<p>
<table border='1' width='90%' align='center' summary='Script output'>
<tr>
<th scope="col">
NAME
</th>
<th scope="col">
VALUE
</th>
<th scope="col">
DESCRIPTION
</th>
</tr>
<tr>
<td>
_4031_dump_bitvec
</td>
<td>
67194879
</td>
<td>
bitvec to specify dumps prior to 4031 error
</td>
</tr>
<tr>
<td>
_4031_dump_interval
</td>
<td>
300
</td>
<td>
Dump 4031 error once for each n-second interv
al
</td>
</tr>
<tr>
<td>
_4031_max_dumps
</td>
<td>
100
</td>
<td>
Maximum number of 4031 dumps for this process
</td>
</tr>
<tr>
<td>
_4031_sga_dump_interval
</td>
<td>
3600
</td>
<td>
Dump 4031 SGA heapdump error once for each n-
second interval
</td>
</tr>
<tr>
<td>
_4031_sga_max_dumps
</td>
<td>
10
</td>
<td>
Maximum number of SGA heapdumps
</td>
</tr>
<tr>
<td>
_NUMA_instance_mapping
</td>
<td>
Not specified
</td>
<td>
Set of nodes that this instance should run on
</td>
</tr>
<tr>
<td>
_NUMA_pool_size
</td>
<td>
Not specified
</td>
<td>
aggregate size in bytes of NUMA pool
</td>
</tr>
<tr>
<td>
_PX_use_large_pool
</td>
<td>
FALSE
</td>
<td>
Use Large Pool as source of PX buffers
</td>
</tr>
<tr>
<td>
_UTL_FILE_FOLLOW_SYMLINKS
</td>
<td>
FALSE
</td>
<td>
UTL_FILE backout event which allows UTL_FILE
to open symlinks
</td>
</tr>
<tr>
<td>
__db_cache_size
</td>
<td>
62914560
</td>
<td>
Actual size of DEFAULT buffer pool for standa
rd block size buffers
</td>
</tr>
<tr>
<td>
__dg_broker_service_names
</td>
<td>
ELEVEN_XPT
</td>
<td>
service names for broker use
</td>
</tr>
<tr>
<td>
__java_pool_size
</td>
<td>
0
</td>
<td>
Actual size in bytes of java pool
</td>
</tr>
<tr>
<td>
__large_pool_size
</td>
<td>
0
</td>
<td>
Actual size in bytes of large pool
</td>
</tr>
<tr>
<td>
__oracle_base
</td>
<td>
C:\oracle
</td>
<td>
ORACLE_BASE
</td>
</tr>
<tr>
<td>
__pga_aggregate_target
</td>
<td>
1073741824
</td>
<td>
Current target size for the aggregate PGA mem
ory consumed
</td>
</tr>
<tr>
<td>
__sga_target
</td>
<td>
0
</td>
<td>
Actual size of SGA
</td>
</tr>
<tr>
<td>
__shared_io_pool_size
</td>
<td>
0
</td>
<td>
Actual size of shared IO pool
</td>
</tr>
<tr>
<td>
__shared_pool_size
</td>
<td>
163577856
</td>
<td>
Actual size in bytes of shared pool
</td>
</tr>
<tr>
<td>
__streams_pool_size
</td>
<td>
0
</td>
<td>
Actual size in bytes of streams pool
</td>
</tr>
<tr>
<td>
_abort_recovery_on_join
</td>
<td>
FALSE
</td>
<td>
if TRUE, abort recovery on join reconfigurati
ons
</td>
</tr>
<tr>
<td>
_accept_versions
</td>
<td>
&nbsp;
</td>
<td>
List of parameters for rolling operation
</td>
</tr>
<tr>
<td>
_active_standby_fast_reconfiguration
</td>
<td>
TRUE
</td>
<td>
if TRUE optimize dlm reconfiguration for acti
ve/standby OPS
</td>
</tr>
<tr>
<td>
_adaptive_direct_read
</td>
<td>
TRUE
</td>
<td>
Adaptive Direct Read
</td>
</tr>
<tr>
<td>
_adaptive_fetch_enabled
</td>
<td>
TRUE
</td>
<td>
enable/disable adaptive fetch in parallel gro
up by
</td>
</tr>
<tr>
<td>
_add_col_optim_enabled
</td>
<td>
TRUE
</td>
<td>
Allows new add column optimization
</td>
</tr>
<tr>
<td>
_add_stale_mv_to_dependency_list
</td>
<td>
TRUE
</td>
<td>
add stale mv to dependency list
</td>
</tr>
<tr>
<td>
_addm_auto_enable
</td>
<td>
TRUE
</td>
<td>
governs whether ADDM gets run automatically a
fter every AWR snapshot
</td>
</tr>
<tr>
<td>
_addm_skiprules
</td>
<td>
&nbsp;
</td>
<td>
comma-separated list of ADDM nodes to skip
</td>
</tr>
<tr>
<td>
_addm_version_check
</td>
<td>
TRUE
</td>
<td>
governs whether ADDM checks the input AWR sna
pshot version
</td>
</tr>
<tr>
<td>
_adjust_literal_replacement
</td>
<td>
FALSE
</td>
<td>
If TRUE, we will adjust the SQL/PLUS output
</td>
</tr>
<tr>
<td>
_affinity_on
</td>
<td>
TRUE
</td>
<td>
enable/disable affinity at run time
</td>
</tr>
<tr>
<td>
_aiowait_timeouts
</td>
<td>
100
</td>
<td>
Number of aiowait timeouts before error is re
ported
</td>
</tr>
<tr>
<td>
_alert_expiration
</td>
<td>
604800
</td>
<td>
seconds before an alert message is moved to e
xception queue
</td>
</tr>
<tr>
<td>
_alert_message_cleanup
</td>
<td>
1
</td>
<td>
Enable Alert Message Cleanup
</td>
</tr>
<tr>
<td>
_alert_message_purge
</td>
<td>
1
</td>
<td>
Enable Alert Message Purge
</td>
</tr>
<tr>
<td>
_alert_post_background
</td>
<td>
1
</td>
<td>
Enable Background Alert Posting
</td>
</tr>
<tr>
<td>
_all_shared_dblinks
</td>
<td>
&nbsp;
</td>
<td>
treat all dblinks as shared
</td>
</tr>
<tr>
<td>
_allocate_creation_order
</td>
<td>
FALSE
</td>
<td>
should files be examined in creation order du
ring allocation
</td>
</tr>
<tr>
<td>
_allocation_update_interval
</td>
<td>
3
</td>
<td>
interval at which successful search in L1 sho
uld be updated
</td>
</tr>
<tr>
<td>
_allow_commutativity
</td>
<td>
TRUE
</td>
<td>
allow for commutativity of +, * when comparin
g expressions
</td>
</tr>
<tr>
<td>
_allow_drop_snapshot_standby_grsp
</td>
<td>
FALSE
</td>
<td>
Allow dropping snapshot standby guaranteed re
store point
</td>
</tr>
<tr>
<td>
_allow_error_simulation
</td>
<td>
FALSE
</td>
<td>
Allow error simulation for testing
</td>
</tr>
<tr>
<td>
_allow_level_without_connect_by
</td>
<td>
FALSE
</td>
<td>
allow level without connect by
</td>
</tr>
<tr>
<td>
_allow_read_only_corruption
</td>
<td>
FALSE
</td>
<td>
allow read-only open even if database is corr
upt
</td>
</tr>
<tr>
<td>
_allow_resetlogs_corruption
</td>
<td>
FALSE
</td>
<td>
allow resetlogs even if it will cause corrupt
ion
</td>
</tr>
<tr>
<td>
_allow_sage_attr
</td>
<td>
TRUE
</td>
<td>
Allow checking Disk Group SAGE Attr
</td>
</tr>
<tr>
<td>
_allow_terminal_recovery_corruption
</td>
<td>
FALSE
</td>
<td>
Finish terminal recovery even if it may cause
 corruption
</td>
</tr>
<tr>
<td>
_alternate_iot_leaf_block_split_points
</td>
<td>
TRUE
</td>
<td>
enable alternate index-organized table leaf-b
lock split-points
</td>
</tr>
<tr>
<td>
_always_anti_join
</td>
<td>
CHOOSE
</td>
<td>
always use this method for anti-join when pos
sible
</td>
</tr>
<tr>
<td>
_always_semi_join
</td>
<td>
CHOOSE
</td>
<td>
always use this method for semi-join when pos
sible
</td>
</tr>
<tr>
<td>
_always_star_transformation
</td>
<td>
FALSE
</td>
<td>
always favor use of star transformation
</td>
</tr>
<tr>
<td>
_app_ctx_vers
</td>
<td>
FALSE
</td>
<td>
enable app ctx versioning
</td>
</tr>
<tr>
<td>
_aq_tm_scanlimit
</td>
<td>
0
</td>
<td>
scan limit for Time Managers to clean up IOT
</td>
</tr>
<tr>
<td>
_arch_corrupted_redo_log
</td>
<td>
0
</td>
<td>
Variable to simulate corruption errors during
 archivals
</td>
</tr>
<tr>
<td>
_arch_io_slaves
</td>
<td>
0
</td>
<td>
ARCH I/O slaves
</td>
</tr>
<tr>
<td>
_array_update_vector_read_enabled
</td>
<td>
FALSE
</td>
<td>
Enable array update vector read
</td>
</tr>
<tr>
<td>
_ash_disk_filter_ratio
</td>
<td>
10
</td>
<td>
Ratio of the number of in-memory samples to t
he number of samples actually written to disk
</td>
</tr>
<tr>
<td>
_ash_disk_write_enable
</td>
<td>
TRUE
</td>
<td>
To enable or disable Active Session History f
lushing
</td>
</tr>
<tr>
<td>
_ash_dummy_test_param
</td>
<td>
0
</td>
<td>
Oracle internal dummy ASH parameter used ONLY
 for testing!
</td>
</tr>
<tr>
<td>
_ash_eflush_trigger
</td>
<td>
66
</td>
<td>
The percentage above which if the in-memory A
SH is full the emergency flusher will be trig
gered
</td>
</tr>
<tr>
<td>
_ash_enable
</td>
<td>
TRUE
</td>
<td>
To enable or disable Active Session sampling
and flushing
</td>
</tr>
<tr>
<td>
_ash_min_mmnl_dump
</td>
<td>
90
</td>
<td>
Minimum Time interval passed to consider MMNL
 Dump
</td>
</tr>
<tr>
<td>
_ash_sample_all
</td>
<td>
FALSE
</td>
<td>
To enable or disable sampling every connected
 session including ones waiting for idle wait
s
</td>
</tr>
<tr>
<td>
_ash_sampling_interval
</td>
<td>
1000
</td>
<td>
Time interval between two successive Active S
ession samples in millisecs
</td>
</tr>
<tr>
<td>
_ash_size
</td>
<td>
1048618
</td>
<td>
To set the size of the in-memory Active Sessi
on History buffers
</td>
</tr>
<tr>
<td>
_asm_acd_chunks
</td>
<td>
1
</td>
<td>
initial ACD chunks created
</td>
</tr>
<tr>
<td>
_asm_allow_only_raw_disks
</td>
<td>
TRUE
</td>
<td>
Discovery only raw devices
</td>
</tr>
<tr>
<td>
_asm_allow_resilver_corruption
</td>
<td>
FALSE
</td>
<td>
Enable disk resilvering for external redundan
cy
</td>
</tr>
<tr>
<td>
_asm_ausize
</td>
<td>
1048576
</td>
<td>
allocation unit size
</td>
</tr>
<tr>
<td>
_asm_blksize
</td>
<td>
4096
</td>
<td>
metadata block size
</td>
</tr>
<tr>
<td>
_asm_compatibility
</td>
<td>
10.1
</td>
<td>
default ASM compatibility level
</td>
</tr>
<tr>
<td>
_asm_dbmsdg_nohdrchk
</td>
<td>
FALSE
</td>
<td>
dbms_diskgroup.checkfile does not check block
 headers
</td>
</tr>
<tr>
<td>
_asm_disk_repair_time
</td>
<td>
14400
</td>
<td>
seconds to wait before dropping a failing dis
k
</td>
</tr>
<tr>
<td>
_asm_emulmax
</td>
<td>
10000
</td>
<td>
max number of concurrent disks to emulate I/O
 errors
</td>
</tr>
<tr>
<td>
_asm_emultimeout
</td>
<td>
0
</td>
<td>
timeout before emulation begins (in 3s ticks)
</td>
</tr>
<tr>
<td>
_asm_kfdpevent
</td>
<td>
0
</td>
<td>
KFDP event
</td>
</tr>
<tr>
<td>
_asm_kfioevent
</td>
<td>
0
</td>
<td>
KFIO event
</td>
</tr>
<tr>
<td>
_asm_libraries
</td>
<td>
ufs
</td>
<td>
library search order for discovery
</td>
</tr>
<tr>
<td>
_asm_maxio
</td>
<td>
1048576
</td>
<td>
Maximum size of individual I/O request
</td>
</tr>
<tr>
<td>
_asm_repairquantum
</td>
<td>
60
</td>
<td>
quantum (in 3s) used to compute elapsed time
for disk drop
</td>
</tr>
<tr>
<td>
_asm_runtime_capability_volume_support
</td>
<td>
FALSE
</td>
<td>
runtime capability for volume support returns
 supported
</td>
</tr>
<tr>
<td>
_asm_skip_resize_check
</td>
<td>
FALSE
</td>
<td>
skip the checking of the clients for s/w comp
atibility for resize
</td>
</tr>
<tr>
<td>
_asm_stripesize
</td>
<td>
131072
</td>
<td>
ASM file stripe size
</td>
</tr>
<tr>
<td>
_asm_stripewidth
</td>
<td>
8
</td>
<td>
ASM file stripe width
</td>
</tr>
<tr>
<td>
_asm_wait_time
</td>
<td>
18
</td>
<td>
Max/imum time to wait before asmb exits
</td>
</tr>
<tr>
<td>
_asmlib_test
</td>
<td>
0
</td>
<td>
Osmlib test event
</td>
</tr>
<tr>
<td>
_asmsid
</td>
<td>
asm
</td>
<td>
ASM instance id
</td>
</tr>
<tr>
<td>
_assm_default
</td>
<td>
TRUE
</td>
<td>
ASSM default
</td>
</tr>
<tr>
<td>
_async_recovery_claims
</td>
<td>
TRUE
</td>
<td>
if TRUE, issue recovery claims asynchronously
</td>
</tr>
<tr>
<td>
_async_recovery_reads
</td>
<td>
TRUE
</td>
<td>
if TRUE, issue recovery reads asynchronously
</td>
</tr>
<tr>
<td>
_async_ts_threshold
</td>
<td>
1
</td>
<td>
check tablespace thresholds asynchronously
</td>
</tr>
<tr>
<td>
_auto_assign_cg_for_sessions
</td>
<td>
FALSE
</td>
<td>
auto assign CGs for sessions
</td>
</tr>
<tr>
<td>
_automatic_maintenance_test
</td>
<td>
0
</td>
<td>
Enable AUTOTASK Test Mode
</td>
</tr>
<tr>
<td>
_automemory_broker_interval
</td>
<td>
3
</td>
<td>
memory broker statistics gathering interval f
or auto memory
</td>
</tr>
<tr>
<td>
_autotask_max_window
</td>
<td>
480
</td>
<td>
Maximum Logical Maintenance Window Length in
minutes
</td>
</tr>
<tr>
<td>
_autotask_min_window
</td>
<td>
15
</td>
<td>
Minimum Maintenance Window Length in minutes
</td>
</tr>
<tr>
<td>
_autotune_gtx_idle_time
</td>
<td>
600
</td>
<td>
idle time to trigger auto-shutdown a gtx back
ground process
</td>
</tr>
<tr>
<td>
_autotune_gtx_interval
</td>
<td>
5
</td>
<td>
interval to autotune global transaction backg
round processes
</td>
</tr>
<tr>
<td>
_autotune_gtx_threshold
</td>
<td>
60
</td>
<td>
auto-tune threshold for degree of global tran
saction concurrency
</td>
</tr>
<tr>
<td>
_avoid_prepare
</td>
<td>
TRUE
</td>
<td>
if TRUE, do not prepare a buffer when the mas
ter is local
</td>
</tr>
<tr>
<td>
_aw_row_source_enabled
</td>
<td>
TRUE
</td>
<td>
Enables AW Row Source instead of collection i
terator
</td>
</tr>
<tr>
<td>
_awr_corrupt_mode
</td>
<td>
FALSE
</td>
<td>
AWR Corrupt Mode
</td>
</tr>
<tr>
<td>
_awr_disabled_flush_tables
</td>
<td>
&nbsp;
</td>
<td>
Disable flushing of specified AWR tables
</td>
</tr>
<tr>
<td>
_awr_flush_threshold_metrics
</td>
<td>
TRUE
</td>
<td>
Enable/Disable Flushing AWR Threshold Metrics
</td>
</tr>
<tr>
<td>
_awr_flush_workload_metrics
</td>
<td>
FALSE
</td>
<td>
Enable/Disable Flushing AWR Workload Metrics
</td>
</tr>
<tr>
<td>
_awr_mmon_cpuusage
</td>
<td>
TRUE
</td>
<td>
Enable/disable AWR MMON CPU Usage Tracking
</td>
</tr>
<tr>
<td>
_awr_restrict_mode
</td>
<td>
FALSE
</td>
<td>
AWR Restrict Mode
</td>
</tr>
<tr>
<td>
_awr_sql_child_limit
</td>
<td>
200
</td>
<td>
Setting for AWR SQL Child Limit
</td>
</tr>
<tr>
<td>
_b_tree_bitmap_plans
</td>
<td>
TRUE
</td>
<td>
enable the use of bitmap plans for tables w.
only B-tree indexes
</td>
</tr>
<tr>
<td>
_backup_disk_io_slaves
</td>
<td>
0
</td>
<td>
BACKUP Disk I/O slaves
</td>
</tr>
<tr>
<td>
_backup_encrypt_opt_mode
</td>
<td>
4294967294
</td>
<td>
specifies encryption block optimization mode
</td>
</tr>
<tr>
<td>
_backup_io_pool_size
</td>
<td>
1048576
</td>
<td>
memory to reserve from the large pool
</td>
</tr>
<tr>
<td>
_backup_kgc_bufsz
</td>
<td>
0
</td>
<td>
specifies buffer size to be used by BZIP2 com
pression
</td>
</tr>
<tr>
<td>
_backup_kgc_memlevel
</td>
<td>
8
</td>
<td>
specifies memory level for ZLIB compression
</td>
</tr>
<tr>
<td>
_backup_kgc_niters
</td>
<td>
0
</td>
<td>
specifies number of iterations done by BZIP2
compression
</td>
</tr>
<tr>
<td>
_backup_kgc_perflevel
</td>
<td>
1
</td>
<td>
specifies compression (performance) level for
 ZLIB compression
</td>
</tr>
<tr>
<td>
_backup_kgc_scheme
</td>
<td>
ZLIB
</td>
<td>
specifies compression scheme
</td>
</tr>
<tr>
<td>
_backup_kgc_type
</td>
<td>
0
</td>
<td>
specifies compression type used by kgc BZIP2
compression
</td>
</tr>
<tr>
<td>
_backup_kgc_windowbits
</td>
<td>
15
</td>
<td>
specifies window size for ZLIB compression
</td>
</tr>
<tr>
<td>
_backup_ksfq_bufcnt
</td>
<td>
0
</td>
<td>
number of the ksfq buffers used for backup/re
store
</td>
</tr>
<tr>
<td>
_backup_ksfq_bufcnt_max
</td>
<td>
0
</td>
<td>
maximum number of the ksfq buffer used for ba
ckup/restore
</td>
</tr>
<tr>
<td>
_backup_ksfq_bufsz
</td>
<td>
0
</td>
<td>
size of the ksfq buffer used for backup/resto
re
</td>
</tr>
<tr>
<td>
_backup_max_gap_size
</td>
<td>
4294967294
</td>
<td>
largest gap in an incremental/optimized backu
p buffer, in bytes
</td>
</tr>
<tr>
<td>
_bct_bitmaps_per_file
</td>
<td>
8
</td>
<td>
number of bitmaps to store for each datafile
</td>
</tr>
<tr>
<td>
_bct_buffer_allocation_max
</td>
<td>
104857600
</td>
<td>
maximum size of all change tracking buffer al
locations, in bytes
</td>
</tr>
<tr>
<td>
_bct_buffer_allocation_min_extents
</td>
<td>
1
</td>
<td>
mininum number of extents to allocate per buf
fer allocation
</td>
</tr>
<tr>
<td>
_bct_buffer_allocation_size
</td>
<td>
2097152
</td>
<td>
size of one change tracking buffer allocation
, in bytes
</td>
</tr>
<tr>
<td>
_bct_chunk_size
</td>
<td>
0
</td>
<td>
change tracking datafile chunk size, in bytes
</td>
</tr>
<tr>
<td>
_bct_crash_reserve_size
</td>
<td>
262144
</td>
<td>
change tracking reserved crash recovery SGA s
pace, in bytes
</td>
</tr>
<tr>
<td>
_bct_file_block_size
</td>
<td>
0
</td>
<td>
block size of change tracking file, in bytes
</td>
</tr>
<tr>
<td>
_bct_file_extent_size
</td>
<td>
0
</td>
<td>
extent size of change tracking file, in bytes
</td>
</tr>
<tr>
<td>
_bct_fixtab_file
</td>
<td>
&nbsp;
</td>
<td>
change tracking file for fixed tables
</td>
</tr>
<tr>
<td>
_bct_initial_private_dba_buffer_size
</td>
<td>
0
</td>
<td>
initial number of entries in the private chan
ge tracking dba buffers
</td>
</tr>
<tr>
<td>
_bct_public_dba_buffer_size
</td>
<td>
0
</td>
<td>
total size of all public change tracking dba
buffers, in bytes
</td>
</tr>
<tr>
<td>
_bitmap_or_improvement_enabled
</td>
<td>
TRUE
</td>
<td>
controls extensions to partition pruning for
general predicates
</td>
</tr>
<tr>
<td>
_block_change_tracking
</td>
<td>
TRUE
</td>
<td>
change tracking possible
</td>
</tr>
<tr>
<td>
_blocking_sess_graph_cache_size
</td>
<td>
&nbsp;
</td>
<td>
blocking session graph cache size in bytes
</td>
</tr>
<tr>
<td>
_blocks_per_cache_server
</td>
<td>
64
</td>
<td>
number of consecutive blocks per global cache
 server
</td>
</tr>
<tr>
<td>
_bloom_filter_debug
</td>
<td>
0
</td>
<td>
debug level for bloom filtering
</td>
</tr>
<tr>
<td>
_bloom_filter_enabled
</td>
<td>
TRUE
</td>
<td>
enables or disables bloom filter
</td>
</tr>
<tr>
<td>
_bloom_predicate_enabled
</td>
<td>
FALSE
</td>
<td>
enables or disables bloom filter predicate pu
shdown
</td>
</tr>
<tr>
<td>
_bloom_pruning_enabled
</td>
<td>
TRUE
</td>
<td>
Enable partition pruning using bloom filterin
g
</td>
</tr>
<tr>
<td>
_bloom_vector_elements
</td>
<td>
0
</td>
<td>
number of elements in a bloom filter vector
</td>
</tr>
<tr>
<td>
_bsln_adaptive_thresholds_enabled
</td>
<td>
TRUE
</td>
<td>
Adaptive Thresholds Enabled
</td>
</tr>
<tr>
<td>
_bt_mmv_query_rewrite_enabled
</td>
<td>
TRUE
</td>
<td>
allow rewrites with multiple MVs and base tab
les
</td>
</tr>
<tr>
<td>
_buffer_busy_wait_timeout
</td>
<td>
100
</td>
<td>
buffer busy wait time in centiseconds
</td>
</tr>
<tr>
<td>
_buffered_publisher_flow_control_threshold
</td>
<td>
0
</td>
<td>
Flow control threshold for buffered publisher
s except capture
</td>
</tr>
<tr>
<td>
_bufq_stop_flow_control
</td>
<td>
FALSE
</td>
<td>
Stop enforcing flow control for buffered queu
es
</td>
</tr>
<tr>
<td>
_build_deferred_mv_skipping_mvlog_update
</td>
<td>
FALSE
</td>
<td>
DEFERRED MV creation skipping MV log setup up
date
</td>
</tr>
<tr>
<td>
_bump_highwater_mark_count
</td>
<td>
0
</td>
<td>
how many blocks should we allocate per free l
ist on advancing HWM
</td>
</tr>
<tr>
<td>
_bwr_for_flushed_pi
</td>
<td>
TRUE
</td>
<td>
if TRUE, generate a BWR for a flushed PI
</td>
</tr>
<tr>
<td>
_cache_stats_monitor
</td>
<td>
FALSE
</td>
<td>
if TRUE, enable cache stats monitoring
</td>
</tr>
<tr>
<td>
_capture_buffer_size
</td>
<td>
65536
</td>
<td>
To set the size of the PGA I/O recording buff
ers
</td>
</tr>
<tr>
<td>
_capture_publisher_flow_control_threshold
</td>
<td>
0
</td>
<td>
Flow control threshold for capture publishers
</td>
</tr>
<tr>
<td>
_case_sensitive_logon
</td>
<td>
TRUE
</td>
<td>
case sensitive logon enabled
</td>
</tr>
<tr>
<td>
_cgs_reconfig_timeout
</td>
<td>
1000
</td>
<td>
CGS reconfiguration timeout interval
</td>
</tr>
<tr>
<td>
_cgs_send_timeout
</td>
<td>
300
</td>
<td>
CGS send timeout value
</td>
</tr>
<tr>
<td>
_cgs_tickets
</td>
<td>
1000
</td>
<td>
CGS messaging tickets
</td>
</tr>
<tr>
<td>
_check_block_after_checksum
</td>
<td>
TRUE
</td>
<td>
perform block check after checksum if both ar
e turned on
</td>
</tr>
<tr>
<td>
_check_block_new_invariant_for_flashback
</td>
<td>
FALSE
</td>
<td>
check block new invariant for flashback
</td>
</tr>
<tr>
<td>
_check_ts_threshold
</td>
<td>
0
</td>
<td>
check tablespace thresholds
</td>
</tr>
<tr>
<td>
_cleanup_rollback_entries
</td>
<td>
100
</td>
<td>
no. of undo entries to apply per transaction
cleanup
</td>
</tr>
<tr>
<td>
_client_result_cache_bypass
</td>
<td>
FALSE
</td>
<td>
bypass the client result cache
</td>
</tr>
<tr>
<td>
_close_cached_open_cursors
</td>
<td>
FALSE
</td>
<td>
close cursors cached by PL/SQL at each commit
</td>
</tr>
<tr>
<td>
_cluster_library
</td>
<td>
clss
</td>
<td>
cluster library selection
</td>
</tr>
<tr>
<td>
_clusterwide_global_transactions
</td>
<td>
TRUE
</td>
<td>
enable/disable clusterwide global transaction
s
</td>
</tr>
<tr>
<td>
_collapse_wait_history
</td>
<td>
FALSE
</td>
<td>
collapse wait history
</td>
</tr>
<tr>
<td>
_collect_undo_stats
</td>
<td>
TRUE
</td>
<td>
Collect Statistics v$undostat
</td>
</tr>
<tr>
<td>
_column_compression_factor
</td>
<td>
0
</td>
<td>
Column compression ratio
</td>
</tr>
<tr>
<td>
_column_elimination_off
</td>
<td>
FALSE
</td>
<td>
turn off predicate-only column elimination
</td>
</tr>
<tr>
<td>
_column_tracking_level
</td>
<td>
1
</td>
<td>
column usage tracking
</td>
</tr>
<tr>
<td>
_compilation_call_heap_extent_size
</td>
<td>
16384
</td>
<td>
Size of the compilation call heaps extents
</td>
</tr>
<tr>
<td>
_complex_view_merging
</td>
<td>
TRUE
</td>
<td>
enable complex view merging
</td>
</tr>
<tr>
<td>
_compression_above_cache
</td>
<td>
0
</td>
<td>
number of recompression above cache for sanit
y check
</td>
</tr>
<tr>
<td>
_compression_advisor
</td>
<td>
0
</td>
<td>
Compression advisor
</td>
</tr>
<tr>
<td>
_compression_chain
</td>
<td>
50
</td>
<td>
percentage of chained rows allowed for Compre
ssion
</td>
</tr>
<tr>
<td>
_controlfile_block_size
</td>
<td>
0
</td>
<td>
control file block size in bytes
</td>
</tr>
<tr>
<td>
_controlfile_enqueue_dump
</td>
<td>
FALSE
</td>
<td>
dump the system states after controlfile enqu
eue timeout
</td>
</tr>
<tr>
<td>
_controlfile_enqueue_holding_time
</td>
<td>
780
</td>
<td>
control file enqueue max holding time in seco
nds
</td>
</tr>
<tr>
<td>
_controlfile_enqueue_timeout
</td>
<td>
900
</td>
<td>
control file enqueue timeout in seconds
</td>
</tr>
<tr>
<td>
_controlfile_section_init_size
</td>
<td>
&nbsp;
</td>
<td>
control file initial section size
</td>
</tr>
<tr>
<td>
_controlfile_section_max_expand
</td>
<td>
&nbsp;
</td>
<td>
control file max expansion rate
</td>
</tr>
<tr>
<td>
_controlfile_update_check
</td>
<td>
OFF
</td>
<td>
controlfile update sanity check
</td>
</tr>
<tr>
<td>
_convert_set_to_join
</td>
<td>
FALSE
</td>
<td>
enables conversion of set operator to join
</td>
</tr>
<tr>
<td>
_coord_message_buffer
</td>
<td>
0
</td>
<td>
parallel recovery coordinator side extra mess
age buffer size
</td>
</tr>
<tr>
<td>
_corrupted_rollback_segments
</td>
<td>
&nbsp;
</td>
<td>
corrupted undo segment list
</td>
</tr>
<tr>
<td>
_cost_equality_semi_join
</td>
<td>
TRUE
</td>
<td>
enables costing of equality semi-join
</td>
</tr>
<tr>
<td>
_cp_num_hash_latches
</td>
<td>
1
</td>
<td>
connection pool number of hash latches
</td>
</tr>
<tr>
<td>
_cpu_to_io
</td>
<td>
0
</td>
<td>
divisor for converting CPU cost to I/O cost
</td>
</tr>
<tr>
<td>
_cr_grant_global_role
</td>
<td>
TRUE
</td>
<td>
if TRUE, grant lock for CR requests when bloc
k is in global role
</td>
</tr>
<tr>
<td>
_cr_grant_local_role
</td>
<td>
AUTO
</td>
<td>
turn 3-way CR grants off, make it automatic,
or turn it on
</td>
</tr>
<tr>
<td>
_cr_server_log_flush
</td>
<td>
TRUE
</td>
<td>
if TRUE, flush redo log before serving a CR b
uffer
</td>
</tr>
<tr>
<td>
_cursor_bind_capture_area_size
</td>
<td>
400
</td>
<td>
maximum size of the cursor bind capture area
</td>
</tr>
<tr>
<td>
_cursor_bind_capture_interval
</td>
<td>
900
</td>
<td>
interval (in seconds) between two bind captur
e for a cursor
</td>
</tr>
<tr>
<td>
_cursor_db_buffers_pinned
</td>
<td>
147
</td>
<td>
additional number of buffers a cursor can pin
 at once
</td>
</tr>
<tr>
<td>
_cursor_features_enabled
</td>
<td>
2
</td>
<td>
Shared cursor features enabled bits.
</td>
</tr>
<tr>
<td>
_cursor_plan_enabled
</td>
<td>
TRUE
</td>
<td>
enable collection and display of cursor plans
</td>
</tr>
<tr>
<td>
_cursor_plan_hash_version
</td>
<td>
1
</td>
<td>
version of cursor plan hash value
</td>
</tr>
<tr>
<td>
_cursor_plan_unparse_enabled
</td>
<td>
TRUE
</td>
<td>
enables/disables using unparse to build proje
ction/predicates
</td>
</tr>
<tr>
<td>
_cursor_stats_bucket
</td>
<td>
15
</td>
<td>
Hash table buckets for cursor stats (2^).
</td>
</tr>
<tr>
<td>
_cursor_stats_heap
</td>
<td>
4
</td>
<td>
Heaps/latches for cursor stats.
</td>
</tr>
<tr>
<td>
_cvw_enable_weak_checking
</td>
<td>
TRUE
</td>
<td>
enable weak view checking
</td>
</tr>
<tr>
<td>
_db_aging_cool_count
</td>
<td>
1
</td>
<td>
Touch count set when buffer cooled
</td>
</tr>
<tr>
<td>
_db_aging_freeze_cr
</td>
<td>
FALSE
</td>
<td>
Make CR buffers always be too cold to keep in
 cache
</td>
</tr>
<tr>
<td>
_db_aging_hot_criteria
</td>
<td>
2
</td>
<td>
Touch count which sends a buffer to head of r
eplacement list
</td>
</tr>
<tr>
<td>
_db_aging_stay_count
</td>
<td>
0
</td>
<td>
Touch count set when buffer moved to head of
replacement list
</td>
</tr>
<tr>
<td>
_db_aging_touch_time
</td>
<td>
3
</td>
<td>
Touch count which sends a buffer to head of r
eplacement list
</td>
</tr>
<tr>
<td>
_db_always_check_system_ts
</td>
<td>
TRUE
</td>
<td>
Always perform block check and checksum for S
ystem tablespace
</td>
</tr>
<tr>
<td>
_db_block_adjcheck
</td>
<td>
TRUE
</td>
<td>
adjacent cache buffer checks - low blkchk ove
rwrite parameter
</td>
</tr>
<tr>
<td>
_db_block_adjchk_level
</td>
<td>
0
</td>
<td>
adjacent cache buffer check level
</td>
</tr>
<tr>
<td>
_db_block_align_direct_read
</td>
<td>
TRUE
</td>
<td>
Align Direct Reads
</td>
</tr>
<tr>
<td>
_db_block_bad_write_check
</td>
<td>
FALSE
</td>
<td>
enable bad write checks
</td>
</tr>
<tr>
<td>
_db_block_buffers
</td>
<td>
7470
</td>
<td>
Number of database blocks cached in memory: h
idden parameter
</td>
</tr>
<tr>
<td>
_db_block_cache_clone
</td>
<td>
FALSE
</td>
<td>
Always clone data blocks on get (for debuggin
g)
</td>
</tr>
<tr>
<td>
_db_block_cache_history
</td>
<td>
0
</td>
<td>
buffer header tracing (non-zero only when deb
ugging)
</td>
</tr>
<tr>
<td>
_db_block_cache_history_level
</td>
<td>
2
</td>
<td>
buffer header tracing level
</td>
</tr>
<tr>
<td>
_db_block_cache_num_umap
</td>
<td>
0
</td>
<td>
number of unmapped buffers (for tracking swap
 calls on blocks)
</td>
</tr>
<tr>
<td>
_db_block_cache_protect
</td>
<td>
FALSE
</td>
<td>
protect database blocks (true only when debug
ging)
</td>
</tr>
<tr>
<td>
_db_block_cache_protect_internal
</td>
<td>
0
</td>
<td>
protect database blocks (for strictly interna
l use only)
</td>
</tr>
<tr>
<td>
_db_block_check_for_debug
</td>
<td>
FALSE
</td>
<td>
Check more and dump block before image for de
bugging
</td>
</tr>
<tr>
<td>
_db_block_check_objtyp
</td>
<td>
TRUE
</td>
<td>
check objd and typ on cache disk read
</td>
</tr>
<tr>
<td>
_db_block_corruption_recovery_threshold
</td>
<td>
5
</td>
<td>
threshold number of block recovery attempts
</td>
</tr>
<tr>
<td>
_db_block_do_full_mbreads
</td>
<td>
FALSE
</td>
<td>
do full block read even if some blocks are in
 cache
</td>
</tr>
<tr>
<td>
_db_block_hash_buckets
</td>
<td>
16384
</td>
<td>
Number of database block hash buckets
</td>
</tr>
<tr>
<td>
_db_block_hash_latches
</td>
<td>
1024
</td>
<td>
Number of database block hash latches
</td>
</tr>
<tr>
<td>
_db_block_header_guard_level
</td>
<td>
0
</td>
<td>
number of extra buffer headers to use as guar
d pages
</td>
</tr>
<tr>
<td>
_db_block_hi_priority_batch_size
</td>
<td>
0
</td>
<td>
Fraction of writes for high priority reasons
</td>
</tr>
<tr>
<td>
_db_block_known_clean_pct
</td>
<td>
2
</td>
<td>
Initial Percentage of buffers to maintain kno
wn clean
</td>
</tr>
<tr>
<td>
_db_block_lru_latches
</td>
<td>
8
</td>
<td>
number of lru latches
</td>
</tr>
<tr>
<td>
_db_block_max_cr_dba
</td>
<td>
6
</td>
<td>
Maximum Allowed Number of CR buffers per dba
</td>
</tr>
<tr>
<td>
_db_block_max_scan_pct
</td>
<td>
40
</td>
<td>
Percentage of buffers to inspect when looking
 for free
</td>
</tr>
<tr>
<td>
_db_block_med_priority_batch_size
</td>
<td>
0
</td>
<td>
Fraction of writes for medium priority reason
s
</td>
</tr>
<tr>
<td>
_db_block_numa
</td>
<td>
1
</td>
<td>
Number of NUMA nodes
</td>
</tr>
<tr>
<td>
_db_block_prefetch_fast_longjumps_enabled
</td>
<td>
TRUE
</td>
<td>
Batched IO enable fast longjumps
</td>
</tr>
<tr>
<td>
_db_block_prefetch_limit
</td>
<td>
0
</td>
<td>
Prefetch limit in blocks
</td>
</tr>
<tr>
<td>
_db_block_prefetch_override
</td>
<td>
0
</td>
<td>
Prefetch force override in blocks
</td>
</tr>
<tr>
<td>
_db_block_prefetch_private_cache_enabled
</td>
<td>
TRUE
</td>
<td>
Batched IO enable private cache
</td>
</tr>
<tr>
<td>
_db_block_prefetch_quota
</td>
<td>
10
</td>
<td>
Prefetch quota as a percent of cache size
</td>
</tr>
<tr>
<td>
_db_block_prefetch_skip_reading_enabled
</td>
<td>
TRUE
</td>
<td>
Batched IO enable skip reading buffers
</td>
</tr>
<tr>
<td>
_db_block_table_scan_buffer_size
</td>
<td>
4194304
</td>
<td>
Size of shared table scan read buffer
</td>
</tr>
<tr>
<td>
_db_block_temp_redo
</td>
<td>
FALSE
</td>
<td>
generate redo for temp blocks
</td>
</tr>
<tr>
<td>
_db_block_trace_protect
</td>
<td>
FALSE
</td>
<td>
trace buffer protect calls
</td>
</tr>
<tr>
<td>
_db_block_vlm_check
</td>
<td>
FALSE
</td>
<td>
check of rvlm mapping leaks (for debugging)
</td>
</tr>
<tr>
<td>
_db_block_vlm_leak_threshold
</td>
<td>
3
</td>
<td>
Threshold for allowable vlm leaks
</td>
</tr>
<tr>
<td>
_db_blocks_per_hash_latch
</td>
<td>
&nbsp;
</td>
<td>
Number of blocks per hash latch
</td>
</tr>
<tr>
<td>
_db_cache_advice_batch_size
</td>
<td>
128
</td>
<td>
cache advisory simulation batch size
</td>
</tr>
<tr>
<td>
_db_cache_advice_sample_factor
</td>
<td>
4
</td>
<td>
cache advisory sampling factor
</td>
</tr>
<tr>
<td>
_db_cache_crx_check
</td>
<td>
FALSE
</td>
<td>
check for costly crx examination functions
</td>
</tr>
<tr>
<td>
_db_cache_pre_warm
</td>
<td>
TRUE
</td>
<td>
Buffer Cache Pre-Warm Enabled : hidden parame
ter
</td>
</tr>
<tr>
<td>
_db_cache_process_cr_pin_max
</td>
<td>
&nbsp;
</td>
<td>
maximum number of cr pins a process may have
</td>
</tr>
<tr>
<td>
_db_change_notification_enable
</td>
<td>
TRUE
</td>
<td>
enable db change notification
</td>
</tr>
<tr>
<td>
_db_disable_temp_encryption
</td>
<td>
FALSE
</td>
<td>
Diable Temp Encryption for Spills
</td>
</tr>
<tr>
<td>
_db_fast_obj_check
</td>
<td>
FALSE
</td>
<td>
enable fast object drop sanity check
</td>
</tr>
<tr>
<td>
_db_fast_obj_ckpt
</td>
<td>
TRUE
</td>
<td>
enable fast object checkpoint
</td>
</tr>
<tr>
<td>
_db_fast_obj_truncate
</td>
<td>
TRUE
</td>
<td>
enable fast object truncate
</td>
</tr>
<tr>
<td>
_db_file_direct_io_count
</td>
<td>
1048576
</td>
<td>
Sequential I/O buf size
</td>
</tr>
<tr>
<td>
_db_file_exec_read_count
</td>
<td>
124
</td>
<td>
multiblock read count for regular clients
</td>
</tr>
<tr>
<td>
_db_file_format_io_buffers
</td>
<td>
4
</td>
<td>
Block formatting I/O buf count
</td>
</tr>
<tr>
<td>
_db_file_noncontig_mblock_read_count
</td>
<td>
11
</td>
<td>
number of noncontiguous db blocks to be prefe
tched
</td>
</tr>
<tr>
<td>
_db_file_optimizer_read_count
</td>
<td>
8
</td>
<td>
multiblock read count for regular clients
</td>
</tr>
<tr>
<td>
_db_handles
</td>
<td>
250
</td>
<td>
System-wide simultaneous buffer operations
</td>
</tr>
<tr>
<td>
_db_handles_cached
</td>
<td>
5
</td>
<td>
Buffer handles cached each process
</td>
</tr>
<tr>
<td>
_db_hot_block_tracking
</td>
<td>
FALSE
</td>
<td>
track hot blocks for hash latch contention
</td>
</tr>
<tr>
<td>
_db_index_block_checking
</td>
<td>
TRUE
</td>
<td>
index block checking override parameter
</td>
</tr>
<tr>
<td>
_db_large_dirty_queue
</td>
<td>
25
</td>
<td>
Number of buffers which force dirty queue to
be written
</td>
</tr>
<tr>
<td>
_db_lost_write_checking
</td>
<td>
FALSE
</td>
<td>
Enable scn based lost write detection mechani
sm
</td>
</tr>
<tr>
<td>
_db_mttr_advice
</td>
<td>
ON
</td>
<td>
MTTR advisory
</td>
</tr>
<tr>
<td>
_db_mttr_partitions
</td>
<td>
0
</td>
<td>
number of partitions for MTTR advisory
</td>
</tr>
<tr>
<td>
_db_mttr_sample_factor
</td>
<td>
64
</td>
<td>
MTTR simulation sampling factor
</td>
</tr>
<tr>
<td>
_db_mttr_sim_target
</td>
<td>
&nbsp;
</td>
<td>
MTTR simulation targets
</td>
</tr>
<tr>
<td>
_db_mttr_sim_trace_size
</td>
<td>
256
</td>
<td>
MTTR simulation trace size
</td>
</tr>
<tr>
<td>
_db_mttr_trace_to_alert
</td>
<td>
FALSE
</td>
<td>
dump trace entries to alert file
</td>
</tr>
<tr>
<td>
_db_noarch_disble_optim
</td>
<td>
FALSE
</td>
<td>
Image redo logging (NOARCHIVEMODE)
</td>
</tr>
<tr>
<td>
_db_num_evict_waitevents
</td>
<td>
64
</td>
<td>
number of evict wait events
</td>
</tr>
<tr>
<td>
_db_obj_enable_ksr
</td>
<td>
TRUE
</td>
<td>
enable ksr in object checkpoint/reuse
</td>
</tr>
<tr>
<td>
_db_percent_hot_default
</td>
<td>
50
</td>
<td>
Percent of default buffer pool considered hot
</td>
</tr>
<tr>
<td>
_db_percent_hot_keep
</td>
<td>
0
</td>
<td>
Percent of keep buffer pool considered hot
</td>
</tr>
<tr>
<td>
_db_percent_hot_recycle
</td>
<td>
0
</td>
<td>
Percent of recycle buffer pool considered hot
</td>
</tr>
<tr>
<td>
_db_percpu_create_cachesize
</td>
<td>
2
</td>
<td>
size of cache created per cpu in deferred cac
he create
</td>
</tr>
<tr>
<td>
_db_recovery_temporal_file_dest
</td>
<td>
&nbsp;
</td>
<td>
default database recovery temporal file locat
ion
</td>
</tr>
<tr>
<td>
_db_required_percent_fairshare_usage
</td>
<td>
10
</td>
<td>
percent of fairshare a processor group should
 always use
</td>
</tr>
<tr>
<td>
_db_row_overlap_checking
</td>
<td>
TRUE
</td>
<td>
row overlap checking override parameter for d
ata/index blocks
</td>
</tr>
<tr>
<td>
_db_todefer_cache_create
</td>
<td>
TRUE
</td>
<td>
buffer cache deferred create
</td>
</tr>
<tr>
<td>
_db_writer_chunk_writes
</td>
<td>
0
</td>
<td>
Number of writes DBWR should wait for
</td>
</tr>
<tr>
<td>
_db_writer_coalesce_area_size
</td>
<td>
622592
</td>
<td>
Size of memory allocated to dbwriter for coal
escing writes
</td>
</tr>
<tr>
<td>
_db_writer_coalesce_write_limit
</td>
<td>
131072
</td>
<td>
Limit on size of coalesced write
</td>
</tr>
<tr>
<td>
_db_writer_flush_imu
</td>
<td>
TRUE
</td>
<td>
If FALSE, DBWR will not downgrade IMU txns fo
r AGING
</td>
</tr>
<tr>
<td>
_db_writer_histogram_statistics
</td>
<td>
FALSE
</td>
<td>
maintain dbwr histogram statistics in x$kcbbh
s
</td>
</tr>
<tr>
<td>
_db_writer_max_writes
</td>
<td>
0
</td>
<td>
Max number of outstanding DB Writer IOs
</td>
</tr>
<tr>
<td>
_db_writer_nomemcopy_coalesce
</td>
<td>
FALSE
</td>
<td>
Enable DBWR no-memcopy coalescing
</td>
</tr>
<tr>
<td>
_db_writer_verify_writes
</td>
<td>
FALSE
</td>
<td>
Enable lost write detection mechanism
</td>
</tr>
<tr>
<td>
_dbg_proc_startup
</td>
<td>
FALSE
</td>
<td>
debug process startup
</td>
</tr>
<tr>
<td>
_dbms_sql_security_level
</td>
<td>
1
</td>
<td>
Security level in DBMS_SQL
</td>
</tr>
<tr>
<td>
_dbwr_async_io
</td>
<td>
TRUE
</td>
<td>
Enable dbwriter asynchronous writes
</td>
</tr>
<tr>
<td>
_dbwr_scan_interval
</td>
<td>
300
</td>
<td>
dbwriter scan interval
</td>
</tr>
<tr>
<td>
_dbwr_tracing
</td>
<td>
0
</td>
<td>
Enable dbwriter tracing
</td>
</tr>
<tr>
<td>
_dde_flood_control_init
</td>
<td>
TRUE
</td>
<td>
Initialize Flood Control at database open
</td>
</tr>
<tr>
<td>
_dead_process_scan_interval
</td>
<td>
60
</td>
<td>
PMON dead process scan interval
</td>
</tr>
<tr>
<td>
_deadlock_diagnostic_level
</td>
<td>
2
</td>
<td>
automatic deadlock resolution diagnostics lev
el
</td>
</tr>
<tr>
<td>
_deadlock_resolution_incidents_enabled
</td>
<td>
TRUE
</td>
<td>
create incidents during deadlock resolution
</td>
</tr>
<tr>
<td>
_deadlock_resolution_level
</td>
<td>
1
</td>
<td>
automatic deadlock resolution level
</td>
</tr>
<tr>
<td>
_deadlock_resolution_min_wait_timeout_secs
</td>
<td>
60
</td>
<td>
the minimum wait timeout required for deadloc
k resolution
</td>
</tr>
<tr>
<td>
_deadlock_resolution_signal_process_thresh_se
cs
</td>
<td>
60
</td>
<td>
the amount of time given to process a deadloc
k resolution signal
</td>
</tr>
<tr>
<td>
_debug_enable
</td>
<td>
FALSE
</td>
<td>
wait for debug
</td>
</tr>
<tr>
<td>
_dedicated_server_poll_count
</td>
<td>
10
</td>
<td>
dedicated server poll count
</td>
</tr>
<tr>
<td>
_dedicated_server_post_wait
</td>
<td>
FALSE
</td>
<td>
dedicated server post/wait
</td>
</tr>
<tr>
<td>
_dedicated_server_post_wait_call
</td>
<td>
FALSE
</td>
<td>
dedicated server post/wait call
</td>
</tr>
<tr>
<td>
_default_encrypt_alg
</td>
<td>
0
</td>
<td>
default encryption algorithm
</td>
</tr>
<tr>
<td>
_default_non_equality_sel_check
</td>
<td>
TRUE
</td>
<td>
sanity check on default selectivity for like/
range predicate
</td>
</tr>
<tr>
<td>
_defer_log_boundary_ckpt
</td>
<td>
TRUE
</td>
<td>
defer media recovery checkpoint at log bounda
ry
</td>
</tr>
<tr>
<td>
_defer_log_count
</td>
<td>
2
</td>
<td>
Number of log boundaries media recovery check
point lags behind
</td>
</tr>
<tr>
<td>
_delay_index_maintain
</td>
<td>
TRUE
</td>
<td>
delays index maintenance until after MV is re
freshed
</td>
</tr>
<tr>
<td>
_desired_readmem_rate
</td>
<td>
70
</td>
<td>
The desired percentage of redo reading from m
emory
</td>
</tr>
<tr>
<td>
_diag_adr_auto_purge
</td>
<td>
TRUE
</td>
<td>
Enable/disable ADR MMON Auto Purging
</td>
</tr>
<tr>
<td>
_diag_adr_enabled
</td>
<td>
TRUE
</td>
<td>
Parameter to enable/disable Diag ADR
</td>
</tr>
<tr>
<td>
_diag_adr_test_param
</td>
<td>
0
</td>
<td>
Test parameter for Diagnosability
</td>
</tr>
<tr>
<td>
_diag_backward_compat
</td>
<td>
TRUE
</td>
<td>
Backward Compatibility for Diagnosability
</td>
</tr>
<tr>
<td>
_diag_cc_enabled
</td>
<td>
TRUE
</td>
<td>
Parameter to enable/disable Diag Call Context
</td>
</tr>
<tr>
<td>
_diag_conf_cap_enabled
</td>
<td>
TRUE
</td>
<td>
Parameter to enable/disable Diag Configuratio
n Capture
</td>
</tr>
<tr>
<td>
_diag_daemon
</td>
<td>
TRUE
</td>
<td>
start DIAG daemon
</td>
</tr>
<tr>
<td>
_diag_dde_async_age_limit
</td>
<td>
300
</td>
<td>
diag dde async actions: message age limit (in
 seconds)
</td>
</tr>
<tr>
<td>
_diag_dde_async_cputime_limit
</td>
<td>
300
</td>
<td>
diag dde async actions: action cputime limit
(in seconds)
</td>
</tr>
<tr>
<td>
_diag_dde_async_mode
</td>
<td>
1
</td>
<td>
diag dde async actions: dispatch mode
</td>
</tr>
<tr>
<td>
_diag_dde_async_msg_capacity
</td>
<td>
1024
</td>
<td>
diag dde async actions: message buffer capaci
ty
</td>
</tr>
<tr>
<td>
_diag_dde_async_msgs
</td>
<td>
50
</td>
<td>
diag dde async actions: number of preallocate
d message buffers
</td>
</tr>
<tr>
<td>
_diag_dde_async_process_rate
</td>
<td>
5
</td>
<td>
diag dde async actions: message processing ra
te - per loop
</td>
</tr>
<tr>
<td>
_diag_dde_async_runtime_limit
</td>
<td>
900
</td>
<td>
diag dde async actions: action runtime limit
(in seconds)
</td>
</tr>
<tr>
<td>
_diag_dde_async_slaves
</td>
<td>
5
</td>
<td>
diag dde async actions: max number of concurr
ent slave processes
</td>
</tr>
<tr>
<td>
_diag_dde_enabled
</td>
<td>
TRUE
</td>
<td>
enable DDE handling of critical errors
</td>
</tr>
<tr>
<td>
_diag_dde_fc_enabled
</td>
<td>
TRUE
</td>
<td>
Parameter to enable/disable Diag Flood Contro
l
</td>
</tr>
<tr>
<td>
_diag_dde_fc_implicit_time
</td>
<td>
0
</td>
<td>
Override Implicit Error Flood Control time pa
rameter
</td>
</tr>
<tr>
<td>
_diag_dde_fc_macro_time
</td>
<td>
0
</td>
<td>
Override Macro Error Flood Control time param
eter
</td>
</tr>
<tr>
<td>
_diag_dde_inc_proc_delay
</td>
<td>
1
</td>
<td>
The minimum delay between two MMON incident s
weeps (minutes)
</td>
</tr>
<tr>
<td>
_diag_diagnostics
</td>
<td>
TRUE
</td>
<td>
Turn off diag diagnostics
</td>
</tr>
<tr>
<td>
_diag_dump_timeout
</td>
<td>
30
</td>
<td>
timeout parameter for SYNC dump
</td>
</tr>
<tr>
<td>
_diag_hm_rc_enabled
</td>
<td>
TRUE
</td>
<td>
Parameter to enable/disable Diag HM Reactive
Checks
</td>
</tr>
<tr>
<td>
_diag_hm_tc_enabled
</td>
<td>
FALSE
</td>
<td>
Parameter to enable/disable Diag HM Test(dumm
y) Checks
</td>
</tr>
<tr>
<td>
_diag_uts_control
</td>
<td>
0
</td>
<td>
UTS control parameter
</td>
</tr>
<tr>
<td>
_dimension_skip_null
</td>
<td>
TRUE
</td>
<td>
control dimension skip when null feature
</td>
</tr>
<tr>
<td>
_direct_path_insert_features
</td>
<td>
0
</td>
<td>
disable direct path insert features
</td>
</tr>
<tr>
<td>
_disable_12751
</td>
<td>
FALSE
</td>
<td>
disable policy timeout error (ORA-12751)
</td>
</tr>
<tr>
<td>
_disable_adaptive_shrunk_aggregation
</td>
<td>
FALSE
</td>
<td>
adaptive shrunk aggregation
</td>
</tr>
<tr>
<td>
_disable_autotune_gtx
</td>
<td>
FALSE
</td>
<td>
disable autotune global transaction backgroun
d processes
</td>
</tr>
<tr>
<td>
_disable_datalayer_sampling
</td>
<td>
FALSE
</td>
<td>
disable datalayer sampling
</td>
</tr>
<tr>
<td>
_disable_duplex_link
</td>
<td>
FALSE
</td>
<td>
Turn off connection duplexing
</td>
</tr>
<tr>
<td>
_disable_fast_aggregation
</td>
<td>
FALSE
</td>
<td>
fast aggregation
</td>
</tr>
<tr>
<td>
_disable_fast_validate
</td>
<td>
FALSE
</td>
<td>
disable PL/SQL fast validation
</td>
</tr>
<tr>
<td>
_disable_fastopen
</td>
<td>
FALSE
</td>
<td>
Do Not Use Fastopen
</td>
</tr>
<tr>
<td>
_disable_fba_qrw
</td>
<td>
0
</td>
<td>
disable flashback archiver query rewrite
</td>
</tr>
<tr>
<td>
_disable_fba_wpr
</td>
<td>
0
</td>
<td>
disable flashback archiver wait for prepared
transactions
</td>
</tr>
<tr>
<td>
_disable_file_locks
</td>
<td>
FALSE
</td>
<td>
disable file locks for control, data, redo lo
g files
</td>
</tr>
<tr>
<td>
_disable_flashback_archiver
</td>
<td>
0
</td>
<td>
disable flashback archiver
</td>
</tr>
<tr>
<td>
_disable_flashback_wait_callback
</td>
<td>
FALSE
</td>
<td>
Disable flashback wait callback
</td>
</tr>
<tr>
<td>
_disable_function_based_index
</td>
<td>
FALSE
</td>
<td>
disable function-based index matching
</td>
</tr>
<tr>
<td>
_disable_health_check
</td>
<td>
FALSE
</td>
<td>
Disable Health Check
</td>
</tr>
<tr>
<td>
_disable_highres_ticks
</td>
<td>
FALSE
</td>
<td>
disable high-res tick counter
</td>
</tr>
<tr>
<td>
_disable_image_check
</td>
<td>
FALSE
</td>
<td>
Disable Oracle executable image checking
</td>
</tr>
<tr>
<td>
_disable_incremental_checkpoints
</td>
<td>
FALSE
</td>
<td>
Disable incremental checkpoints for thread re
covery
</td>
</tr>
<tr>
<td>
_disable_incremental_recovery_ckpt
</td>
<td>
FALSE
</td>
<td>
Disable incremental recovery checkpoint mecha
nism
</td>
</tr>
<tr>
<td>
_disable_index_block_prefetching
</td>
<td>
FALSE
</td>
<td>
disable index block prefetching
</td>
</tr>
<tr>
<td>
_disable_instance_params_check
</td>
<td>
FALSE
</td>
<td>
disable instance type check for ksp
</td>
</tr>
<tr>
<td>
_disable_interface_checking
</td>
<td>
FALSE
</td>
<td>
disable interface checking at startup
</td>
</tr>
<tr>
<td>
_disable_kcb_flashback_blocknew_opt
</td>
<td>
FALSE
</td>
<td>
Disable KCB flashback block new optimization
</td>
</tr>
<tr>
<td>
_disable_kcbhxor_osd
</td>
<td>
FALSE
</td>
<td>
disable kcbh(c)xor OSD functionality
</td>
</tr>
<tr>
<td>
_disable_kcbl_flashback_blocknew_opt
</td>
<td>
FALSE
</td>
<td>
Disable KCBL flashback block new optimization
</td>
</tr>
<tr>
<td>
_disable_latch_free_SCN_writes_via_32cas
</td>
<td>
FALSE
</td>
<td>
disable latch-free SCN writes using 32-bit co
mpare &amp; swap
</td>
</tr>
<tr>
<td>
_disable_latch_free_SCN_writes_via_64cas
</td>
<td>
FALSE
</td>
<td>
disable latch-free SCN writes using 64-bit co
mpare &amp; swap
</td>
</tr>
<tr>
<td>
_disable_logging
</td>
<td>
FALSE
</td>
<td>
Disable logging
</td>
</tr>
<tr>
<td>
_disable_metrics_group
</td>
<td>
0
</td>
<td>
Disable Metrics Group (or all Metrics Groups)
</td>
</tr>
<tr>
<td>
_disable_multiple_block_sizes
</td>
<td>
FALSE
</td>
<td>
disable multiple block size support (for debu
gging)
</td>
</tr>
<tr>
<td>
_disable_ntlog_events
</td>
<td>
FALSE
</td>
<td>
Disable logging to NT event log
</td>
</tr>
<tr>
<td>
_disable_odm
</td>
<td>
FALSE
</td>
<td>
disable odm feature
</td>
</tr>
<tr>
<td>
_disable_parallel_conventional_load
</td>
<td>
FALSE
</td>
<td>
Disable parallel conventional loads
</td>
</tr>
<tr>
<td>
_disable_read_only_open_dict_check
</td>
<td>
FALSE
</td>
<td>
Disable read-only open dictionary check
</td>
</tr>
<tr>
<td>
_disable_rebalance_space_check
</td>
<td>
FALSE
</td>
<td>
disable space usage checks for storage reconf
iguration
</td>
</tr>
<tr>
<td>
_disable_recoverable_recovery
</td>
<td>
FALSE
</td>
<td>
Disable the new recoverable recovery mechanis
m
</td>
</tr>
<tr>
<td>
_disable_recovery_read_skip
</td>
<td>
FALSE
</td>
<td>
Disable the read optimization during media re
covery
</td>
</tr>
<tr>
<td>
_disable_sample_io_optim
</td>
<td>
FALSE
</td>
<td>
disable row sampling IO optimization
</td>
</tr>
<tr>
<td>
_disable_savepoint_reset
</td>
<td>
FALSE
</td>
<td>
disable the fix for bug 1402161
</td>
</tr>
<tr>
<td>
_disable_sec_ticks
</td>
<td>
FALSE
</td>
<td>
disable low-res (sec) counter
</td>
</tr>
<tr>
<td>
_disable_selftune_checkpointing
</td>
<td>
FALSE
</td>
<td>
Disable self-tune checkpointing
</td>
</tr>
<tr>
<td>
_disable_streams_pool_auto_tuning
</td>
<td>
FALSE
</td>
<td>
disable streams pool auto tuning
</td>
</tr>
<tr>
<td>
_disable_system_state
</td>
<td>
4294967294
</td>
<td>
disable system state dump
</td>
</tr>
<tr>
<td>
_disable_thread_internal_disable
</td>
<td>
FALSE
</td>
<td>
Disable thread internal disable feature
</td>
</tr>
<tr>
<td>
_disable_txn_alert
</td>
<td>
0
</td>
<td>
disable txn layer alert
</td>
</tr>
<tr>
<td>
_disable_vktm
</td>
<td>
FALSE
</td>
<td>
disable vktm process
</td>
</tr>
<tr>
<td>
_disable_wait_stack
</td>
<td>
FALSE
</td>
<td>
Disable wait stack
</td>
</tr>
<tr>
<td>
_discrete_transactions_enabled
</td>
<td>
FALSE
</td>
<td>
enable OLTP mode
</td>
</tr>
<tr>
<td>
_diskmon_pipe_name
</td>
<td>
&nbsp;
</td>
<td>
DiSKMon skgznp pipe name
</td>
</tr>
<tr>
<td>
_dispatcher_rate_scale
</td>
<td>
&nbsp;
</td>
<td>
scale to display rate statistic (100ths of a
second)
</td>
</tr>
<tr>
<td>
_dispatcher_rate_ttl
</td>
<td>
&nbsp;
</td>
<td>
time-to-live for rate statistic (100ths of a
second)
</td>
</tr>
<tr>
<td>
_distinct_view_unnesting
</td>
<td>
FALSE
</td>
<td>
enables unnesting of in subquery into distinc
t view
</td>
</tr>
<tr>
<td>
_distributed_recovery_connection_hold_time
</td>
<td>
200
</td>
<td>
number of seconds RECO holds outbound connect
ions open
</td>
</tr>
<tr>
<td>
_dlmtrace
</td>
<td>
&nbsp;
</td>
<td>
Trace string of global enqueue type(s)
</td>
</tr>
<tr>
<td>
_dm_max_shared_pool_pct
</td>
<td>
1
</td>
<td>
max percentage of the shared pool to use for
a mining model
</td>
</tr>
<tr>
<td>
_dml_monitoring_enabled
</td>
<td>
TRUE
</td>
<td>
enable modification monitoring
</td>
</tr>
<tr>
<td>
_domain_index_batch_size
</td>
<td>
2000
</td>
<td>
maximum number of rows from one call to domai
n index fetch routine
</td>
</tr>
<tr>
<td>
_domain_index_dml_batch_size
</td>
<td>
200
</td>
<td>
maximum number of rows for one call to domain
 index dml routines
</td>
</tr>
<tr>
<td>
_dra_bmr_number_threshold
</td>
<td>
1000
</td>
<td>
Maximum number of BMRs that can be done to a
file
</td>
</tr>
<tr>
<td>
_dra_bmr_percent_threshold
</td>
<td>
10
</td>
<td>
Maximum percentage of blocks in a file that c
an be BMR-ed
</td>
</tr>
<tr>
<td>
_dra_enable_offline_dictionary
</td>
<td>
TRUE
</td>
<td>
Enable the periodic creation of the offline d
ictionary for DRA
</td>
</tr>
<tr>
<td>
_drop_table_granule
</td>
<td>
256
</td>
<td>
drop_table_granule
</td>
</tr>
<tr>
<td>
_drop_table_optimization_enabled
</td>
<td>
TRUE
</td>
<td>
reduce SGA memory use during drop of a partit
ioned table
</td>
</tr>
<tr>
<td>
_ds_iocount_iosize
</td>
<td>
6553664
</td>
<td>
Dynamic Sampling Service defaults: #IOs and I
O Size
</td>
</tr>
<tr>
<td>
_dss_cache_flush
</td>
<td>
FALSE
</td>
<td>
enable full cache flush for parallel executio
n
</td>
</tr>
<tr>
<td>
_dtree_area_size
</td>
<td>
131072
</td>
<td>
size of Decision Tree Classification work are
a
</td>
</tr>
<tr>
<td>
_dtree_binning_enabled
</td>
<td>
TRUE
</td>
<td>
Decision Tree Binning Enabled
</td>
</tr>
<tr>
<td>
_dtree_bintest_id
</td>
<td>
0
</td>
<td>
Decision Tree Binning Test ID
</td>
</tr>
<tr>
<td>
_dtree_compressbmp_enabled
</td>
<td>
TRUE
</td>
<td>
Decision Tree Using Compressed Bitmaps Enable
d
</td>
</tr>
<tr>
<td>
_dtree_max_surrogates
</td>
<td>
1
</td>
<td>
maximum number of surrogates
</td>
</tr>
<tr>
<td>
_dtree_pruning_enabled
</td>
<td>
TRUE
</td>
<td>
Decision Tree Pruning Enabled
</td>
</tr>
<tr>
<td>
_dummy_instance
</td>
<td>
FALSE
</td>
<td>
dummy instance started by RMAN
</td>
</tr>
<tr>
<td>
_dump_common_subexpressions
</td>
<td>
FALSE
</td>
<td>
dump common subexpressions
</td>
</tr>
<tr>
<td>
_dump_connect_by_loop_data
</td>
<td>
FALSE
</td>
<td>
dump connect by loop error message into trc f
ile
</td>
</tr>
<tr>
<td>
_dump_cursor_heap_sizes
</td>
<td>
FALSE
</td>
<td>
dump comp/exec heap sizes to tryace file
</td>
</tr>
<tr>
<td>
_dump_interval_limit
</td>
<td>
120
</td>
<td>
trace dump time interval limit (in seconds)
</td>
</tr>
<tr>
<td>
_dump_max_limit
</td>
<td>
5
</td>
<td>
max number of dump within dump interval
</td>
</tr>
<tr>
<td>
_dump_qbc_tree
</td>
<td>
0
</td>
<td>
dump top level query parse tree to trace
</td>
</tr>
<tr>
<td>
_dump_rcvr_ipc
</td>
<td>
TRUE
</td>
<td>
if TRUE enables IPC dump at instance eviction
 time
</td>
</tr>
<tr>
<td>
_dump_system_state_scope
</td>
<td>
local
</td>
<td>
scope of sysstate dump during instance termin
ation
</td>
</tr>
<tr>
<td>
_dump_trace_scope
</td>
<td>
global
</td>
<td>
scope of trace dump during a process crash
</td>
</tr>
<tr>
<td>
_dynamic_rls_policies
</td>
<td>
TRUE
</td>
<td>
rls policies are dynamic
</td>
</tr>
<tr>
<td>
_dynamic_stats_threshold
</td>
<td>
30
</td>
<td>
delay threshold (in seconds) between sending
statistics messages
</td>
</tr>
<tr>
<td>
_edition_based_redefinition
</td>
<td>
FALSE
</td>
<td>
enable edition based redefinition
</td>
</tr>
<tr>
<td>
_eliminate_common_subexpr
</td>
<td>
TRUE
</td>
<td>
enables elimination of common sub-expressions
</td>
</tr>
<tr>
<td>
_emon_regular_ntfn_slaves
</td>
<td>
4
</td>
<td>
number of EMON slaves doing regular database
notifications
</td>
</tr>
<tr>
<td>
_enable_NUMA_optimization
</td>
<td>
TRUE
</td>
<td>
Enable NUMA specific optimizations
</td>
</tr>
<tr>
<td>
_enable_automatic_maintenance
</td>
<td>
1
</td>
<td>
if 1, Automated Maintenance Is Enabled
</td>
</tr>
<tr>
<td>
_enable_automatic_sqltune
</td>
<td>
TRUE
</td>
<td>
Automatic SQL Tuning Advisory enabled paramet
er
</td>
</tr>
<tr>
<td>
_enable_block_level_transaction_recovery
</td>
<td>
TRUE
</td>
<td>
enable block level recovery
</td>
</tr>
<tr>
<td>
_enable_cscn_caching
</td>
<td>
FALSE
</td>
<td>
enable commit SCN caching for all transaction
s
</td>
</tr>
<tr>
<td>
_enable_ddl_wait_lock
</td>
<td>
TRUE
</td>
<td>
use this to turn off ddls with wait semantics
</td>
</tr>
<tr>
<td>
_enable_default_affinity
</td>
<td>
0
</td>
<td>
to enable default implementation of affinity
osds
</td>
</tr>
<tr>
<td>
_enable_dml_lock_escalation
</td>
<td>
TRUE
</td>
<td>
enable dml lock escalation against partitione
d tables if TRUE
</td>
</tr>
<tr>
<td>
_enable_exchange_validation_using_check
</td>
<td>
TRUE
</td>
<td>
use check constraints on the table for valida
tion
</td>
</tr>
<tr>
<td>
_enable_fast_ref_after_mv_tbs
</td>
<td>
FALSE
</td>
<td>
enable fast refresh after move tablespace
</td>
</tr>
<tr>
<td>
_enable_hash_overflow
</td>
<td>
FALSE
</td>
<td>
TRUE - enable hash cluster overflow based on
SIZE
</td>
</tr>
<tr>
<td>
_enable_hwm_sync
</td>
<td>
TRUE
</td>
<td>
enable HWM synchronization
</td>
</tr>
<tr>
<td>
_enable_list_io
</td>
<td>
FALSE
</td>
<td>
Enable List I/O
</td>
</tr>
<tr>
<td>
_enable_midtier_affinity
</td>
<td>
TRUE
</td>
<td>
enable midtier affinity metrics processing
</td>
</tr>
<tr>
<td>
_enable_nativenet_tcpip
</td>
<td>
FALSE
</td>
<td>
Enable skgxp driver usage for native net
</td>
</tr>
<tr>
<td>
_enable_obj_queues
</td>
<td>
TRUE
</td>
<td>
enable object queues
</td>
</tr>
<tr>
<td>
_enable_online_index_without_s_locking
</td>
<td>
TRUE
</td>
<td>
Allow online index creation algorithm without
 S DML lock
</td>
</tr>
<tr>
<td>
_enable_query_rewrite_on_remote_objs
</td>
<td>
TRUE
</td>
<td>
mv rewrite on remote table/view
</td>
</tr>
<tr>
<td>
_enable_refresh_schedule
</td>
<td>
TRUE
</td>
<td>
enable or disable MV refresh scheduling (reve
rt to 9.2 behavior)
</td>
</tr>
<tr>
<td>
_enable_reliable_latch_waits
</td>
<td>
TRUE
</td>
<td>
Enable reliable latch waits
</td>
</tr>
<tr>
<td>
_enable_rlb
</td>
<td>
TRUE
</td>
<td>
enable RLB metrics processing
</td>
</tr>
<tr>
<td>
_enable_row_shipping
</td>
<td>
TRUE
</td>
<td>
use the row shipping optimization for wide ta
ble selects
</td>
</tr>
<tr>
<td>
_enable_scn_wait_interface
</td>
<td>
TRUE
</td>
<td>
use this to turn off scn wait interface in kt
a
</td>
</tr>
<tr>
<td>
_enable_separable_transactions
</td>
<td>
FALSE
</td>
<td>
enable/disable separable transactions
</td>
</tr>
<tr>
<td>
_enable_shared_pool_durations
</td>
<td>
FALSE
</td>
<td>
temporary to disable/enable kgh policy
</td>
</tr>
<tr>
<td>
_enable_shared_server_vector_io
</td>
<td>
FALSE
</td>
<td>
Enable shared server vector I/O
</td>
</tr>
<tr>
<td>
_enable_space_preallocation
</td>
<td>
3
</td>
<td>
enable space pre-allocation
</td>
</tr>
<tr>
<td>
_enable_spacebg
</td>
<td>
TRUE
</td>
<td>
enable space management background task
</td>
</tr>
<tr>
<td>
_enable_tablespace_alerts
</td>
<td>
TRUE
</td>
<td>
enable tablespace alerts
</td>
</tr>
<tr>
<td>
_enable_type_dep_selectivity
</td>
<td>
TRUE
</td>
<td>
enable type dependent selectivity estimates
</td>
</tr>
<tr>
<td>
_endprot_chunk_comment
</td>
<td>
chk 10235 dflt
</td>
<td>
chunk comment for selective overrun protectio
n
</td>
</tr>
<tr>
<td>
_endprot_heap_comment
</td>
<td>
hp 10235 dflt
</td>
<td>
heap comment for selective overrun protection
</td>
</tr>
<tr>
<td>
_endprot_subheaps
</td>
<td>
TRUE
</td>
<td>
selective overrun protection for subeheaps
</td>
</tr>
<tr>
<td>
_enqueue_deadlock_time_sec
</td>
<td>
5
</td>
<td>
requests with timeout &lt;= this will not have d
eadlock detection
</td>
</tr>
<tr>
<td>
_enqueue_debug_multi_instance
</td>
<td>
FALSE
</td>
<td>
debug enqueue multi instance
</td>
</tr>
<tr>
<td>
_enqueue_hash
</td>
<td>
155
</td>
<td>
enqueue hash table length
</td>
</tr>
<tr>
<td>
_enqueue_hash_chain_latches
</td>
<td>
2
</td>
<td>
enqueue hash chain latches
</td>
</tr>
<tr>
<td>
_enqueue_locks
</td>
<td>
990
</td>
<td>
locks for managed enqueues
</td>
</tr>
<tr>
<td>
_enqueue_resources
</td>
<td>
484
</td>
<td>
resources for enqueues
</td>
</tr>
<tr>
<td>
_evolve_plan_baseline_report_level
</td>
<td>
typical
</td>
<td>
Level of detail to show in plan verification/
evolution report
</td>
</tr>
<tr>
<td>
_evt_system_event_propagation
</td>
<td>
TRUE
</td>
<td>
disable system event propagation
</td>
</tr>
<tr>
<td>
_expand_aggregates
</td>
<td>
TRUE
</td>
<td>
expand aggregates
</td>
</tr>
<tr>
<td>
_explain_rewrite_mode
</td>
<td>
FALSE
</td>
<td>
allow additional messages to be generated dur
ing explain rewrite
</td>
</tr>
<tr>
<td>
_extended_pruning_enabled
</td>
<td>
TRUE
</td>
<td>
do runtime pruning in iterator if set to TRUE
</td>
</tr>
<tr>
<td>
_fair_remote_cvt
</td>
<td>
FALSE
</td>
<td>
if TRUE enables fair remote convert
</td>
</tr>
<tr>
<td>
_fairness_threshold
</td>
<td>
4
</td>
<td>
number of times to CR serve before downgradin
g lock
</td>
</tr>
<tr>
<td>
_fast_dual_enabled
</td>
<td>
TRUE
</td>
<td>
enable/disable fast dual
</td>
</tr>
<tr>
<td>
_fast_full_scan_enabled
</td>
<td>
TRUE
</td>
<td>
enable/disable index fast full scan
</td>
</tr>
<tr>
<td>
_fastpin_enable
</td>
<td>
1
</td>
<td>
enable reference count based fast pins
</td>
</tr>
<tr>
<td>
_fbda_busy_percentage
</td>
<td>
0
</td>
<td>
flashback archiver busy percentage
</td>
</tr>
<tr>
<td>
_fbda_inline2_percentage
</td>
<td>
0
</td>
<td>
flashback archiver full inline percentage
</td>
</tr>
<tr>
<td>
_fbda_inline_percentage
</td>
<td>
0
</td>
<td>
flashback archiver inline percentage
</td>
</tr>
<tr>
<td>
_fg_iorm_slaves
</td>
<td>
1
</td>
<td>
ForeGround I/O slaves for IORM
</td>
</tr>
<tr>
<td>
_fg_log_checksum
</td>
<td>
TRUE
</td>
<td>
Checksum redo in foreground process
</td>
</tr>
<tr>
<td>
_fic_algorithm_set
</td>
<td>
automatic
</td>
<td>
Set Frequent Itemset Counting Algorithm
</td>
</tr>
<tr>
<td>
_fic_area_size
</td>
<td>
131072
</td>
<td>
size of Frequent Itemset Counting work area
</td>
</tr>
<tr>
<td>
_fic_max_length
</td>
<td>
20
</td>
<td>
Frequent Itemset Counting Maximum Itemset Len
gth
</td>
</tr>
<tr>
<td>
_fic_min_bmsize
</td>
<td>
1024
</td>
<td>
Frequent Itemset Counting Minimum BITMAP Size
</td>
</tr>
<tr>
<td>
_fic_outofmem_candidates
</td>
<td>
FALSE
</td>
<td>
Frequent Itemset Counting Out Of Memory Candi
dates Generation
</td>
</tr>
<tr>
<td>
_fifth_spare_parameter
</td>
<td>
&nbsp;
</td>
<td>
fifth spare parameter - string
</td>
</tr>
<tr>
<td>
_filemap_dir
</td>
<td>
&nbsp;
</td>
<td>
FILEMAP directory
</td>
</tr>
<tr>
<td>
_first_k_rows_dynamic_proration
</td>
<td>
TRUE
</td>
<td>
enable the use of dynamic proration of join c
ardinalities
</td>
</tr>
<tr>
<td>
_first_spare_parameter
</td>
<td>
&nbsp;
</td>
<td>
first spare parameter - integer
</td>
</tr>
<tr>
<td>
_fix_control
</td>
<td>
&nbsp;
</td>
<td>
bug fix control parameter
</td>
</tr>
<tr>
<td>
_flashback_allow_noarchivelog
</td>
<td>
FALSE
</td>
<td>
Allow enabling flashback on noarchivelog data
base
</td>
</tr>
<tr>
<td>
_flashback_archiver_partition_size
</td>
<td>
0
</td>
<td>
flashback archiver table partition size
</td>
</tr>
<tr>
<td>
_flashback_barrier_interval
</td>
<td>
1800
</td>
<td>
Flashback barrier interval in seconds
</td>
</tr>
<tr>
<td>
_flashback_copy_latches
</td>
<td>
10
</td>
<td>
Number of flashback copy latches
</td>
</tr>
<tr>
<td>
_flashback_format_chunk_mb
</td>
<td>
4
</td>
<td>
Chunk mega-bytes for formatting flashback log
s using sync write
</td>
</tr>
<tr>
<td>
_flashback_format_chunk_mb_dwrite
</td>
<td>
16
</td>
<td>
Chunk mega-bytes for formatting flashback log
s using delayed write
</td>
</tr>
<tr>
<td>
_flashback_fuzzy_barrier
</td>
<td>
TRUE
</td>
<td>
Use flashback fuzzy barrier
</td>
</tr>
<tr>
<td>
_flashback_generation_buffer_size
</td>
<td>
8388608
</td>
<td>
flashback generation buffer size
</td>
</tr>
<tr>
<td>
_flashback_hint_barrier_percent
</td>
<td>
20
</td>
<td>
Flashback hint barrier percent
</td>
</tr>
<tr>
<td>
_flashback_log_io_error_behavior
</td>
<td>
0
</td>
<td>
Specify Flashback log I/O error behavior
</td>
</tr>
<tr>
<td>
_flashback_log_min_size
</td>
<td>
100
</td>
<td>
Minimum flashback log size
</td>
</tr>
<tr>
<td>
_flashback_log_size
</td>
<td>
1000
</td>
<td>
Flashback log size
</td>
</tr>
<tr>
<td>
_flashback_logfile_enqueue_timeout
</td>
<td>
600
</td>
<td>
flashback logfile enqueue timeout for opens
</td>
</tr>
<tr>
<td>
_flashback_marker_cache_enabled
</td>
<td>
TRUE
</td>
<td>
Enable flashback database marker cache
</td>
</tr>
<tr>
<td>
_flashback_marker_cache_size
</td>
<td>
328
</td>
<td>
Size of flashback database marker cache
</td>
</tr>
<tr>
<td>
_flashback_max_log_size
</td>
<td>
0
</td>
<td>
Maximum flashback log size in bytes (OS limit
)
</td>
</tr>
<tr>
<td>
_flashback_max_n_log_per_thread
</td>
<td>
2048
</td>
<td>
Maximum number of flashback logs per flashbac
k thread
</td>
</tr>
<tr>
<td>
_flashback_max_standby_sync_span
</td>
<td>
900
</td>
<td>
Maximum time span between standby recovery sy
nc for flashback
</td>
</tr>
<tr>
<td>
_flashback_n_log_per_thread
</td>
<td>
128
</td>
<td>
Desired number of flashback logs per flashbac
k thread
</td>
</tr>
<tr>
<td>
_flashback_standby_barrier_interval
</td>
<td>
1800
</td>
<td>
Flashback standby barrier interval in seconds
</td>
</tr>
<tr>
<td>
_flashback_verbose_info
</td>
<td>
FALSE
</td>
<td>
Print verbose information about flashback dat
abase
</td>
</tr>
<tr>
<td>
_flashback_write_max_loop_limit
</td>
<td>
10
</td>
<td>
Flashback writer loop limit before it returns
</td>
</tr>
<tr>
<td>
_force_datefold_trunc
</td>
<td>
FALSE
</td>
<td>
force use of trunc for datefolding rewrite
</td>
</tr>
<tr>
<td>
_force_hsc_compress
</td>
<td>
FALSE
</td>
<td>
compress all new created tables
</td>
</tr>
<tr>
<td>
_force_oltp_compress
</td>
<td>
FALSE
</td>
<td>
OLTP Compress all new created tables
</td>
</tr>
<tr>
<td>
_force_rewrite_enable
</td>
<td>
FALSE
</td>
<td>
control new query rewrite features
</td>
</tr>
<tr>
<td>
_force_slave_mapping_intra_part_loads
</td>
<td>
FALSE
</td>
<td>
Force slave mapping for intra partition loads
</td>
</tr>
<tr>
<td>
_force_temptables_for_gsets
</td>
<td>
FALSE
</td>
<td>
executes concatenation of rollups using temp
tables
</td>
</tr>
<tr>
<td>
_force_tmp_segment_loads
</td>
<td>
FALSE
</td>
<td>
Force tmp segment loads
</td>
</tr>
<tr>
<td>
_forwarded_2pc_threshold
</td>
<td>
10
</td>
<td>
auto-tune threshold for two-phase commit rate
 across RAC instances
</td>
</tr>
<tr>
<td>
_fourth_spare_parameter
</td>
<td>
&nbsp;
</td>
<td>
fourth spare parameter - string
</td>
</tr>
<tr>
<td>
_full_pwise_join_enabled
</td>
<td>
TRUE
</td>
<td>
enable full partition-wise join when TRUE
</td>
</tr>
<tr>
<td>
_gby_hash_aggregation_enabled
</td>
<td>
TRUE
</td>
<td>
enable group-by and aggregation using hash sc
heme
</td>
</tr>
<tr>
<td>
_gby_onekey_enabled
</td>
<td>
TRUE
</td>
<td>
enable use of one comparison of all group by
keys
</td>
</tr>
<tr>
<td>
_gc_affinity_locking
</td>
<td>
TRUE
</td>
<td>
if TRUE, enable object affinity
</td>
</tr>
<tr>
<td>
_gc_affinity_locks
</td>
<td>
TRUE
</td>
<td>
if TRUE, get affinity locks
</td>
</tr>
<tr>
<td>
_gc_affinity_ratio
</td>
<td>
50
</td>
<td>
dynamic object affinity ratio
</td>
</tr>
<tr>
<td>
_gc_async_memcpy
</td>
<td>
FALSE
</td>
<td>
if TRUE, use async memcpy
</td>
</tr>
<tr>
<td>
_gc_bypass_readers
</td>
<td>
TRUE
</td>
<td>
if TRUE, modifications bypass readers
</td>
</tr>
<tr>
<td>
_gc_check_bscn
</td>
<td>
TRUE
</td>
<td>
if TRUE, check for stale blocks
</td>
</tr>
<tr>
<td>
_gc_coalesce_recovery_reads
</td>
<td>
TRUE
</td>
<td>
if TRUE, coalesce recovery reads
</td>
</tr>
<tr>
<td>
_gc_defer_time
</td>
<td>
3
</td>
<td>
how long to defer down converts for hot buffe
rs
</td>
</tr>
<tr>
<td>
_gc_dissolve_undo_affinity
</td>
<td>
FALSE
</td>
<td>
if TRUE, dissolve undo affinity after an offl
ine
</td>
</tr>
<tr>
<td>
_gc_element_percent
</td>
<td>
110
</td>
<td>
global cache element percent
</td>
</tr>
<tr>
<td>
_gc_global_checkpoint_scn
</td>
<td>
TRUE
</td>
<td>
if TRUE, enable global checkpoint scn
</td>
</tr>
<tr>
<td>
_gc_global_lru
</td>
<td>
AUTO
</td>
<td>
turn global lru off, make it automatic, or tu
rn it on
</td>
</tr>
<tr>
<td>
_gc_initiate_undo_affinity
</td>
<td>
TRUE
</td>
<td>
if TRUE, initiate undo affinity after an onli
ne
</td>
</tr>
<tr>
<td>
_gc_integrity_checks
</td>
<td>
1
</td>
<td>
set the integrity check level
</td>
</tr>
<tr>
<td>
_gc_keep_recovery_buffers
</td>
<td>
TRUE
</td>
<td>
if TRUE, make recovery buffers current
</td>
</tr>
<tr>
<td>
_gc_latches
</td>
<td>
8
</td>
<td>
number of latches per LMS process
</td>
</tr>
<tr>
<td>
_gc_long_query_threshold
</td>
<td>
0
</td>
<td>
threshold for long running query
</td>
</tr>
<tr>
<td>
_gc_maximum_bids
</td>
<td>
0
</td>
<td>
maximum number of bids which can be prepared
</td>
</tr>
<tr>
<td>
_gc_policy_minimum
</td>
<td>
1500
</td>
<td>
dynamic object policy minimum activity per mi
nute
</td>
</tr>
<tr>
<td>
_gc_policy_time
</td>
<td>
10
</td>
<td>
how often to make object policy decisions in
minutes
</td>
</tr>
<tr>
<td>
_gc_read_mostly_locking
</td>
<td>
TRUE
</td>
<td>
if TRUE, enable read-mostly locking
</td>
</tr>
<tr>
<td>
_gc_statistics
</td>
<td>
TRUE
</td>
<td>
if TRUE, kcl statistics are maintained
</td>
</tr>
<tr>
<td>
_gc_transfer_ratio
</td>
<td>
2
</td>
<td>
dynamic object read-mostly transfer ratio
</td>
</tr>
<tr>
<td>
_gc_undo_affinity
</td>
<td>
TRUE
</td>
<td>
if TRUE, enable dynamic undo affinity
</td>
</tr>
<tr>
<td>
_gc_undo_block_disk_reads
</td>
<td>
TRUE
</td>
<td>
if TRUE, enable undo block disk reads
</td>
</tr>
<tr>
<td>
_gc_use_cr
</td>
<td>
TRUE
</td>
<td>
if TRUE, allow CR pins on PI and WRITING buff
ers
</td>
</tr>
<tr>
<td>
_gc_vector_read
</td>
<td>
TRUE
</td>
<td>
if TRUE, vector read current buffers
</td>
</tr>
<tr>
<td>
_gc_voluntary_down_convert_obj
</td>
<td>
0
</td>
<td>
object number for voluntary down-convert
</td>
</tr>
<tr>
<td>
_gcs_fast_reconfig
</td>
<td>
TRUE
</td>
<td>
if TRUE, enable fast reconfiguration for gcs
locks
</td>
</tr>
<tr>
<td>
_gcs_latches
</td>
<td>
0
</td>
<td>
number of gcs resource hash latches to be all
ocated per LMS process
</td>
</tr>
<tr>
<td>
_gcs_process_in_recovery
</td>
<td>
TRUE
</td>
<td>
if TRUE, process gcs requests during instance
 recovery
</td>
</tr>
<tr>
<td>
_gcs_res_per_bucket
</td>
<td>
16
</td>
<td>
number of gcs resource per hash bucket
</td>
</tr>
<tr>
<td>
_gcs_resources
</td>
<td>
&nbsp;
</td>
<td>
number of gcs resources to be allocated
</td>
</tr>
<tr>
<td>
_gcs_shadow_locks
</td>
<td>
&nbsp;
</td>
<td>
number of pcm shadow locks to be allocated
</td>
</tr>
<tr>
<td>
_gcs_testing
</td>
<td>
0
</td>
<td>
GCS testing parameter
</td>
</tr>
<tr>
<td>
_generalized_pruning_enabled
</td>
<td>
TRUE
</td>
<td>
controls extensions to partition pruning for
general predicates
</td>
</tr>
<tr>
<td>
_ges_dd_debug
</td>
<td>
1
</td>
<td>
if 1 or higher enables GES deadlock detection
 debug diagnostics
</td>
</tr>
<tr>
<td>
_ges_diagnostics
</td>
<td>
TRUE
</td>
<td>
if TRUE enables GES diagnostics
</td>
</tr>
<tr>
<td>
_ges_health_check
</td>
<td>
1
</td>
<td>
if greater than 0 enables GES system health c
heck
</td>
</tr>
<tr>
<td>
_global_hang_analysis_interval_secs
</td>
<td>
10
</td>
<td>
the interval at which global hang analysis is
 run
</td>
</tr>
<tr>
<td>
_globalindex_pnum_filter_enabled
</td>
<td>
TRUE
</td>
<td>
enables filter for global index with partitio
n extended syntax
</td>
</tr>
<tr>
<td>
_groupby_nopushdown_cut_ratio
</td>
<td>
3
</td>
<td>
groupby nopushdown cut ratio
</td>
</tr>
<tr>
<td>
_groupby_orderby_combine
</td>
<td>
5000
</td>
<td>
groupby/orderby don't combine threshold
</td>
</tr>
<tr>
<td>
_gs_anti_semi_join_allowed
</td>
<td>
TRUE
</td>
<td>
enable anti/semi join for the GS query
</td>
</tr>
<tr>
<td>
_hang_analysis_num_call_stacks
</td>
<td>
3
</td>
<td>
hang analysis num call stacks
</td>
</tr>
<tr>
<td>
_hang_detection
</td>
<td>
60
</td>
<td>
Hang Management detection interval
</td>
</tr>
<tr>
<td>
_hang_resolution
</td>
<td>
FALSE
</td>
<td>
Hang Management hang resolution
</td>
</tr>
<tr>
<td>
_hard_protection
</td>
<td>
FALSE
</td>
<td>
if TRUE enable H.A.R.D specific format change
s
</td>
</tr>
<tr>
<td>
_hash_join_enabled
</td>
<td>
TRUE
</td>
<td>
enable/disable hash join
</td>
</tr>
<tr>
<td>
_hash_multiblock_io_count
</td>
<td>
0
</td>
<td>
number of blocks hash join will read/write at
 once
</td>
</tr>
<tr>
<td>
_heur_deadlock_resolution_secs
</td>
<td>
0
</td>
<td>
the heuristic wait time per node for deadlock
 resolution
</td>
</tr>
<tr>
<td>
_high_priority_processes
</td>
<td>
LMS*|VKTM
</td>
<td>
High Priority Process Name Mask
</td>
</tr>
<tr>
<td>
_high_server_threshold
</td>
<td>
0
</td>
<td>
high server thresholds
</td>
</tr>
<tr>
<td>
_hj_bit_filter_threshold
</td>
<td>
50
</td>
<td>
hash-join bit filtering threshold (0 always e
nabled)
</td>
</tr>
<tr>
<td>
_hm_analysis_oradebug_node_dump_level
</td>
<td>
0
</td>
<td>
the oradebug node dump level for hang manager
 hang analysis
</td>
</tr>
<tr>
<td>
_hm_analysis_oradebug_sys_dump_level
</td>
<td>
0
</td>
<td>
the oradebug system state level for hang mana
ger hang analysis
</td>
</tr>
<tr>
<td>
_hm_analysis_output_disk
</td>
<td>
FALSE
</td>
<td>
if TRUE the hang manager outputs hang analysi
s results to disk
</td>
</tr>
<tr>
<td>
_hm_log_incidents
</td>
<td>
FALSE
</td>
<td>
Hang Manager incident logging
</td>
</tr>
<tr>
<td>
_hm_verification_interval
</td>
<td>
60
</td>
<td>
the hang manager verification interval
</td>
</tr>
<tr>
<td>
_hwm_sync_threshold
</td>
<td>
10
</td>
<td>
HWM synchronization threshold in percentage
</td>
</tr>
<tr>
<td>
_idl_conventional_index_maintenance
</td>
<td>
TRUE
</td>
<td>
enable conventional index maintenance for ins
ert direct load
</td>
</tr>
<tr>
<td>
_idle_session_kill_enabled
</td>
<td>
TRUE
</td>
<td>
enables or disables resource manager session
idle limit checks
</td>
</tr>
<tr>
<td>
_idxrb_rowincr
</td>
<td>
100000000
</td>
<td>
proportionality constant for dop vs. rows in
index rebuild
</td>
</tr>
<tr>
<td>
_ignore_desc_in_index
</td>
<td>
FALSE
</td>
<td>
ignore DESC in indexes, sort those columns as
cending anyhow
</td>
</tr>
<tr>
<td>
_ignore_fg_deps
</td>
<td>
&nbsp;
</td>
<td>
ignore fine-grain dependencies during invalid
ation
</td>
</tr>
<tr>
<td>
_immediate_commit_propagation
</td>
<td>
TRUE
</td>
<td>
if TRUE, propagate commit SCN immediately
</td>
</tr>
<tr>
<td>
_improved_outerjoin_card
</td>
<td>
TRUE
</td>
<td>
improved outer-join cardinality calculation
</td>
</tr>
<tr>
<td>
_improved_row_length_enabled
</td>
<td>
TRUE
</td>
<td>
enable the improvements for computing the ave
rage row length
</td>
</tr>
<tr>
<td>
_imr_active
</td>
<td>
TRUE
</td>
<td>
Activate Instance Membership Recovery feature
</td>
</tr>
<tr>
<td>
_imr_avoid_double_voting
</td>
<td>
TRUE
</td>
<td>
Avoid device voting for CSS reconfig during I
MR
</td>
</tr>
<tr>
<td>
_imr_device_type
</td>
<td>
controlfile
</td>
<td>
Type of device to be used by IMR
</td>
</tr>
<tr>
<td>
_imr_disk_voting_interval
</td>
<td>
3
</td>
<td>
Maximum wait for IMR disk voting (seconds)
</td>
</tr>
<tr>
<td>
_imr_evicted_member_kill
</td>
<td>
TRUE
</td>
<td>
IMR issue evicted member kill after a wait
</td>
</tr>
<tr>
<td>
_imr_evicted_member_kill_wait
</td>
<td>
20
</td>
<td>
IMR evicted member kill wait time in seconds
</td>
</tr>
<tr>
<td>
_imr_highload_threshold
</td>
<td>
&nbsp;
</td>
<td>
IMR system highload threshold
</td>
</tr>
<tr>
<td>
_imr_max_reconfig_delay
</td>
<td>
300
</td>
<td>
Maximum Reconfiguration delay (seconds)
</td>
</tr>
<tr>
<td>
_imr_splitbrain_res_wait
</td>
<td>
600
</td>
<td>
Maximum wait for split-brain resolution (seco
nds)
</td>
</tr>
<tr>
<td>
_imr_systemload_check
</td>
<td>
TRUE
</td>
<td>
Perform the system load check during IMR
</td>
</tr>
<tr>
<td>
_imu_pools
</td>
<td>
3
</td>
<td>
in memory undo pools
</td>
</tr>
<tr>
<td>
_in_memory_undo
</td>
<td>
TRUE
</td>
<td>
Make in memory undo for top level transaction
s
</td>
</tr>
<tr>
<td>
_incremental_recovery_ckpt_min_batch
</td>
<td>
30
</td>
<td>
Minimum number of writes for incremental reco
very ckpt every 3 sec
</td>
</tr>
<tr>
<td>
_index_join_enabled
</td>
<td>
TRUE
</td>
<td>
enable the use of index joins
</td>
</tr>
<tr>
<td>
_index_prefetch_factor
</td>
<td>
100
</td>
<td>
index prefetching factor
</td>
</tr>
<tr>
<td>
_init_granule_interval
</td>
<td>
10
</td>
<td>
number of granules to process for deferred ca
che
</td>
</tr>
<tr>
<td>
_init_sql_file
</td>
<td>
%ORACLE_HOME%\RDBMS\ADMIN
\SQL.BSQ
</td>
<td>
File containing SQL statements to execute upo
n database creation
</td>
</tr>
<tr>
<td>
_inject_startup_fault
</td>
<td>
0
</td>
<td>
inject fault in the startup code
</td>
</tr>
<tr>
<td>
_inline_sql_in_plsql
</td>
<td>
FALSE
</td>
<td>
inline SQL in PL/SQL
</td>
</tr>
<tr>
<td>
_insert_enable_hwm_brokered
</td>
<td>
TRUE
</td>
<td>
during parallel inserts high water marks are
brokered
</td>
</tr>
<tr>
<td>
_inst_locking_period
</td>
<td>
5
</td>
<td>
period an instance can retain a newly acquire
d level1 bitmap
</td>
</tr>
<tr>
<td>
_interconnect_checksum
</td>
<td>
TRUE
</td>
<td>
if TRUE, checksum interconnect blocks
</td>
</tr>
<tr>
<td>
_intrapart_pdml_enabled
</td>
<td>
TRUE
</td>
<td>
Enable intra-partition updates/deletes
</td>
</tr>
<tr>
<td>
_intrapart_pdml_randomlocal_enabled
</td>
<td>
TRUE
</td>
<td>
Enable intra-partition updates/deletes with r
andom local dist
</td>
</tr>
<tr>
<td>
_io_resource_manager_always_on
</td>
<td>
FALSE
</td>
<td>
io resource manager always on
</td>
</tr>
<tr>
<td>
_io_shared_pool_size
</td>
<td>
4194304
</td>
<td>
Size of I/O buffer pool from SGA
</td>
</tr>
<tr>
<td>
_io_slaves_disabled
</td>
<td>
FALSE
</td>
<td>
Do not use I/O slaves
</td>
</tr>
<tr>
<td>
_io_statistics
</td>
<td>
TRUE
</td>
<td>
if TRUE, ksfd I/O statistics are collected
</td>
</tr>
<tr>
<td>
_ioq_fanin_multiplier
</td>
<td>
2
</td>
<td>
IOQ miss count before a miss exception
</td>
</tr>
<tr>
<td>
_ior_serialize_fault
</td>
<td>
0
</td>
<td>
inject fault in the ior serialize code
</td>
</tr>
<tr>
<td>
_iorm_tout
</td>
<td>
1000
</td>
<td>
IORM scheduler timeout value in msec
</td>
</tr>
<tr>
<td>
_ioslave_batch_count
</td>
<td>
1
</td>
<td>
Per attempt IOs picked
</td>
</tr>
<tr>
<td>
_ioslave_issue_count
</td>
<td>
500
</td>
<td>
IOs issued before completion check
</td>
</tr>
<tr>
<td>
_job_queue_interval
</td>
<td>
5
</td>
<td>
Wakeup interval in seconds for job queue co-o
rdinator
</td>
</tr>
<tr>
<td>
_k2q_latches
</td>
<td>
0
</td>
<td>
number of k2q latches
</td>
</tr>
<tr>
<td>
_kcfis_fault_control
</td>
<td>
0
</td>
<td>
trace level setting for KCFIS module
</td>
</tr>
<tr>
<td>
_kcfis_max_appliances
</td>
<td>
40
</td>
<td>
Max. appliances in a KCFIS session
</td>
</tr>
<tr>
<td>
_kcfis_oss_io_size
</td>
<td>
0
</td>
<td>
KCFIS OSS I/O size
</td>
</tr>
<tr>
<td>
_kcfis_read_buffer_limit
</td>
<td>
0
</td>
<td>
KCFIS Read Buffer (per session) memory limit
in bytes
</td>
</tr>
<tr>
<td>
_kcfis_trace_level
</td>
<td>
0
</td>
<td>
trace level setting for KCFIS module
</td>
</tr>
<tr>
<td>
_kcfis_work_set_appliances
</td>
<td>
6
</td>
<td>
Working Set of appliances in a KCFIS session
</td>
</tr>
<tr>
<td>
_kcl_commit
</td>
<td>
TRUE
</td>
<td>
if TRUE, call kjbcommit
</td>
</tr>
<tr>
<td>
_kcl_conservative_log_flush
</td>
<td>
FALSE
</td>
<td>
if TRUE, conservatively log flush before CR s
erving
</td>
</tr>
<tr>
<td>
_kcl_debug
</td>
<td>
TRUE
</td>
<td>
if TRUE, record le history
</td>
</tr>
<tr>
<td>
_kcl_index_split
</td>
<td>
TRUE
</td>
<td>
if TRUE, reject pings on blocks in middle of
a split
</td>
</tr>
<tr>
<td>
_kdbl_enable_post_allocation
</td>
<td>
FALSE
</td>
<td>
allocate dbas after populating data buffers
</td>
</tr>
<tr>
<td>
_kdi_avoid_block_checking
</td>
<td>
FALSE
</td>
<td>
avoid index block checking on sensitive opcod
es
</td>
</tr>
<tr>
<td>
_kdli_STOP_bsz
</td>
<td>
0
</td>
<td>
undocumented parameter for internal use only
</td>
</tr>
<tr>
<td>
_kdli_STOP_dba
</td>
<td>
0
</td>
<td>
undocumented parameter for internal use only
</td>
</tr>
<tr>
<td>
_kdli_STOP_fsz
</td>
<td>
0
</td>
<td>
undocumented parameter for internal use only
</td>
</tr>
<tr>
<td>
_kdli_STOP_nio
</td>
<td>
0
</td>
<td>
undocumented parameter for internal use only
</td>
</tr>
<tr>
<td>
_kdli_STOP_tsn
</td>
<td>
0
</td>
<td>
undocumented parameter for internal use only
</td>
</tr>
<tr>
<td>
_kdli_allow_corrupt
</td>
<td>
TRUE
</td>
<td>
allow corrupt filesystem_logging data blocks
during read/write
</td>
</tr>
<tr>
<td>
_kdli_cache_inode
</td>
<td>
TRUE
</td>
<td>
cache inode state across calls
</td>
</tr>
<tr>
<td>
_kdli_cache_read_threshold
</td>
<td>
0
</td>
<td>
minimum lob size for cache-&gt;nocache read (0 d
isables heuristic)
</td>
</tr>
<tr>
<td>
_kdli_cache_size
</td>
<td>
8
</td>
<td>
maximum #entries in inode cache
</td>
</tr>
<tr>
<td>
_kdli_cache_verify
</td>
<td>
FALSE
</td>
<td>
verify cached inode via deserialization
</td>
</tr>
<tr>
<td>
_kdli_cache_write_threshold
</td>
<td>
0
</td>
<td>
minimum lob size for cache-&gt;nocache write (0
disables heuristic)
</td>
</tr>
<tr>
<td>
_kdli_cacheable_length
</td>
<td>
0
</td>
<td>
minimum lob length for inode cacheability
</td>
</tr>
<tr>
<td>
_kdli_force_cr
</td>
<td>
TRUE
</td>
<td>
force CR when reading data blocks of direct-w
rite lobs
</td>
</tr>
<tr>
<td>
_kdli_force_cr_meta
</td>
<td>
TRUE
</td>
<td>
force CR when reading metadata blocks of dire
ct-write lobs
</td>
</tr>
<tr>
<td>
_kdli_force_storage
</td>
<td>
none
</td>
<td>
force storage settings for all lobs
</td>
</tr>
<tr>
<td>
_kdli_full_readahead_threshold
</td>
<td>
0
</td>
<td>
maximum lob size for full readahead
</td>
</tr>
<tr>
<td>
_kdli_inject_assert
</td>
<td>
0
</td>
<td>
inject asserts into the inode
</td>
</tr>
<tr>
<td>
_kdli_inject_crash
</td>
<td>
0
</td>
<td>
inject crashes into the inode
</td>
</tr>
<tr>
<td>
_kdli_inline_xfm
</td>
<td>
TRUE
</td>
<td>
allow inline transformed lobs
</td>
</tr>
<tr>
<td>
_kdli_inode_preference
</td>
<td>
data
</td>
<td>
inline inode evolution preference (data, head
less, lhb)
</td>
</tr>
<tr>
<td>
_kdli_itree_entries
</td>
<td>
0
</td>
<td>
#entries in lhb/itree blocks (for testing onl
y)
</td>
</tr>
<tr>
<td>
_kdli_memory_protect
</td>
<td>
FALSE
</td>
<td>
trace accesses to inode memory outside kdli A
PI functions
</td>
</tr>
<tr>
<td>
_kdli_rci_lobmap_entries
</td>
<td>
255
</td>
<td>
#entries in RCI lobmap before migration to lh
b
</td>
</tr>
<tr>
<td>
_kdli_readahead_limit
</td>
<td>
0
</td>
<td>
shared/cached IO readahead limit
</td>
</tr>
<tr>
<td>
_kdli_readahead_strategy
</td>
<td>
contig
</td>
<td>
shared/cached IO readahead strategy
</td>
</tr>
<tr>
<td>
_kdli_recent_scn
</td>
<td>
FALSE
</td>
<td>
use recent (not dependent) scns for block for
mat/allocation
</td>
</tr>
<tr>
<td>
_kdli_reshape
</td>
<td>
FALSE
</td>
<td>
reshape an inode to inline or headless on len
gth truncation
</td>
</tr>
<tr>
<td>
_kdli_safe_callbacks
</td>
<td>
TRUE
</td>
<td>
invoke inode read/write callbacks safely
</td>
</tr>
<tr>
<td>
_kdli_sio_async
</td>
<td>
TRUE
</td>
<td>
asynchronous shared IO
</td>
</tr>
<tr>
<td>
_kdli_sio_backoff
</td>
<td>
FALSE
</td>
<td>
use exponential backoff when attempting SIOP
allocations
</td>
</tr>
<tr>
<td>
_kdli_sio_bps
</td>
<td>
0
</td>
<td>
maximum blocks per IO slot
</td>
</tr>
<tr>
<td>
_kdli_sio_dop
</td>
<td>
2
</td>
<td>
degree-of-parallelism in the SIO keep pool
</td>
</tr>
<tr>
<td>
_kdli_sio_fgio
</td>
<td>
TRUE
</td>
<td>
reap asynchronous IO in the foreground
</td>
</tr>
<tr>
<td>
_kdli_sio_fileopen
</td>
<td>
nodsync
</td>
<td>
shared IO fileopen mode: datasync vs nodatasy
nc vs async
</td>
</tr>
<tr>
<td>
_kdli_sio_flush
</td>
<td>
FALSE
</td>
<td>
enable shared IO pool operations
</td>
</tr>
<tr>
<td>
_kdli_sio_free
</td>
<td>
TRUE
</td>
<td>
free IO buffers when not in active use
</td>
</tr>
<tr>
<td>
_kdli_sio_min_read
</td>
<td>
0
</td>
<td>
shared IO pool read threshold
</td>
</tr>
<tr>
<td>
_kdli_sio_min_write
</td>
<td>
0
</td>
<td>
shared IO pool write threshold
</td>
</tr>
<tr>
<td>
_kdli_sio_nbufs
</td>
<td>
8
</td>
<td>
maximum #IO buffers to allocate per session
</td>
</tr>
<tr>
<td>
_kdli_sio_niods
</td>
<td>
8
</td>
<td>
maximum #IO descriptors to allocate per sessi
on
</td>
</tr>
<tr>
<td>
_kdli_sio_on
</td>
<td>
TRUE
</td>
<td>
enable shared IO pool operations
</td>
</tr>
<tr>
<td>
_kdli_sio_pga
</td>
<td>
FALSE
</td>
<td>
use PGA allocations for direct IO
</td>
</tr>
<tr>
<td>
_kdli_sio_pga_top
</td>
<td>
FALSE
</td>
<td>
PGA allocations come from toplevel PGA heap
</td>
</tr>
<tr>
<td>
_kdli_sio_strategy
</td>
<td>
auto
</td>
<td>
shared IO strategy: block vs. extent
</td>
</tr>
<tr>
<td>
_kdli_small_cache_limit
</td>
<td>
32
</td>
<td>
size limit of small inode cache
</td>
</tr>
<tr>
<td>
_kdli_sort_dbas
</td>
<td>
FALSE
</td>
<td>
sort dbas during chunkification
</td>
</tr>
<tr>
<td>
_kdli_space_cache_limit
</td>
<td>
2048
</td>
<td>
maximum size of the space cache in #blocks
</td>
</tr>
<tr>
<td>
_kdli_squeeze
</td>
<td>
TRUE
</td>
<td>
compact lobmap extents with contiguous dbas
</td>
</tr>
<tr>
<td>
_kdli_timer_dmp
</td>
<td>
FALSE
</td>
<td>
dump inode timers on session termination
</td>
</tr>
<tr>
<td>
_kdli_timer_trc
</td>
<td>
FALSE
</td>
<td>
trace inode timers to uts/tracefile
</td>
</tr>
<tr>
<td>
_kdli_trace
</td>
<td>
0
</td>
<td>
inode trace level
</td>
</tr>
<tr>
<td>
_kdlu_max_bucket_size
</td>
<td>
4194304
</td>
<td>
UTS kdlu bucket size
</td>
</tr>
<tr>
<td>
_kdlu_max_bucket_size_mts
</td>
<td>
131072
</td>
<td>
UTS kdlu bucket size for mts
</td>
</tr>
<tr>
<td>
_kdlu_trace_layer
</td>
<td>
0
</td>
<td>
UTS kdlu per-layer trace level
</td>
</tr>
<tr>
<td>
_kdlu_trace_session
</td>
<td>
0
</td>
<td>
UTS session dump
</td>
</tr>
<tr>
<td>
_kdlu_trace_system
</td>
<td>
0
</td>
<td>
UTS system dump
</td>
</tr>
<tr>
<td>
_kdlw_enable_ksi_locking
</td>
<td>
FALSE
</td>
<td>
enable ksi locking for lobs
</td>
</tr>
<tr>
<td>
_kdlw_enable_write_gathering
</td>
<td>
TRUE
</td>
<td>
enable lob write gathering for sql txns
</td>
</tr>
<tr>
<td>
_kdlwp_flush_threshold
</td>
<td>
4194304
</td>
<td>
WGC flush threshold in bytes
</td>
</tr>
<tr>
<td>
_kdlxp_cmp_subunit_size
</td>
<td>
262144
</td>
<td>
size of compression sub-unit in bytes
</td>
</tr>
<tr>
<td>
_kdlxp_dedup_flush_threshold
</td>
<td>
8388608
</td>
<td>
deduplication flush threshold in bytes
</td>
</tr>
<tr>
<td>
_kdlxp_dedup_hash_algo
</td>
<td>
SHA1
</td>
<td>
secure hash algorithm for deduplication - onl
y on SecureFiles
</td>
</tr>
<tr>
<td>
_kdlxp_dedup_prefix_threshold
</td>
<td>
1048576
</td>
<td>
deduplication prefix hash threshold in bytes
</td>
</tr>
<tr>
<td>
_kdlxp_lobcompress
</td>
<td>
FALSE
</td>
<td>
enable lob compression - only on SecureFiles
</td>
</tr>
<tr>
<td>
_kdlxp_lobdeduplicate
</td>
<td>
FALSE
</td>
<td>
enable lob deduplication - only on SecureFile
s
</td>
</tr>
<tr>
<td>
_kdlxp_lobdedupvalidate
</td>
<td>
TRUE
</td>
<td>
enable deduplicate validate - only on SecureF
iles
</td>
</tr>
<tr>
<td>
_kdlxp_lobencrypt
</td>
<td>
FALSE
</td>
<td>
enable lob encryption - only on SecureFiles
</td>
</tr>
<tr>
<td>
_kdlxp_min_xfm_size
</td>
<td>
32768
</td>
<td>
minimum transformation size in bytes
</td>
</tr>
<tr>
<td>
_kdlxp_mincmp
</td>
<td>
20
</td>
<td>
minimum comp ratio in pct - only on SecureFil
es
</td>
</tr>
<tr>
<td>
_kdlxp_spare1
</td>
<td>
0
</td>
<td>
deduplication spare 1
</td>
</tr>
<tr>
<td>
_kdlxp_xfmcache
</td>
<td>
TRUE
</td>
<td>
enable xfm cache - only on SecureFiles
</td>
</tr>
<tr>
<td>
_kdt_buffering
</td>
<td>
TRUE
</td>
<td>
control kdt buffering for conventional insert
s
</td>
</tr>
<tr>
<td>
_kebm_nstrikes
</td>
<td>
3
</td>
<td>
kebm # strikes to auto suspend an action
</td>
</tr>
<tr>
<td>
_kebm_suspension_time
</td>
<td>
82800
</td>
<td>
kebm auto suspension time in seconds
</td>
</tr>
<tr>
<td>
_keep_remote_column_size
</td>
<td>
FALSE
</td>
<td>
remote column size does not get modified
</td>
</tr>
<tr>
<td>
_kernel_message_network_driver
</td>
<td>
FALSE
</td>
<td>
kernel message network driver
</td>
</tr>
<tr>
<td>
_kffmap_hash_size
</td>
<td>
1024
</td>
<td>
size of kffmap_hash table
</td>
</tr>
<tr>
<td>
_kffmop_hash_size
</td>
<td>
2048
</td>
<td>
size of kffmop_hash table
</td>
</tr>
<tr>
<td>
_kfm_disable_set_fence
</td>
<td>
FALSE
</td>
<td>
disable set fence calls and revert to default
 (process fence)
</td>
</tr>
<tr>
<td>
_kghdsidx_count
</td>
<td>
1
</td>
<td>
max kghdsidx count
</td>
</tr>
<tr>
<td>
_kgl_bucket_count
</td>
<td>
9
</td>
<td>
index to the bucket count array
</td>
</tr>
<tr>
<td>
_kgl_debug
</td>
<td>
&nbsp;
</td>
<td>
Library cache debugging
</td>
</tr>
<tr>
<td>
_kgl_features_enabled
</td>
<td>
2
</td>
<td>
Library cache features enabled bits
</td>
</tr>
<tr>
<td>
_kgl_fixed_extents
</td>
<td>
TRUE
</td>
<td>
fixed extent size for library cache memory al
locations
</td>
</tr>
<tr>
<td>
_kgl_hash_collision
</td>
<td>
FALSE
</td>
<td>
whether KGL hash collision is possible
</td>
</tr>
<tr>
<td>
_kgl_heap_size
</td>
<td>
1024
</td>
<td>
extent size for library cache heap 0
</td>
</tr>
<tr>
<td>
_kgl_kqr_cap_so_stacks
</td>
<td>
FALSE
</td>
<td>
capture stacks for library and row cache stat
e objects
</td>
</tr>
<tr>
<td>
_kgl_large_heap_warning_threshold
</td>
<td>
52428800
</td>
<td>
maximum heap size before KGL writes warnings
to the alert log
</td>
</tr>
<tr>
<td>
_kgl_latch_count
</td>
<td>
0
</td>
<td>
number of library cache latches
</td>
</tr>
<tr>
<td>
_kgl_message_locks
</td>
<td>
64
</td>
<td>
RAC message lock count
</td>
</tr>
<tr>
<td>
_kgl_min_cached_so_count
</td>
<td>
1
</td>
<td>
Minimum cached SO count. If &gt; 1 can help find
 SO corruptions
</td>
</tr>
<tr>
<td>
_kgl_multi_instance_invalidation
</td>
<td>
TRUE
</td>
<td>
whether KGL to support multi-instance invalid
ations
</td>
</tr>
<tr>
<td>
_kgl_multi_instance_lock
</td>
<td>
TRUE
</td>
<td>
whether KGL to support multi-instance locks
</td>
</tr>
<tr>
<td>
_kgl_multi_instance_pin
</td>
<td>
TRUE
</td>
<td>
whether KGL to support multi-instance pins
</td>
</tr>
<tr>
<td>
_kgl_so_stack_depth
</td>
<td>
16
</td>
<td>
The depth of the stack capture for SO get or
free
</td>
</tr>
<tr>
<td>
_kgl_time_to_wait_for_locks
</td>
<td>
15
</td>
<td>
time to wait for locks and pins before timing
 out
</td>
</tr>
<tr>
<td>
_kglsim_maxmem_percent
</td>
<td>
5
</td>
<td>
max percentage of shared pool size to be used
 for KGL advice
</td>
</tr>
<tr>
<td>
_kgsb_threshold_size
</td>
<td>
16777216
</td>
<td>
threshold size for base allocator
</td>
</tr>
<tr>
<td>
_kgx_latches
</td>
<td>
1024
</td>
<td>
# of mutex latches if CAS is not supported.
</td>
</tr>
<tr>
<td>
_kgx_spin_count
</td>
<td>
255
</td>
<td>
third spare parameter - integer
</td>
</tr>
<tr>
<td>
_kill_controlfile_enqueue_blocker
</td>
<td>
TRUE
</td>
<td>
enable killing controlfile enqueue blocker on
 timeout
</td>
</tr>
<tr>
<td>
_kill_diagnostics_timeout
</td>
<td>
60
</td>
<td>
timeout delay in seconds before killing enque
ue blocker
</td>
</tr>
<tr>
<td>
_kill_enqueue_blocker
</td>
<td>
2
</td>
<td>
if greater than 0 enables killing enqueue blo
cker
</td>
</tr>
<tr>
<td>
_kill_java_threads_on_eoc
</td>
<td>
FALSE
</td>
<td>
Kill Java threads and do sessionspace migrati
on at end of call
</td>
</tr>
<tr>
<td>
_kill_session_dump
</td>
<td>
TRUE
</td>
<td>
Process dump on kill session immediate
</td>
</tr>
<tr>
<td>
_kkdlgon_max_iter
</td>
<td>
20000
</td>
<td>
kkdlgon maximum number of iterations
</td>
</tr>
<tr>
<td>
_kkfi_trace
</td>
<td>
FALSE
</td>
<td>
trace expression substitution
</td>
</tr>
<tr>
<td>
_kks_free_cursor_stat_pct
</td>
<td>
10
</td>
<td>
percentage of cursor stats buckets to scan on
 each load, in 1/10th of a percent
</td>
</tr>
<tr>
<td>
_kks_use_mutex_pin
</td>
<td>
TRUE
</td>
<td>
Turning on this will make KKS use mutex for c
ursor pins.
</td>
</tr>
<tr>
<td>
_kokli_cache_size
</td>
<td>
32
</td>
<td>
Size limit of Materialized View and Object Ta
ble Lookup Cache
</td>
</tr>
<tr>
<td>
_kolfuseslf
</td>
<td>
FALSE
</td>
<td>
allow kolf to use slffopen
</td>
</tr>
<tr>
<td>
_kql_subheap_trace
</td>
<td>
0
</td>
<td>
tracing level for library cache subheap level
 pins
</td>
</tr>
<tr>
<td>
_ksb_disable_diagpid
</td>
<td>
FALSE
</td>
<td>
disable the call to ksb_diagpid
</td>
</tr>
<tr>
<td>
_ksb_restart_clean_time
</td>
<td>
30000
</td>
<td>
process uptime for restarts
</td>
</tr>
<tr>
<td>
_ksb_restart_policy_times
</td>
<td>
0, 60, 120, 240
</td>
<td>
process restart policy times in seconds
</td>
</tr>
<tr>
<td>
_ksd_test_param
</td>
<td>
999
</td>
<td>
KSD test parmeter
</td>
</tr>
<tr>
<td>
_ksdxdocmd_default_timeout_ms
</td>
<td>
30000
</td>
<td>
default timeout for internal oradebug command
s
</td>
</tr>
<tr>
<td>
_ksdxdocmd_enabled
</td>
<td>
TRUE
</td>
<td>
if TRUE ksdxdocmd* invocations are enabled
</td>
</tr>
<tr>
<td>
_ksdxw_cini_flg
</td>
<td>
0
</td>
<td>
ksdxw context initialization flag
</td>
</tr>
<tr>
<td>
_ksdxw_nbufs
</td>
<td>
1000
</td>
<td>
ksdxw number of buffers in buffered mode
</td>
</tr>
<tr>
<td>
_ksdxw_num_pgw
</td>
<td>
10
</td>
<td>
number of watchpoints on a per-process basis
</td>
</tr>
<tr>
<td>
_ksdxw_num_sgw
</td>
<td>
10
</td>
<td>
number of watchpoints to be shared by all pro
cesses
</td>
</tr>
<tr>
<td>
_ksdxw_stack_depth
</td>
<td>
4
</td>
<td>
number of PCs to collect in the stack when wa
tchpoint is hit
</td>
</tr>
<tr>
<td>
_kse_die_timeout
</td>
<td>
60000
</td>
<td>
amount of time a dying process is spared by P
MON (in centi-secs)
</td>
</tr>
<tr>
<td>
_kse_pc_table_size
</td>
<td>
256
</td>
<td>
kse pc table cache size
</td>
</tr>
<tr>
<td>
_kse_signature_entries
</td>
<td>
0
</td>
<td>
number of entries in the kse stack signature
cache
</td>
</tr>
<tr>
<td>
_kse_signature_limit
</td>
<td>
7
</td>
<td>
number of stack frames to cache per kse signa
ture
</td>
</tr>
<tr>
<td>
_kse_snap_ring_size
</td>
<td>
0
</td>
<td>
ring buffer to debug internal error 17090
</td>
</tr>
<tr>
<td>
_ksfd_verify_write
</td>
<td>
FALSE
</td>
<td>
verify asynchronous writes issued through ksf
d
</td>
</tr>
<tr>
<td>
_ksi_trace
</td>
<td>
&nbsp;
</td>
<td>
KSI trace string of lock type(s)
</td>
</tr>
<tr>
<td>
_ksi_trace_bucket
</td>
<td>
PRIVATE
</td>
<td>
memory tracing: use ksi-private or rdbms-shar
ed bucket
</td>
</tr>
<tr>
<td>
_ksi_trace_bucket_size
</td>
<td>
8192
</td>
<td>
size of the KSI trace bucket
</td>
</tr>
<tr>
<td>
_ksmb_debug
</td>
<td>
0
</td>
<td>
ksmb debug flags
</td>
</tr>
<tr>
<td>
_ksmd_protect_mode
</td>
<td>
off
</td>
<td>
KSMD protect mode for catching stale access
</td>
</tr>
<tr>
<td>
_ksmg_granule_locking_status
</td>
<td>
1
</td>
<td>
granule locking status
</td>
</tr>
<tr>
<td>
_ksmg_granule_size
</td>
<td>
4194304
</td>
<td>
granule size in bytes
</td>
</tr>
<tr>
<td>
_ksmg_lock_check_interval
</td>
<td>
&nbsp;
</td>
<td>
timeout action interval in minutes
</td>
</tr>
<tr>
<td>
_ksmg_lock_reacquire_count
</td>
<td>
5
</td>
<td>
repeat count for acquisition of locks
</td>
</tr>
<tr>
<td>
_kspol_tac_timeout
</td>
<td>
5
</td>
<td>
timeouts for TAC registerd by kspol
</td>
</tr>
<tr>
<td>
_ksr_unit_test_processes
</td>
<td>
0
</td>
<td>
number of ksr unit test processes
</td>
</tr>
<tr>
<td>
_kss_quiet
</td>
<td>
FALSE
</td>
<td>
if TRUE access violations during kss dumps ar
e not recorded
</td>
</tr>
<tr>
<td>
_ksu_diag_kill_time
</td>
<td>
5
</td>
<td>
number of seconds ksuitm waits before killing
 diag
</td>
</tr>
<tr>
<td>
_ksuitm_addon_trccmd
</td>
<td>
&nbsp;
</td>
<td>
command to execute when dead processes don't
go away
</td>
</tr>
<tr>
<td>
_ksuitm_dont_kill_dumper
</td>
<td>
FALSE
</td>
<td>
delay inst. termination to allow processes to
 dump
</td>
</tr>
<tr>
<td>
_ksv_max_spawn_fail_limit
</td>
<td>
5
</td>
<td>
bg slave spawn failure limit
</td>
</tr>
<tr>
<td>
_ksv_pool_hang_kill_to
</td>
<td>
0
</td>
<td>
bg slave pool terminate timeout
</td>
</tr>
<tr>
<td>
_ksv_pool_wait_timeout
</td>
<td>
600
</td>
<td>
bg slave pool wait limit
</td>
</tr>
<tr>
<td>
_ksv_spawn_control_all
</td>
<td>
FALSE
</td>
<td>
control all spawning of background slaves
</td>
</tr>
<tr>
<td>
_ksvppktmode
</td>
<td>
0
</td>
<td>
ksv internal pkt test
</td>
</tr>
<tr>
<td>
_ksxp_diagmode
</td>
<td>
OFF
</td>
<td>
set to OFF to disable automatic slowsend diag
nostics
</td>
</tr>
<tr>
<td>
_ksxp_disable_dynamic_loading
</td>
<td>
FALSE
</td>
<td>
disable dynamic loadin of lib skgxp
</td>
</tr>
<tr>
<td>
_ksxp_disable_ipc_stats
</td>
<td>
FALSE
</td>
<td>
disable ipc statistics
</td>
</tr>
<tr>
<td>
_ksxp_init_stats_bkts
</td>
<td>
0
</td>
<td>
initial number arrays for ipc statistics
</td>
</tr>
<tr>
<td>
_ksxp_max_stats_bkts
</td>
<td>
0
</td>
<td>
max. arrays for ipc statistics
</td>
</tr>
<tr>
<td>
_ksxp_ping_enable
</td>
<td>
TRUE
</td>
<td>
disable dynamic loadin of lib skgxp
</td>
</tr>
<tr>
<td>
_ksxp_ping_polling_time
</td>
<td>
0
</td>
<td>
max. arrays for ipc statistics
</td>
</tr>
<tr>
<td>
_ksxp_reaping
</td>
<td>
20
</td>
<td>
tune ksxp layer reaping limit
</td>
</tr>
<tr>
<td>
_ksxp_reporting_process
</td>
<td>
LMD0
</td>
<td>
reporting process for KSXP
</td>
</tr>
<tr>
<td>
_ksxp_send_timeout
</td>
<td>
300
</td>
<td>
set timeout for sends queued with the inter-i
nstance IPC
</td>
</tr>
<tr>
<td>
_ksxp_skgxp_compat_library_path
</td>
<td>
&nbsp;
</td>
<td>
over-ride default location of lib skgxp compa
t
</td>
</tr>
<tr>
<td>
_ksxp_skgxp_library_path
</td>
<td>
&nbsp;
</td>
<td>
over-ride default location of lib skgxp
</td>
</tr>
<tr>
<td>
_ksxp_stats_mem_lmt
</td>
<td>
0
</td>
<td>
limit ipc statistics memory. this parameter i
s a percentage value
</td>
</tr>
<tr>
<td>
_ksxp_testing
</td>
<td>
0
</td>
<td>
KSXP test parameter
</td>
</tr>
<tr>
<td>
_ksxp_unit_test_byte_transformation
</td>
<td>
FALSE
</td>
<td>
enable byte transformation unit test
</td>
</tr>
<tr>
<td>
_ktc_debug
</td>
<td>
0
</td>
<td>
for ktc debug
</td>
</tr>
<tr>
<td>
_ktc_latches
</td>
<td>
0
</td>
<td>
number of ktc latches
</td>
</tr>
<tr>
<td>
_ktslj_segext_warning
</td>
<td>
10
</td>
<td>
segment pre-extension warning threshold in pe
rcentage
</td>
</tr>
<tr>
<td>
_ktspsrch_maxsc
</td>
<td>
32
</td>
<td>
maximum segments supported by space search ca
che
</td>
</tr>
<tr>
<td>
_kttext_warning
</td>
<td>
5
</td>
<td>
tablespace pre-extension warning threshold in
 percentage
</td>
</tr>
<tr>
<td>
_ktu_latches
</td>
<td>
0
</td>
<td>
number of KTU latches
</td>
</tr>
<tr>
<td>
_ku_trace
</td>
<td>
none
</td>
<td>
datapump trace parameter
</td>
</tr>
<tr>
<td>
_large_pool_min_alloc
</td>
<td>
16000
</td>
<td>
minimum allocation size in bytes for the larg
e allocation pool
</td>
</tr>
<tr>
<td>
_last_allocation_period
</td>
<td>
5
</td>
<td>
period over which an instance can retain an a
ctive level1 bitmap
</td>
</tr>
<tr>
<td>
_latch_class_0
</td>
<td>
&nbsp;
</td>
<td>
latch class 0
</td>
</tr>
<tr>
<td>
_latch_class_1
</td>
<td>
&nbsp;
</td>
<td>
latch class 1
</td>
</tr>
<tr>
<td>
_latch_class_2
</td>
<td>
&nbsp;
</td>
<td>
latch class 2
</td>
</tr>
<tr>
<td>
_latch_class_3
</td>
<td>
&nbsp;
</td>
<td>
latch class 3
</td>
</tr>
<tr>
<td>
_latch_class_4
</td>
<td>
&nbsp;
</td>
<td>
latch class 4
</td>
</tr>
<tr>
<td>
_latch_class_5
</td>
<td>
&nbsp;
</td>
<td>
latch class 5
</td>
</tr>
<tr>
<td>
_latch_class_6
</td>
<td>
&nbsp;
</td>
<td>
latch class 6
</td>
</tr>
<tr>
<td>
_latch_class_7
</td>
<td>
&nbsp;
</td>
<td>
latch class 7
</td>
</tr>
<tr>
<td>
_latch_classes
</td>
<td>
&nbsp;
</td>
<td>
latch classes override
</td>
</tr>
<tr>
<td>
_latch_miss_stat_sid
</td>
<td>
0
</td>
<td>
Sid of process for which to collect latch sta
ts
</td>
</tr>
<tr>
<td>
_latch_recovery_alignment
</td>
<td>
65534
</td>
<td>
align latch recovery structures
</td>
</tr>
<tr>
<td>
_ldr_io_size
</td>
<td>
262144
</td>
<td>
size of write IOs used during a load operatio
n
</td>
</tr>
<tr>
<td>
_left_nested_loops_random
</td>
<td>
TRUE
</td>
<td>
enable random distribution method for left of
 nestedloops
</td>
</tr>
<tr>
<td>
_lgwr_async_broadcasts
</td>
<td>
TRUE
</td>
<td>
LGWR Asynchronous Broadcasts enabling boolean
 flag
</td>
</tr>
<tr>
<td>
_lgwr_delay_write
</td>
<td>
FALSE
</td>
<td>
LGWR write delay for debugging
</td>
</tr>
<tr>
<td>
_lgwr_io_slaves
</td>
<td>
0
</td>
<td>
LGWR I/O slaves
</td>
</tr>
<tr>
<td>
_lgwr_max_ns_wt
</td>
<td>
1
</td>
<td>
Maximum wait time for lgwr to allow NetServer
 to progress
</td>
</tr>
<tr>
<td>
_lgwr_ns_nl_max
</td>
<td>
1000
</td>
<td>
Variable to simulate network latency or buffe
r threshold
</td>
</tr>
<tr>
<td>
_lgwr_ns_nl_min
</td>
<td>
500
</td>
<td>
Variable to simulate network latency or buffe
r threshold
</td>
</tr>
<tr>
<td>
_lgwr_ns_sim_err
</td>
<td>
0
</td>
<td>
Variable to simulate errors lgwrns
</td>
</tr>
<tr>
<td>
_lgwr_ta_sim_err
</td>
<td>
0
</td>
<td>
Variable to simulate errors lgwr true async
</td>
</tr>
<tr>
<td>
_library_cache_advice
</td>
<td>
TRUE
</td>
<td>
whether KGL advice should be turned on
</td>
</tr>
<tr>
<td>
_lightweight_hdrs
</td>
<td>
TRUE
</td>
<td>
Lightweight headers for redo
</td>
</tr>
<tr>
<td>
_like_with_bind_as_equality
</td>
<td>
FALSE
</td>
<td>
treat LIKE predicate with bind as an equality
 predicate
</td>
</tr>
<tr>
<td>
_lm_activate_lms_threshold
</td>
<td>
100
</td>
<td>
threshold value to activate an additional lms
</td>
</tr>
<tr>
<td>
_lm_asm_enq_hashing
</td>
<td>
TRUE
</td>
<td>
if TRUE makes ASM use enqueue master hashing
for fusion locks
</td>
</tr>
<tr>
<td>
_lm_better_ddvictim
</td>
<td>
TRUE
</td>
<td>
GES better deadlock victim
</td>
</tr>
<tr>
<td>
_lm_cache_lvl0_cleanup
</td>
<td>
0
</td>
<td>
how often to cleanup level 0 cache res (in se
c)
</td>
</tr>
<tr>
<td>
_lm_cache_res_cleanup
</td>
<td>
25
</td>
<td>
percentage of cached resources should be clea
nup
</td>
</tr>
<tr>
<td>
_lm_cache_res_type
</td>
<td>
TMHWDI
</td>
<td>
cache resource: string of lock types(s)
</td>
</tr>
<tr>
<td>
_lm_checksum_batch_msg
</td>
<td>
0
</td>
<td>
GES checksum batch messages
</td>
</tr>
<tr>
<td>
_lm_contiguous_res_count
</td>
<td>
128
</td>
<td>
number of contiguous blocks that will hash to
 the same HV bucket
</td>
</tr>
<tr>
<td>
_lm_dd_interval
</td>
<td>
10
</td>
<td>
dd time interval in seconds
</td>
</tr>
<tr>
<td>
_lm_dd_max_search_time
</td>
<td>
180
</td>
<td>
max dd search time per token
</td>
</tr>
<tr>
<td>
_lm_dd_scan_interval
</td>
<td>
5
</td>
<td>
dd scan interval in seconds
</td>
</tr>
<tr>
<td>
_lm_dd_search_cnt
</td>
<td>
3
</td>
<td>
number of dd search per token get
</td>
</tr>
<tr>
<td>
_lm_drm_max_requests
</td>
<td>
100
</td>
<td>
dynamic remastering maximum affinity requests
 processed together
</td>
</tr>
<tr>
<td>
_lm_drm_window
</td>
<td>
0
</td>
<td>
dynamic remastering bucket window size
</td>
</tr>
<tr>
<td>
_lm_drm_xlatch
</td>
<td>
0
</td>
<td>
dynamic remastering forced exclusive latches
</td>
</tr>
<tr>
<td>
_lm_dynamic_lms
</td>
<td>
FALSE
</td>
<td>
dynamic lms invocation
</td>
</tr>
<tr>
<td>
_lm_dynamic_load
</td>
<td>
TRUE
</td>
<td>
dynamic load adjustment
</td>
</tr>
<tr>
<td>
_lm_enq_lock_freelist
</td>
<td>
&nbsp;
</td>
<td>
Number of ges enqueue element freelist
</td>
</tr>
<tr>
<td>
_lm_enq_rcfg
</td>
<td>
TRUE
</td>
<td>
if TRUE enables enqueue reconfiguration
</td>
</tr>
<tr>
<td>
_lm_enqueue_freelist
</td>
<td>
3
</td>
<td>
Number of enqueue freelist
</td>
</tr>
<tr>
<td>
_lm_file_affinity
</td>
<td>
&nbsp;
</td>
<td>
mapping between file id and master instance n
umber
</td>
</tr>
<tr>
<td>
_lm_global_posts
</td>
<td>
TRUE
</td>
<td>
if TRUE deliver global posts to remote nodes
</td>
</tr>
<tr>
<td>
_lm_idle_connection_check
</td>
<td>
TRUE
</td>
<td>
GES idle connection check
</td>
</tr>
<tr>
<td>
_lm_idle_connection_check_interval
</td>
<td>
10
</td>
<td>
GES idle connection check interval time
</td>
</tr>
<tr>
<td>
_lm_idle_connection_kill
</td>
<td>
FALSE
</td>
<td>
GES idle connection kill
</td>
</tr>
<tr>
<td>
_lm_lmd_waittime
</td>
<td>
8
</td>
<td>
default wait time for lmd in centiseconds
</td>
</tr>
<tr>
<td>
_lm_lmon_nowait_latch
</td>
<td>
TRUE
</td>
<td>
if TRUE makes lmon get nowait latches with ti
meout loop
</td>
</tr>
<tr>
<td>
_lm_lms
</td>
<td>
0
</td>
<td>
number of background gcs server processes to
start
</td>
</tr>
<tr>
<td>
_lm_lms_waittime
</td>
<td>
8
</td>
<td>
default wait time for lms in centiseconds
</td>
</tr>
<tr>
<td>
_lm_locks
</td>
<td>
12000
</td>
<td>
number of enqueues configured for cluster dat
abase
</td>
</tr>
<tr>
<td>
_lm_master_weight
</td>
<td>
1
</td>
<td>
master resource weight for this instance
</td>
</tr>
<tr>
<td>
_lm_max_lms
</td>
<td>
0
</td>
<td>
max. number of background global cache server
 processes
</td>
</tr>
<tr>
<td>
_lm_msg_batch_size
</td>
<td>
0
</td>
<td>
GES batch message size
</td>
</tr>
<tr>
<td>
_lm_msg_cleanup_interval
</td>
<td>
3000
</td>
<td>
GES message buffer cleanup interval time
</td>
</tr>
<tr>
<td>
_lm_node_join_opt
</td>
<td>
FALSE
</td>
<td>
cluster database node join optimization in re
config
</td>
</tr>
<tr>
<td>
_lm_non_fault_tolerant
</td>
<td>
FALSE
</td>
<td>
disable cluster database fault-tolerance mode
</td>
</tr>
<tr>
<td>
_lm_num_pt_buckets
</td>
<td>
8192
</td>
<td>
number of buckets in the object affinity hash
 table
</td>
</tr>
<tr>
<td>
_lm_num_pt_latches
</td>
<td>
128
</td>
<td>
number of latches in the object affinity hash
 table
</td>
</tr>
<tr>
<td>
_lm_postevent_buffer_size
</td>
<td>
256
</td>
<td>
postevent buffer size
</td>
</tr>
<tr>
<td>
_lm_proc_freeze_timeout
</td>
<td>
300
</td>
<td>
reconfiguration: process freeze timeout
</td>
</tr>
<tr>
<td>
_lm_process_batching
</td>
<td>
TRUE
</td>
<td>
GES implicit process batching for IPC message
s
</td>
</tr>
<tr>
<td>
_lm_procs
</td>
<td>
320
</td>
<td>
number of client processes configured for clu
ster database
</td>
</tr>
<tr>
<td>
_lm_psrcfg
</td>
<td>
FALSE
</td>
<td>
enable pseudo reconfiguration
</td>
</tr>
<tr>
<td>
_lm_rcfg_timeout
</td>
<td>
1260
</td>
<td>
Reconfiguration timeout
</td>
</tr>
<tr>
<td>
_lm_rcvr_hang_allow_time
</td>
<td>
200
</td>
<td>
receiver hang allow time in seconds
</td>
</tr>
<tr>
<td>
_lm_rcvr_hang_check_frequency
</td>
<td>
60
</td>
<td>
receiver hang check frequency in seconds
</td>
</tr>
<tr>
<td>
_lm_rcvr_hang_kill
</td>
<td>
FALSE
</td>
<td>
to kill receiver hang
</td>
</tr>
<tr>
<td>
_lm_res_hash_bucket
</td>
<td>
0
</td>
<td>
number of resource hash buckets
</td>
</tr>
<tr>
<td>
_lm_res_part
</td>
<td>
128
</td>
<td>
number of resource partition configured for g
cs
</td>
</tr>
<tr>
<td>
_lm_ress
</td>
<td>
6000
</td>
<td>
number of resources configured for cluster da
tabase
</td>
</tr>
<tr>
<td>
_lm_send_mode
</td>
<td>
auto
</td>
<td>
GES send mode
</td>
</tr>
<tr>
<td>
_lm_send_queue_batching
</td>
<td>
TRUE
</td>
<td>
GES send queue message batching
</td>
</tr>
<tr>
<td>
_lm_send_queue_length
</td>
<td>
5000
</td>
<td>
GES send queue maximum length
</td>
</tr>
<tr>
<td>
_lm_sendproxy_reserve
</td>
<td>
25
</td>
<td>
GES percentage of send proxy reserve of send
tickets
</td>
</tr>
<tr>
<td>
_lm_share_lock_opt
</td>
<td>
FALSE
</td>
<td>
if TRUE enables share lock optimization
</td>
</tr>
<tr>
<td>
_lm_sq_batch_factor
</td>
<td>
2
</td>
<td>
GES send queue minimum batching factor
</td>
</tr>
<tr>
<td>
_lm_sq_batch_type
</td>
<td>
auto
</td>
<td>
GES send queue batching mechanism
</td>
</tr>
<tr>
<td>
_lm_sq_batch_waittick
</td>
<td>
3
</td>
<td>
GES send queue batching waittime in tick
</td>
</tr>
<tr>
<td>
_lm_sync_timeout
</td>
<td>
420
</td>
<td>
Synchronization timeout for DLM reconfigurati
on steps
</td>
</tr>
<tr>
<td>
_lm_ticket_active_sendback
</td>
<td>
&nbsp;
</td>
<td>
Flow control ticket active sendback threshold
</td>
</tr>
<tr>
<td>
_lm_tickets
</td>
<td>
1000
</td>
<td>
GES messaging tickets
</td>
</tr>
<tr>
<td>
_lm_tx_delta
</td>
<td>
16
</td>
<td>
TX lock localization delta
</td>
</tr>
<tr>
<td>
_lm_validate_resource_type
</td>
<td>
FALSE
</td>
<td>
if TRUE enables resource name validation
</td>
</tr>
<tr>
<td>
_lm_xids
</td>
<td>
352
</td>
<td>
number of transaction IDs configured for clus
ter database
</td>
</tr>
<tr>
<td>
_lmn_compression
</td>
<td>
FALSE
</td>
<td>
suppl logging for compression enabled
</td>
</tr>
<tr>
<td>
_load_without_compile
</td>
<td>
none
</td>
<td>
Load PL/SQL or Database objects without compi
lation
</td>
</tr>
<tr>
<td>
_local_communication_costing_enabled
</td>
<td>
TRUE
</td>
<td>
enable local communication costing when TRUE
</td>
</tr>
<tr>
<td>
_local_communication_ratio
</td>
<td>
50
</td>
<td>
set the ratio between global and local commun
ication (0..100)
</td>
</tr>
<tr>
<td>
_local_hang_analysis_interval_secs
</td>
<td>
3
</td>
<td>
the interval at which local hang analysis is
run
</td>
</tr>
<tr>
<td>
_lock_sga_areas
</td>
<td>
0
</td>
<td>
Lock specified areas of the SGA in physical m
emory
</td>
</tr>
<tr>
<td>
_log_archive_avoid_memcpy
</td>
<td>
TRUE
</td>
<td>
log archive avoid memcpy
</td>
</tr>
<tr>
<td>
_log_archive_buffers
</td>
<td>
4
</td>
<td>
Number of buffers to allocate for archiving
</td>
</tr>
<tr>
<td>
_log_archive_callout
</td>
<td>
&nbsp;
</td>
<td>
archival callout
</td>
</tr>
<tr>
<td>
_log_archive_compress_enable
</td>
<td>
FALSE
</td>
<td>
Bypass database rules for enabling archivelog
 compression
</td>
</tr>
<tr>
<td>
_log_archive_network_redo_size
</td>
<td>
10
</td>
<td>
Log archive network redo buffer size used by
ARCH
</td>
</tr>
<tr>
<td>
_log_archive_prot_auto_demote
</td>
<td>
FALSE
</td>
<td>
log archive protection auto demotion
</td>
</tr>
<tr>
<td>
_log_archive_security_enabled
</td>
<td>
TRUE
</td>
<td>
log archive security enabled
</td>
</tr>
<tr>
<td>
_log_archive_strong_auth
</td>
<td>
TRUE
</td>
<td>
log archive security strong auth
</td>
</tr>
<tr>
<td>
_log_blocks_during_backup
</td>
<td>
TRUE
</td>
<td>
log block images when changed during backup
</td>
</tr>
<tr>
<td>
_log_buffers_corrupt
</td>
<td>
FALSE
</td>
<td>
corrupt redo buffers before write
</td>
</tr>
<tr>
<td>
_log_buffers_debug
</td>
<td>
FALSE
</td>
<td>
debug redo buffers (slows things down)
</td>
</tr>
<tr>
<td>
_log_checkpoint_recovery_check
</td>
<td>
0
</td>
<td>
# redo blocks to verify after checkpoint
</td>
</tr>
<tr>
<td>
_log_committime_block_cleanout
</td>
<td>
FALSE
</td>
<td>
Log commit-time block cleanout
</td>
</tr>
<tr>
<td>
_log_deletion_policy
</td>
<td>
mandatory
</td>
<td>
archivelog deletion policy for mandatory/all
destination
</td>
</tr>
<tr>
<td>
_log_event_queues
</td>
<td>
0
</td>
<td>
number of the log writer event queues
</td>
</tr>
<tr>
<td>
_log_io_size
</td>
<td>
0
</td>
<td>
automatically initiate log write if this many
 redo blocks in buffer
</td>
</tr>
<tr>
<td>
_log_parallelism_dynamic
</td>
<td>
TRUE
</td>
<td>
Enable dynamic strands
</td>
</tr>
<tr>
<td>
_log_parallelism_max
</td>
<td>
2
</td>
<td>
Maximum number of log buffer strands
</td>
</tr>
<tr>
<td>
_log_private_mul
</td>
<td>
5
</td>
<td>
Private strand multiplier for log space preal
location
</td>
</tr>
<tr>
<td>
_log_private_parallelism
</td>
<td>
FALSE
</td>
<td>
Number of private log buffer strands for zero
-copy redo
</td>
</tr>
<tr>
<td>
_log_private_parallelism_mul
</td>
<td>
10
</td>
<td>
Active sessions multiplier to deduce number o
f private strands
</td>
</tr>
<tr>
<td>
_log_read_buffers
</td>
<td>
4
</td>
<td>
Number of log read buffers for media recovery
</td>
</tr>
<tr>
<td>
_log_simultaneous_copies
</td>
<td>
4
</td>
<td>
number of simultaneous copies into redo buffe
r(# of copy latches)
</td>
</tr>
<tr>
<td>
_log_space_errors
</td>
<td>
TRUE
</td>
<td>
should we report space errors to alert log
</td>
</tr>
<tr>
<td>
_log_switch_timeout
</td>
<td>
0
</td>
<td>
Maximum number of seconds redos in the curren
t log could span
</td>
</tr>
<tr>
<td>
_logout_storm_rate
</td>
<td>
0
</td>
<td>
number of processes that can logout in a seco
nd
</td>
</tr>
<tr>
<td>
_logout_storm_retrycnt
</td>
<td>
600
</td>
<td>
maximum retry count for logouts
</td>
</tr>
<tr>
<td>
_logout_storm_timeout
</td>
<td>
5
</td>
<td>
timeout in centi-seconds for time to wait bet
ween retries
</td>
</tr>
<tr>
<td>
_longops_enabled
</td>
<td>
TRUE
</td>
<td>
longops stats enabled
</td>
</tr>
<tr>
<td>
_low_server_threshold
</td>
<td>
0
</td>
<td>
low server thresholds
</td>
</tr>
<tr>
<td>
_ltc_trace
</td>
<td>
0
</td>
<td>
tracing level for load table conventional
</td>
</tr>
<tr>
<td>
_master_direct_sends
</td>
<td>
31
</td>
<td>
direct sends for messages from master (DFS)
</td>
</tr>
<tr>
<td>
_mav_refresh_consistent_read
</td>
<td>
TRUE
</td>
<td>
refresh materialized views using consistent r
ead snapshot
</td>
</tr>
<tr>
<td>
_mav_refresh_double_count_prevented
</td>
<td>
FALSE
</td>
<td>
materialized view MAV refreshes avoid double
counting
</td>
</tr>
<tr>
<td>
_mav_refresh_opt
</td>
<td>
0
</td>
<td>
optimizations during refresh of materialized
views
</td>
</tr>
<tr>
<td>
_mav_refresh_unionall_tables
</td>
<td>
3
</td>
<td>
# tables for union all expansion during mater
ialized view refresh
</td>
</tr>
<tr>
<td>
_max_arch_lns_wait
</td>
<td>
120
</td>
<td>
Maximum wait by ARCH to allow NetServer to co
mplete archival
</td>
</tr>
<tr>
<td>
_max_exponential_sleep
</td>
<td>
0
</td>
<td>
max sleep during exponential backoff
</td>
</tr>
<tr>
<td>
_max_io_size
</td>
<td>
1048576
</td>
<td>
Maximum I/O size in bytes for sequential file
 accesses
</td>
</tr>
<tr>
<td>
_max_large_io
</td>
<td>
0
</td>
<td>
IORM:max number of large I/O's to issue
</td>
</tr>
<tr>
<td>
_max_lns_shutdown_archival_time
</td>
<td>
30
</td>
<td>
Maximum time spent by LNS to archive last log
 during shutdown
</td>
</tr>
<tr>
<td>
_max_protocol_support
</td>
<td>
10000
</td>
<td>
Max occurrence protocols supported in a proce
ss
</td>
</tr>
<tr>
<td>
_max_shrink_obj_stats
</td>
<td>
0
</td>
<td>
number of segments for which shrink stats wil
l be maintained
</td>
</tr>
<tr>
<td>
_max_sleep_holding_latch
</td>
<td>
4
</td>
<td>
max time to sleep while holding a latch
</td>
</tr>
<tr>
<td>
_max_small_io
</td>
<td>
0
</td>
<td>
IORM:max number of small I/O's to issue
</td>
</tr>
<tr>
<td>
_max_spacebg_slaves
</td>
<td>
10
</td>
<td>
maximum space management background slaves
</td>
</tr>
<tr>
<td>
_max_spacebg_tasks
</td>
<td>
1000
</td>
<td>
maximum space management background tasks
</td>
</tr>
<tr>
<td>
_max_temp_overhead
</td>
<td>
0
</td>
<td>
max tempspc overhead
</td>
</tr>
<tr>
<td>
_media_recovery_read_batch
</td>
<td>
128
</td>
<td>
media recovery block read batch
</td>
</tr>
<tr>
<td>
_mem_annotation_pr_lev
</td>
<td>
0
</td>
<td>
private memory annotation collection level
</td>
</tr>
<tr>
<td>
_mem_annotation_scale
</td>
<td>
1
</td>
<td>
memory annotation pre-allocation scaling
</td>
</tr>
<tr>
<td>
_mem_annotation_sh_lev
</td>
<td>
0
</td>
<td>
shared memory annotation collection level
</td>
</tr>
<tr>
<td>
_mem_annotation_store
</td>
<td>
FALSE
</td>
<td>
memory annotation in-memory store
</td>
</tr>
<tr>
<td>
_mem_std_extent_size
</td>
<td>
4096
</td>
<td>
standard extent size for fixed-size-extent he
aps
</td>
</tr>
<tr>
<td>
_memory_broker_log_stat_entries
</td>
<td>
5
</td>
<td>
memory broker num stat entries
</td>
</tr>
<tr>
<td>
_memory_broker_marginal_utility_bc
</td>
<td>
12
</td>
<td>
Marginal Utility threshold pct for bc
</td>
</tr>
<tr>
<td>
_memory_broker_marginal_utility_sp
</td>
<td>
7
</td>
<td>
Marginal Utility threshold pct for sp
</td>
</tr>
<tr>
<td>
_memory_broker_shrink_heaps
</td>
<td>
0
</td>
<td>
memory broker allow policy to shrink shared p
ool
</td>
</tr>
<tr>
<td>
_memory_broker_shrink_java_heaps
</td>
<td>
900
</td>
<td>
memory broker allow policy to shrink java poo
l
</td>
</tr>
<tr>
<td>
_memory_broker_shrink_streams_pool
</td>
<td>
900
</td>
<td>
memory broker allow policy to shrink streams
pool
</td>
</tr>
<tr>
<td>
_memory_broker_shrink_timeout
</td>
<td>
60000000
</td>
<td>
memory broker policy to timeout shrink shared
/java pool
</td>
</tr>
<tr>
<td>
_memory_broker_stat_interval
</td>
<td>
30
</td>
<td>
memory broker statistics gathering interval f
or auto sga
</td>
</tr>
<tr>
<td>
_memory_management_tracing
</td>
<td>
0
</td>
<td>
trace memory management activity
</td>
</tr>
<tr>
<td>
_memory_nocancel_defsgareq
</td>
<td>
FALSE
</td>
<td>
do not cancel deferred sga reqs with auto-mem
ory
</td>
</tr>
<tr>
<td>
_memory_sanity_check
</td>
<td>
0
</td>
<td>
partial granule sanity check
</td>
</tr>
<tr>
<td>
_messages
</td>
<td>
100
</td>
<td>
message queue resources - dependent on # proc
esses &amp; # buffers
</td>
</tr>
<tr>
<td>
_midtier_affinity_clusterwait_threshold
</td>
<td>
100
</td>
<td>
cluster wait threshold to enter affinity
</td>
</tr>
<tr>
<td>
_midtier_affinity_goodness_threshold
</td>
<td>
2000
</td>
<td>
goodness gradient threshold to dissolve affin
ity
</td>
</tr>
<tr>
<td>
_midtier_affinity_timeout
</td>
<td>
30000
</td>
<td>
default timeout for midtier affinity processi
ng
</td>
</tr>
<tr>
<td>
_minfree_plus
</td>
<td>
0
</td>
<td>
max percentage of block space + minfree befor
e we mark block full
</td>
</tr>
<tr>
<td>
_minimal_stats_aggregation
</td>
<td>
TRUE
</td>
<td>
prohibit stats aggregation at compile/partiti
on maintenance time
</td>
</tr>
<tr>
<td>
_minimum_blocks_to_shrink
</td>
<td>
0
</td>
<td>
minimum number freeable blocks for shrink to
be present
</td>
</tr>
<tr>
<td>
_minimum_db_flashback_retention
</td>
<td>
60
</td>
<td>
Minimum flashback retention
</td>
</tr>
<tr>
<td>
_minimum_extents_to_shrink
</td>
<td>
1
</td>
<td>
minimum number freeable extents for shrink to
 be present
</td>
</tr>
<tr>
<td>
_minimum_giga_scn
</td>
<td>
0
</td>
<td>
Minimum SCN to start with in 2^30 units
</td>
</tr>
<tr>
<td>
_mirror_redo_buffers
</td>
<td>
FALSE
</td>
<td>
Save buffers for debugging redo corruptions
</td>
</tr>
<tr>
<td>
_mmv_query_rewrite_enabled
</td>
<td>
TRUE
</td>
<td>
allow rewrites with multiple MVs and/or base
tables
</td>
</tr>
<tr>
<td>
_multi_instance_pmr
</td>
<td>
TRUE
</td>
<td>
force multi instance or single instance paral
lel recovery
</td>
</tr>
<tr>
<td>
_multi_join_key_table_lookup
</td>
<td>
TRUE
</td>
<td>
TRUE iff multi-join-key table lookup prefetch
 is enabled
</td>
</tr>
<tr>
<td>
_multiple_instance_recovery
</td>
<td>
FALSE
</td>
<td>
use multiple instances for media recovery
</td>
</tr>
<tr>
<td>
_mv_refresh_ana
</td>
<td>
0
</td>
<td>
what percent to analyze after complete/PCT re
fresh
</td>
</tr>
<tr>
<td>
_mv_refresh_costing
</td>
<td>
rule
</td>
<td>
refresh decision based on cost or on rules
</td>
</tr>
<tr>
<td>
_mv_refresh_delta_fraction
</td>
<td>
10
</td>
<td>
delta mv as fractional percentage of size of
mv
</td>
</tr>
<tr>
<td>
_mv_refresh_eut
</td>
<td>
TRUE
</td>
<td>
refresh materialized views using EUT(partitio
n)-based algorithm
</td>
</tr>
<tr>
<td>
_mv_refresh_force_parallel_query
</td>
<td>
0
</td>
<td>
force materialized view refreshes to use para
llel query
</td>
</tr>
<tr>
<td>
_mv_refresh_new_setup_disabled
</td>
<td>
FALSE
</td>
<td>
materialized view MV refresh new setup disabl
ing
</td>
</tr>
<tr>
<td>
_mv_refresh_rebuild_percentage
</td>
<td>
10
</td>
<td>
minimum percentage change required in MV to f
orce an indexrebuild
</td>
</tr>
<tr>
<td>
_mv_refresh_selections
</td>
<td>
TRUE
</td>
<td>
create materialized views with selections and
 fast refresh
</td>
</tr>
<tr>
<td>
_mv_refresh_use_stats
</td>
<td>
FALSE
</td>
<td>
pass cardinality hints to refresh queries
</td>
</tr>
<tr>
<td>
_mv_refsched_timeincr
</td>
<td>
300000
</td>
<td>
proportionality constant for dop vs. time in
MV refresh
</td>
</tr>
<tr>
<td>
_mv_rolling_inv
</td>
<td>
FALSE
</td>
<td>
create/alter mv uses rolling cursor invalidat
ion instead of immediate
</td>
</tr>
<tr>
<td>
_mwin_schedule
</td>
<td>
TRUE
</td>
<td>
Enable/disable Maintenance Window Schedules
</td>
</tr>
<tr>
<td>
_nchar_imp_cnv
</td>
<td>
TRUE
</td>
<td>
NLS allow Implicit Conversion between CHAR an
d NCHAR
</td>
</tr>
<tr>
<td>
_nchar_imp_conv
</td>
<td>
TRUE
</td>
<td>
should implicit conversion bewteen clob and n
clob be allowed
</td>
</tr>
<tr>
<td>
_ncmb_readahead_enabled
</td>
<td>
0
</td>
<td>
enable multi-block readahead for an index sca
n
</td>
</tr>
<tr>
<td>
_ncmb_readahead_tracing
</td>
<td>
0
</td>
<td>
turn on multi-block readahead tracing
</td>
</tr>
<tr>
<td>
_nested_loop_fudge
</td>
<td>
100
</td>
<td>
nested loop fudge
</td>
</tr>
<tr>
<td>
_nested_mav_fast_oncommit_enabled
</td>
<td>
TRUE
</td>
<td>
nested MAV refresh fast on commit allowed
</td>
</tr>
<tr>
<td>
_new_initial_join_orders
</td>
<td>
TRUE
</td>
<td>
enable initial join orders based on new order
ing heuristics
</td>
</tr>
<tr>
<td>
_new_sort_cost_estimate
</td>
<td>
TRUE
</td>
<td>
enables the use of new cost estimate for sort
</td>
</tr>
<tr>
<td>
_newsort_enabled
</td>
<td>
TRUE
</td>
<td>
controls whether new sorts can be used as sys
tem sort
</td>
</tr>
<tr>
<td>
_newsort_ordered_pct
</td>
<td>
63
</td>
<td>
controls when new sort avoids sorting ordered
 input
</td>
</tr>
<tr>
<td>
_newsort_type
</td>
<td>
0
</td>
<td>
specifies options for the new sort algorithm
</td>
</tr>
<tr>
<td>
_nlj_batching_enabled
</td>
<td>
1
</td>
<td>
enable batching of the RHS IO in NLJ
</td>
</tr>
<tr>
<td>
_nlj_batching_misses_enabled
</td>
<td>
1
</td>
<td>
enable exceptions for buffer cache misses
</td>
</tr>
<tr>
<td>
_no_objects
</td>
<td>
FALSE
</td>
<td>
no object features are used
</td>
</tr>
<tr>
<td>
_no_or_expansion
</td>
<td>
FALSE
</td>
<td>
OR expansion during optimization disabled
</td>
</tr>
<tr>
<td>
_no_recovery_through_resetlogs
</td>
<td>
FALSE
</td>
<td>
no recovery through this resetlogs operation
</td>
</tr>
<tr>
<td>
_notify_crs
</td>
<td>
FALSE
</td>
<td>
notify cluster ready services of startup and
shutdown
</td>
</tr>
<tr>
<td>
_ns_max_flush_wt
</td>
<td>
1
</td>
<td>
Flush wait time for NetServer to flush oustan
ding writes
</td>
</tr>
<tr>
<td>
_ns_max_send_delay
</td>
<td>
15
</td>
<td>
Data Loss Time Bound for NetServer
</td>
</tr>
<tr>
<td>
_num_longop_child_latches
</td>
<td>
2
</td>
<td>
number of child latches for long op array
</td>
</tr>
<tr>
<td>
_number_cached_attributes
</td>
<td>
10
</td>
<td>
maximum number of cached attributes per insta
nce
</td>
</tr>
<tr>
<td>
_object_reuse_bast
</td>
<td>
2
</td>
<td>
if 1 or higher, handle object reuse
</td>
</tr>
<tr>
<td>
_object_statistics
</td>
<td>
TRUE
</td>
<td>
enable the object level statistics collection
</td>
</tr>
<tr>
<td>
_object_stats_max_entries
</td>
<td>
3072
</td>
<td>
Maximum number of entries to be tracked per s
tat
</td>
</tr>
<tr>
<td>
_offline_rollback_segments
</td>
<td>
&nbsp;
</td>
<td>
offline undo segment list
</td>
</tr>
<tr>
<td>
_ogms_home
</td>
<td>
&nbsp;
</td>
<td>
GMS home directory
</td>
</tr>
<tr>
<td>
_olap_aggregate_buffer_size
</td>
<td>
1048576
</td>
<td>
OLAP Aggregate max buffer size
</td>
</tr>
<tr>
<td>
_olap_aggregate_flags
</td>
<td>
0
</td>
<td>
OLAP Aggregate debug flags
</td>
</tr>
<tr>
<td>
_olap_aggregate_function_cache_enabled
</td>
<td>
TRUE
</td>
<td>
OLAP Aggregate function cache enabler
</td>
</tr>
<tr>
<td>
_olap_aggregate_function_merge_threshold
</td>
<td>
529
</td>
<td>
OLAP Aggregate function merge threshold
</td>
</tr>
<tr>
<td>
_olap_aggregate_max_thread_tuples
</td>
<td>
5000
</td>
<td>
OLAP Aggregate max thread tuples creation
</td>
</tr>
<tr>
<td>
_olap_aggregate_min_buffer_size
</td>
<td>
1024
</td>
<td>
OLAP Aggregate min buffer size
</td>
</tr>
<tr>
<td>
_olap_aggregate_min_thread_status
</td>
<td>
64
</td>
<td>
OLAP Aggregate minimum cardinality of dimensi
ons for thread
</td>
</tr>
<tr>
<td>
_olap_aggregate_multipath_hier
</td>
<td>
FALSE
</td>
<td>
OLAP Aggregate Multi-path Hierarhies enabled
</td>
</tr>
<tr>
<td>
_olap_aggregate_statlen_thresh
</td>
<td>
1024
</td>
<td>
OLAP Aggregate status array usage threshold
</td>
</tr>
<tr>
<td>
_olap_aggregate_store_probability
</td>
<td>
100
</td>
<td>
OLAP Aggregate function storeback probability
</td>
</tr>
<tr>
<td>
_olap_aggregate_work_per_thread
</td>
<td>
1024
</td>
<td>
OLAP Aggregate max work parents
</td>
</tr>
<tr>
<td>
_olap_aggregate_worklist_max
</td>
<td>
5000
</td>
<td>
OLAP Aggregate max worklists generated at onc
e
</td>
</tr>
<tr>
<td>
_olap_allocate_errorlog_format
</td>
<td>
%8p %8y %8z %e (%n)
</td>
<td>
OLAP Allocate Errorlog Format
</td>
</tr>
<tr>
<td>
_olap_allocate_errorlog_header
</td>
<td>
Dim	 Source   Basis
%
-8d %-8s %-8b Description

-------- -------- ------
-- -----------
</td>
<td>
OLAP Allocate Errorlog Header format
</td>
</tr>
<tr>
<td>
_olap_analyze_max
</td>
<td>
10000
</td>
<td>
OLAP DML ANALYZE command max cells to analyze
</td>
</tr>
<tr>
<td>
_olap_continuous_trace_file
</td>
<td>
FALSE
</td>
<td>
Specify TRUE to enable continuous OLAP tracin
g - otherwise only exceptional events will be
 logged
</td>
</tr>
<tr>
<td>
_olap_dbgoutfile_echo_to_eventlog
</td>
<td>
FALSE
</td>
<td>
OLAP DbgOutfile copy output to event log (tra
cefile)
</td>
</tr>
<tr>
<td>
_olap_dimension_corehash_class
</td>
<td>
1
</td>
<td>
OLAP Dimension In-Core Hash Table Class
</td>
</tr>
<tr>
<td>
_olap_dimension_corehash_large
</td>
<td>
50000
</td>
<td>
OLAP Dimension In-Core Hash Table Large Thres
hold
</td>
</tr>
<tr>
<td>
_olap_dimension_corehash_pressure
</td>
<td>
90
</td>
<td>
OLAP Dimension In-Core Hash Table Pressure Th
reshold
</td>
</tr>
<tr>
<td>
_olap_dimension_corehash_size
</td>
<td>
30
</td>
<td>
OLAP Dimension In-Core Hash Table Maximum Mem
ory Use
</td>
</tr>
<tr>
<td>
_olap_dimension_corehash_small
</td>
<td>
1000
</td>
<td>
OLAP Dimension In-Core Hash Table Small Thres
hold
</td>
</tr>
<tr>
<td>
_olap_eif_export_lob_size
</td>
<td>
2147483647
</td>
<td>
OLAP EIF Export BLOB size
</td>
</tr>
<tr>
<td>
_olap_lmgen_dim_size
</td>
<td>
100
</td>
<td>
Limitmap generator dimension column size
</td>
</tr>
<tr>
<td>
_olap_lmgen_meas_size
</td>
<td>
1000
</td>
<td>
Limitmap generator measure column size
</td>
</tr>
<tr>
<td>
_olap_object_hash_class
</td>
<td>
2
</td>
<td>
OLAP Object Hash Table Class
</td>
</tr>
<tr>
<td>
_olap_page_pool_expand_rate
</td>
<td>
20
</td>
<td>
OLAP Page Pool Expand Rate
</td>
</tr>
<tr>
<td>
_olap_page_pool_hi
</td>
<td>
50
</td>
<td>
OLAP Page Pool High Watermark
</td>
</tr>
<tr>
<td>
_olap_page_pool_hit_target
</td>
<td>
100
</td>
<td>
OLAP Page Pool Hit Target
</td>
</tr>
<tr>
<td>
_olap_page_pool_low
</td>
<td>
262144
</td>
<td>
OLAP Page Pool Low Watermark
</td>
</tr>
<tr>
<td>
_olap_page_pool_pressure
</td>
<td>
90
</td>
<td>
OLAP Page Pool Pressure Threshold
</td>
</tr>
<tr>
<td>
_olap_page_pool_shrink_rate
</td>
<td>
50
</td>
<td>
OLAP Page Pool Shrink Rate
</td>
</tr>
<tr>
<td>
_olap_parallel_update_small_group
</td>
<td>
400
</td>
<td>
OLAP parallel update pagespace by group
</td>
</tr>
<tr>
<td>
_olap_parallel_update_small_threshold
</td>
<td>
1000
</td>
<td>
OLAP parallel update threshold for number of
small pagespaces
</td>
</tr>
<tr>
<td>
_olap_parallel_update_threshold
</td>
<td>
1000
</td>
<td>
OLAP parallel update threshold in pages
</td>
</tr>
<tr>
<td>
_olap_poutlog_echo_to_eventlog
</td>
<td>
FALSE
</td>
<td>
OLAP POutLog copy output to event log (tracef
ile)
</td>
</tr>
<tr>
<td>
_olap_sesscache_enabled
</td>
<td>
TRUE
</td>
<td>
OLAP Session Cache knob
</td>
</tr>
<tr>
<td>
_olap_sort_buffer_size
</td>
<td>
262144
</td>
<td>
OLAP Sort Buffer Size
</td>
</tr>
<tr>
<td>
_olap_statbool_corebits
</td>
<td>
20000000
</td>
<td>
OLAP Status Boolean max incore bits
</td>
</tr>
<tr>
<td>
_olap_statbool_threshold
</td>
<td>
8100
</td>
<td>
OLAP Status Boolean CBM threshold
</td>
</tr>
<tr>
<td>
_olap_table_function_statistics
</td>
<td>
FALSE
</td>
<td>
Specify TRUE to output OLAP table function ti
med statistics trace
</td>
</tr>
<tr>
<td>
_olap_wrap_errors
</td>
<td>
FALSE
</td>
<td>
Wrap error messages to OLAP outfile
</td>
</tr>
<tr>
<td>
_olapi_history_retention
</td>
<td>
FALSE
</td>
<td>
enable olapi history retention
</td>
</tr>
<tr>
<td>
_olapi_iface_object_history
</td>
<td>
1000
</td>
<td>
enable olapi interface object history collect
ion
</td>
</tr>
<tr>
<td>
_olapi_iface_object_history_retention
</td>
<td>
FALSE
</td>
<td>
enable olapi interface object history retenti
on
</td>
</tr>
<tr>
<td>
_olapi_iface_operation_history_retention
</td>
<td>
FALSE
</td>
<td>
enable olapi interface operation history rete
ntion
</td>
</tr>
<tr>
<td>
_olapi_interface_operation_history
</td>
<td>
1000
</td>
<td>
enable olapi interface operation history coll
ection
</td>
</tr>
<tr>
<td>
_olapi_memory_operation_history
</td>
<td>
1000
</td>
<td>
enable olapi memory alloc/free history collec
tion
</td>
</tr>
<tr>
<td>
_olapi_memory_operation_history_pause_at_seqn
o
</td>
<td>
0
</td>
<td>
enable olapi memory alloc/free history collec
tion pausing
</td>
</tr>
<tr>
<td>
_olapi_memory_operation_history_retention
</td>
<td>
FALSE
</td>
<td>
enable olapi memory operation history retenti
on
</td>
</tr>
<tr>
<td>
_olapi_session_history
</td>
<td>
300
</td>
<td>
enable olapi session history collection
</td>
</tr>
<tr>
<td>
_olapi_session_history_retention
</td>
<td>
FALSE
</td>
<td>
enable olapi session history retention
</td>
</tr>
<tr>
<td>
_old_connect_by_enabled
</td>
<td>
FALSE
</td>
<td>
enable/disable old connect by
</td>
</tr>
<tr>
<td>
_ols_cleanup_task
</td>
<td>
TRUE
</td>
<td>
Clean up unnecessary entries in OLS sessinfo
table
</td>
</tr>
<tr>
<td>
_oltp_compression
</td>
<td>
TRUE
</td>
<td>
oltp compression enabled
</td>
</tr>
<tr>
<td>
_oltp_compression_gain
</td>
<td>
10
</td>
<td>
oltp compression gain
</td>
</tr>
<tr>
<td>
_omf
</td>
<td>
enabled
</td>
<td>
enable/disable OMF
</td>
</tr>
<tr>
<td>
_oneside_colstat_for_equijoins
</td>
<td>
TRUE
</td>
<td>
sanity check on default selectivity for like/
range predicate
</td>
</tr>
<tr>
<td>
_optim_adjust_for_part_skews
</td>
<td>
TRUE
</td>
<td>
adjust stats for skews across partitions
</td>
</tr>
<tr>
<td>
_optim_dict_stats_at_db_cr_upg
</td>
<td>
TRUE
</td>
<td>
enable/disable dictionary stats gathering at
db create/upgrade
</td>
</tr>
<tr>
<td>
_optim_enhance_nnull_detection
</td>
<td>
TRUE
</td>
<td>
TRUE to enable index [fast] full scan more of
ten
</td>
</tr>
<tr>
<td>
_optim_new_default_join_sel
</td>
<td>
TRUE
</td>
<td>
improves the way default equijoin selectivity
 are computed
</td>
</tr>
<tr>
<td>
_optim_peek_user_binds
</td>
<td>
TRUE
</td>
<td>
enable peeking of user binds
</td>
</tr>
<tr>
<td>
_optimizer_adaptive_cursor_sharing
</td>
<td>
TRUE
</td>
<td>
optimizer adaptive cursor sharing
</td>
</tr>
<tr>
<td>
_optimizer_adjust_for_nulls
</td>
<td>
TRUE
</td>
<td>
adjust selectivity for null values
</td>
</tr>
<tr>
<td>
_optimizer_autostats_job
</td>
<td>
TRUE
</td>
<td>
enable/disable auto stats collection job
</td>
</tr>
<tr>
<td>
_optimizer_aw_join_push_enabled
</td>
<td>
TRUE
</td>
<td>
Enables AW Join Push optimization
</td>
</tr>
<tr>
<td>
_optimizer_aw_stats_enabled
</td>
<td>
TRUE
</td>
<td>
Enables statistcs on AW olap_table table func
tion
</td>
</tr>
<tr>
<td>
_optimizer_better_inlist_costing
</td>
<td>
ALL
</td>
<td>
enable improved costing of index access using
 in-list(s)
</td>
</tr>
<tr>
<td>
_optimizer_block_size
</td>
<td>
8192
</td>
<td>
standard block size used by optimizer
</td>
</tr>
<tr>
<td>
_optimizer_cache_stats
</td>
<td>
FALSE
</td>
<td>
cost with cache statistics
</td>
</tr>
<tr>
<td>
_optimizer_cartesian_enabled
</td>
<td>
TRUE
</td>
<td>
optimizer cartesian join enabled
</td>
</tr>
<tr>
<td>
_optimizer_cbqt_factor
</td>
<td>
50
</td>
<td>
cost factor for cost-based query transformati
on
</td>
</tr>
<tr>
<td>
_optimizer_cbqt_no_size_restriction
</td>
<td>
TRUE
</td>
<td>
disable cost based transformation query size
restriction
</td>
</tr>
<tr>
<td>
_optimizer_ceil_cost
</td>
<td>
TRUE
</td>
<td>
CEIL cost in CBO
</td>
</tr>
<tr>
<td>
_optimizer_choose_permutation
</td>
<td>
0
</td>
<td>
force the optimizer to use the specified perm
utation
</td>
</tr>
<tr>
<td>
_optimizer_complex_pred_selectivity
</td>
<td>
TRUE
</td>
<td>
enable selectivity estimation for builtin fun
ctions
</td>
</tr>
<tr>
<td>
_optimizer_compute_index_stats
</td>
<td>
TRUE
</td>
<td>
force index stats collection on index creatio
n/rebuild
</td>
</tr>
<tr>
<td>
_optimizer_connect_by_combine_sw
</td>
<td>
TRUE
</td>
<td>
combine no filtering connect by and start wit
h
</td>
</tr>
<tr>
<td>
_optimizer_connect_by_cost_based
</td>
<td>
TRUE
</td>
<td>
use cost-based transformation for connect by
</td>
</tr>
<tr>
<td>
_optimizer_correct_sq_selectivity
</td>
<td>
TRUE
</td>
<td>
force correct computation of subquery selecti
vity
</td>
</tr>
<tr>
<td>
_optimizer_cost_based_transformation
</td>
<td>
LINEAR
</td>
<td>
enables cost-based query transformation
</td>
</tr>
<tr>
<td>
_optimizer_cost_filter_pred
</td>
<td>
FALSE
</td>
<td>
enables  costing of filter predicates in IO c
ost model
</td>
</tr>
<tr>
<td>
_optimizer_cost_hjsmj_multimatch
</td>
<td>
TRUE
</td>
<td>
add cost of generating result set when #rows
per key &gt; 1
</td>
</tr>
<tr>
<td>
_optimizer_cost_model
</td>
<td>
CHOOSE
</td>
<td>
optimizer cost model
</td>
</tr>
<tr>
<td>
_optimizer_degree
</td>
<td>
0
</td>
<td>
force the optimizer to use the same degree of
 parallelism
</td>
</tr>
<tr>
<td>
_optimizer_dim_subq_join_sel
</td>
<td>
TRUE
</td>
<td>
use join selectivity in choosing star transfo
rmation dimensions
</td>
</tr>
<tr>
<td>
_optimizer_disable_strans_sanity_checks
</td>
<td>
0
</td>
<td>
disable star transformation sanity checks
</td>
</tr>
<tr>
<td>
_optimizer_distinct_elimination
</td>
<td>
TRUE
</td>
<td>
Eliminates redundant SELECT DISTNCT's
</td>
</tr>
<tr>
<td>
_optimizer_dyn_smp_blks
</td>
<td>
32
</td>
<td>
number of blocks for optimizer dynamic sampli
ng
</td>
</tr>
<tr>
<td>
_optimizer_enable_density_improvements
</td>
<td>
TRUE
</td>
<td>
use improved density computation for selectiv
ity estimation
</td>
</tr>
<tr>
<td>
_optimizer_enable_extended_stats
</td>
<td>
TRUE
</td>
<td>
use extended statistics for selectivity estim
ation
</td>
</tr>
<tr>
<td>
_optimizer_enhanced_filter_push
</td>
<td>
TRUE
</td>
<td>
push filters before trying cost-based query t
ransformation
</td>
</tr>
<tr>
<td>
_optimizer_extend_jppd_view_types
</td>
<td>
TRUE
</td>
<td>
join pred pushdown on group-by, distinct, sem
i-/anti-joined view
</td>
</tr>
<tr>
<td>
_optimizer_extended_cursor_sharing
</td>
<td>
UDO
</td>
<td>
optimizer extended cursor sharing
</td>
</tr>
<tr>
<td>
_optimizer_extended_cursor_sharing_rel
</td>
<td>
SIMPLE
</td>
<td>
optimizer extended cursor sharing for relatio
nal operators
</td>
</tr>
<tr>
<td>
_optimizer_extended_stats_usage_control
</td>
<td>
240
</td>
<td>
controls the optimizer usage of extended stat
s
</td>
</tr>
<tr>
<td>
_optimizer_filter_pred_pullup
</td>
<td>
TRUE
</td>
<td>
use cost-based flter predicate pull up transf
ormation
</td>
</tr>
<tr>
<td>
_optimizer_fkr_index_cost_bias
</td>
<td>
10
</td>
<td>
Optimizer index bias over FTS/IFFS under firs
t K rows mode
</td>
</tr>
<tr>
<td>
_optimizer_free_transformation_heap
</td>
<td>
TRUE
</td>
<td>
free transformation subheap after each transf
ormation
</td>
</tr>
<tr>
<td>
_optimizer_group_by_placement
</td>
<td>
TRUE
</td>
<td>
consider group-by placement optimization
</td>
</tr>
<tr>
<td>
_optimizer_ignore_hints
</td>
<td>
FALSE
</td>
<td>
enables the embedded hints to be ignored
</td>
</tr>
<tr>
<td>
_optimizer_improve_selectivity
</td>
<td>
TRUE
</td>
<td>
improve table and partial overlap join select
ivity computation
</td>
</tr>
<tr>
<td>
_optimizer_invalidation_period
</td>
<td>
18000
</td>
<td>
time window for invalidation of cursors of an
alyzed objects
</td>
</tr>
<tr>
<td>
_optimizer_join_elimination_enabled
</td>
<td>
TRUE
</td>
<td>
optimizer join elimination enabled
</td>
</tr>
<tr>
<td>
_optimizer_join_order_control
</td>
<td>
3
</td>
<td>
controls the optimizer join order search algo
rithm
</td>
</tr>
<tr>
<td>
_optimizer_join_sel_sanity_check
</td>
<td>
TRUE
</td>
<td>
enable/disable sanity check for multi-column
join selectivity
</td>
</tr>
<tr>
<td>
_optimizer_max_permutations
</td>
<td>
2000
</td>
<td>
optimizer maximum join permutations per query
 block
</td>
</tr>
<tr>
<td>
_optimizer_min_cache_blocks
</td>
<td>
10
</td>
<td>
set minimum cached blocks
</td>
</tr>
<tr>
<td>
_optimizer_mjc_enabled
</td>
<td>
TRUE
</td>
<td>
enable merge join cartesian
</td>
</tr>
<tr>
<td>
_optimizer_mode_force
</td>
<td>
TRUE
</td>
<td>
force setting of optimizer mode for user recu
rsive SQL also
</td>
</tr>
<tr>
<td>
_optimizer_multi_level_push_pred
</td>
<td>
TRUE
</td>
<td>
consider join-predicate pushdown that require
s multi-level pushdown to base table
</td>
</tr>
<tr>
<td>
_optimizer_multiple_cenv
</td>
<td>
&nbsp;
</td>
<td>
generate and run plans using several compilat
ion environments
</td>
</tr>
<tr>
<td>
_optimizer_native_full_outer_join
</td>
<td>
FORCE
</td>
<td>
execute full outer join using native implemen
taion
</td>
</tr>
<tr>
<td>
_optimizer_nested_rollup_for_gset
</td>
<td>
100
</td>
<td>
number of groups above which we use nested ro
llup exec for gset
</td>
</tr>
<tr>
<td>
_optimizer_new_join_card_computation
</td>
<td>
TRUE
</td>
<td>
compute join cardinality using non-rounded in
put values
</td>
</tr>
<tr>
<td>
_optimizer_null_aware_antijoin
</td>
<td>
TRUE
</td>
<td>
null-aware antijoin parameter
</td>
</tr>
<tr>
<td>
_optimizer_or_expansion
</td>
<td>
DEPTH
</td>
<td>
control or expansion approach used
</td>
</tr>
<tr>
<td>
_optimizer_or_expansion_subheap
</td>
<td>
TRUE
</td>
<td>
Use subheap for optimizer or-expansion
</td>
</tr>
<tr>
<td>
_optimizer_order_by_elimination_enabled
</td>
<td>
TRUE
</td>
<td>
Eliminates order bys from views before query
transformation
</td>
</tr>
<tr>
<td>
_optimizer_outer_to_anti_enabled
</td>
<td>
TRUE
</td>
<td>
Enable transformation of outer-join to anti-j
oin if possible
</td>
</tr>
<tr>
<td>
_optimizer_percent_parallel
</td>
<td>
101
</td>
<td>
optimizer percent parallel
</td>
</tr>
<tr>
<td>
_optimizer_push_down_distinct
</td>
<td>
0
</td>
<td>
push down distinct from query block to table
</td>
</tr>
<tr>
<td>
_optimizer_push_pred_cost_based
</td>
<td>
TRUE
</td>
<td>
use cost-based query transformation for push
pred optimization
</td>
</tr>
<tr>
<td>
_optimizer_random_plan
</td>
<td>
0
</td>
<td>
optimizer seed value for random plans
</td>
</tr>
<tr>
<td>
_optimizer_reuse_cost_annotations
</td>
<td>
TRUE
</td>
<td>
reuse cost annotations during cost-based quer
y transformation
</td>
</tr>
<tr>
<td>
_optimizer_rownum_bind_default
</td>
<td>
10
</td>
<td>
Default value to use for rownum bind
</td>
</tr>
<tr>
<td>
_optimizer_rownum_pred_based_fkr
</td>
<td>
TRUE
</td>
<td>
enable the use of first K rows due to rownum
predicate
</td>
</tr>
<tr>
<td>
_optimizer_save_stats
</td>
<td>
TRUE
</td>
<td>
enable/disable saving old versions of optimiz
er stats
</td>
</tr>
<tr>
<td>
_optimizer_search_limit
</td>
<td>
5
</td>
<td>
optimizer search limit
</td>
</tr>
<tr>
<td>
_optimizer_self_induced_cache_cost
</td>
<td>
FALSE
</td>
<td>
account for self-induced caching
</td>
</tr>
<tr>
<td>
_optimizer_skip_scan_enabled
</td>
<td>
TRUE
</td>
<td>
enable/disable index skip scan
</td>
</tr>
<tr>
<td>
_optimizer_skip_scan_guess
</td>
<td>
FALSE
</td>
<td>
consider index skip scan for predicates with
guessed selectivity
</td>
</tr>
<tr>
<td>
_optimizer_sortmerge_join_enabled
</td>
<td>
TRUE
</td>
<td>
enable/disable sort-merge join method
</td>
</tr>
<tr>
<td>
_optimizer_sortmerge_join_inequality
</td>
<td>
TRUE
</td>
<td>
enable/disable sort-merge join using inequali
ty predicates
</td>
</tr>
<tr>
<td>
_optimizer_squ_bottomup
</td>
<td>
TRUE
</td>
<td>
enables unnesting of subquery in a bottom-up
manner
</td>
</tr>
<tr>
<td>
_optimizer_star_tran_in_with_clause
</td>
<td>
TRUE
</td>
<td>
enable/disable star transformation in with cl
ause queries
</td>
</tr>
<tr>
<td>
_optimizer_star_trans_min_cost
</td>
<td>
0
</td>
<td>
optimizer star transformation minimum cost
</td>
</tr>
<tr>
<td>
_optimizer_star_trans_min_ratio
</td>
<td>
0
</td>
<td>
optimizer star transformation minimum ratio
</td>
</tr>
<tr>
<td>
_optimizer_starplan_enabled
</td>
<td>
TRUE
</td>
<td>
optimizer star plan enabled
</td>
</tr>
<tr>
<td>
_optimizer_system_stats_usage
</td>
<td>
TRUE
</td>
<td>
system statistics usage
</td>
</tr>
<tr>
<td>
_optimizer_trace
</td>
<td>
none
</td>
<td>
optimizer trace parameter
</td>
</tr>
<tr>
<td>
_optimizer_transitivity_retain
</td>
<td>
TRUE
</td>
<td>
retain equi-join pred upon transitive equalit
y pred generation
</td>
</tr>
<tr>
<td>
_optimizer_undo_changes
</td>
<td>
FALSE
</td>
<td>
undo changes to query optimizer
</td>
</tr>
<tr>
<td>
_optimizer_undo_cost_change
</td>
<td>
11.1.0.6
</td>
<td>
optimizer undo cost change
</td>
</tr>
<tr>
<td>
_optimizer_use_subheap
</td>
<td>
TRUE
</td>
<td>
Enables physical optimizer subheap
</td>
</tr>
<tr>
<td>
_or_expand_nvl_predicate
</td>
<td>
TRUE
</td>
<td>
enable OR expanded plan for NVL/DECODE predic
ate
</td>
</tr>
<tr>
<td>
_oradebug_force
</td>
<td>
FALSE
</td>
<td>
force target processes to execute oradebug co
mmands?
</td>
</tr>
<tr>
<td>
_ordered_nested_loop
</td>
<td>
TRUE
</td>
<td>
enable ordered nested loop costing
</td>
</tr>
<tr>
<td>
_ordered_semijoin
</td>
<td>
TRUE
</td>
<td>
enable ordered semi-join subquery
</td>
</tr>
<tr>
<td>
_orph_cln_interval
</td>
<td>
1200
</td>
<td>
qmon periodic interval for removed subscriber
 messages cleanup
</td>
</tr>
<tr>
<td>
_os_sched_high_priority
</td>
<td>
1
</td>
<td>
OS high priority level
</td>
</tr>
<tr>
<td>
_other_wait_event_exclusion
</td>
<td>
&nbsp;
</td>
<td>
exclude event names from _other_wait_threshol
d calculations
</td>
</tr>
<tr>
<td>
_other_wait_threshold
</td>
<td>
0
</td>
<td>
threshold wait percentage for event wait clas
s Other
</td>
</tr>
<tr>
<td>
_outline_bitmap_tree
</td>
<td>
TRUE
</td>
<td>
BITMAP_TREE hint enabled in outline
</td>
</tr>
<tr>
<td>
_parallel_adaptive_max_users
</td>
<td>
2
</td>
<td>
maximum number of users running with default
DOP
</td>
</tr>
<tr>
<td>
_parallel_broadcast_enabled
</td>
<td>
TRUE
</td>
<td>
enable broadcasting of small inputs to hash a
nd sort merge joins
</td>
</tr>
<tr>
<td>
_parallel_default_max_instances
</td>
<td>
1
</td>
<td>
default maximum number of instances for paral
lel query
</td>
</tr>
<tr>
<td>
_parallel_execution_message_align
</td>
<td>
FALSE
</td>
<td>
Alignment of PX buffers to OS page boundary
</td>
</tr>
<tr>
<td>
_parallel_fake_class_pct
</td>
<td>
0
</td>
<td>
fake db-scheduler percent used for testing
</td>
</tr>
<tr>
<td>
_parallel_fixwrite_bucket
</td>
<td>
1000
</td>
<td>
Number of buckets for each round of fix write
</td>
</tr>
<tr>
<td>
_parallel_load_bal_unit
</td>
<td>
0
</td>
<td>
number of threads to allocate per instance
</td>
</tr>
<tr>
<td>
_parallel_load_balancing
</td>
<td>
TRUE
</td>
<td>
parallel execution load balanced slave alloca
tion
</td>
</tr>
<tr>
<td>
_parallel_min_message_pool
</td>
<td>
618624
</td>
<td>
minimum size of shared pool memory to reserve
 for pq servers
</td>
</tr>
<tr>
<td>
_parallel_policy
</td>
<td>
MANUAL
</td>
<td>
policy used to compute the degree of parallel
ism (MANUAL/LIMITED/AUTO)
</td>
</tr>
<tr>
<td>
_parallel_recovery_stopat
</td>
<td>
32767
</td>
<td>
stop at -position- to step through SMON
</td>
</tr>
<tr>
<td>
_parallel_replay_msg_limit
</td>
<td>
4000
</td>
<td>
Number of messages for each round of parallel
 replay
</td>
</tr>
<tr>
<td>
_parallel_server_idle_time
</td>
<td>
30000
</td>
<td>
idle time before parallel query server dies (
in 1/100 sec)
</td>
</tr>
<tr>
<td>
_parallel_server_sleep_time
</td>
<td>
10
</td>
<td>
sleep time between dequeue timeouts (in 1/100
ths)
</td>
</tr>
<tr>
<td>
_parallel_slave_acquisition_wait
</td>
<td>
1
</td>
<td>
time(in seconds) to wait before retrying slav
e acquisition
</td>
</tr>
<tr>
<td>
_parallel_time_threshold
</td>
<td>
10
</td>
<td>
threshold above which a plan is a candidate f
or parallelization (in seconds)
</td>
</tr>
<tr>
<td>
_parallel_time_unit
</td>
<td>
10
</td>
<td>
unit of work used to derive the degree of par
allelism (in seconds)
</td>
</tr>
<tr>
<td>
_parallel_txn_global
</td>
<td>
FALSE
</td>
<td>
enable parallel_txn hint with updates and del
etes
</td>
</tr>
<tr>
<td>
_parallelism_cost_fudge_factor
</td>
<td>
350
</td>
<td>
set the parallelism cost fudge factor
</td>
</tr>
<tr>
<td>
_parameter_table_block_size
</td>
<td>
1024
</td>
<td>
parameter table block size
</td>
</tr>
<tr>
<td>
_partial_pwise_join_enabled
</td>
<td>
TRUE
</td>
<td>
enable partial partition-wise join when TRUE
</td>
</tr>
<tr>
<td>
_partition_view_enabled
</td>
<td>
TRUE
</td>
<td>
enable/disable partitioned views
</td>
</tr>
<tr>
<td>
_passwordfile_enqueue_timeout
</td>
<td>
900
</td>
<td>
password file enqueue timeout in seconds
</td>
</tr>
<tr>
<td>
_pct_refresh_double_count_prevented
</td>
<td>
TRUE
</td>
<td>
materialized view PCT refreshes avoid double
counting
</td>
</tr>
<tr>
<td>
_pdml_gim_sampling
</td>
<td>
5000
</td>
<td>
control separation of global index maintenanc
e for PDML
</td>
</tr>
<tr>
<td>
_pdml_gim_staggered
</td>
<td>
FALSE
</td>
<td>
slaves start on different index when doing in
dex maint
</td>
</tr>
<tr>
<td>
_pdml_slaves_diff_part
</td>
<td>
TRUE
</td>
<td>
slaves start on different partition when doin
g index maint
</td>
</tr>
<tr>
<td>
_percent_flashback_buf_partial_full
</td>
<td>
50
</td>
<td>
Percent of flashback buffer filled to be cons
idered partial full
</td>
</tr>
<tr>
<td>
_pga_large_extent_size
</td>
<td>
1048576
</td>
<td>
PGA large extent size
</td>
</tr>
<tr>
<td>
_pga_max_size
</td>
<td>
214732800
</td>
<td>
Maximum size of the PGA memory for one proces
s
</td>
</tr>
<tr>
<td>
_ping_level
</td>
<td>
3
</td>
<td>
fusion ping level
</td>
</tr>
<tr>
<td>
_pivot_implementation_method
</td>
<td>
CHOOSE
</td>
<td>
pivot implementation method
</td>
</tr>
<tr>
<td>
_pkt_enable
</td>
<td>
FALSE
</td>
<td>
enable progressive kill test
</td>
</tr>
<tr>
<td>
_pkt_pmon_interval
</td>
<td>
50
</td>
<td>
PMON process clean-up interval (cs)
</td>
</tr>
<tr>
<td>
_pkt_start
</td>
<td>
FALSE
</td>
<td>
start progressive kill test instrumention
</td>
</tr>
<tr>
<td>
_plan_outline_data
</td>
<td>
TRUE
</td>
<td>
explain plan outline data enabled
</td>
</tr>
<tr>
<td>
_plan_verify_improvement_margin
</td>
<td>
150
</td>
<td>
Performance improvement criterion for evolvin
g plan baselines
</td>
</tr>
<tr>
<td>
_plan_verify_local_time_limit
</td>
<td>
0
</td>
<td>
Local time limit to use for an individual pla
n verification
</td>
</tr>
<tr>
<td>
_plsql_anon_block_code_type
</td>
<td>
INTERPRETED
</td>
<td>
PL/SQL anonymous block code-type
</td>
</tr>
<tr>
<td>
_plsql_cache_enable
</td>
<td>
TRUE
</td>
<td>
PL/SQL Function Cache Enabled
</td>
</tr>
<tr>
<td>
_plsql_dump_buffer_events
</td>
<td>
&nbsp;
</td>
<td>
conditions upon which the PL/SQL circular buf
fer is dumped
</td>
</tr>
<tr>
<td>
_plsql_minimum_cache_hit_percent
</td>
<td>
20
</td>
<td>
plsql minimum cache hit percentage required t
o keep caching active
</td>
</tr>
<tr>
<td>
_plsql_nvl_optimize
</td>
<td>
FALSE
</td>
<td>
PL/SQL NVL optimize
</td>
</tr>
<tr>
<td>
_pmon_load_constants
</td>
<td>
300,192,64,3,10,10,0,0
</td>
<td>
server load balancing constants (S,P,D,I,L,C,
M)
</td>
</tr>
<tr>
<td>
_pre_rewrite_push_pred
</td>
<td>
TRUE
</td>
<td>
push predicates into views before rewrite
</td>
</tr>
<tr>
<td>
_precompute_gid_values
</td>
<td>
TRUE
</td>
<td>
precompute gid values and copy them before re
turning a row
</td>
</tr>
<tr>
<td>
_pred_move_around
</td>
<td>
TRUE
</td>
<td>
enables predicate move-around
</td>
</tr>
<tr>
<td>
_predicate_elimination_enabled
</td>
<td>
TRUE
</td>
<td>
allow predicate elimination if set to TRUE
</td>
</tr>
<tr>
<td>
_prescomm
</td>
<td>
FALSE
</td>
<td>
presume commit of IMU transactions
</td>
</tr>
<tr>
<td>
_print_refresh_schedule
</td>
<td>
false
</td>
<td>
enable dbms_output of materialized view refre
sh schedule
</td>
</tr>
<tr>
<td>
_private_memory_address
</td>
<td>
&nbsp;
</td>
<td>
Start address of large extent memory segment
</td>
</tr>
<tr>
<td>
_project_view_columns
</td>
<td>
TRUE
</td>
<td>
enable projecting out unreferenced columns of
 a view
</td>
</tr>
<tr>
<td>
_projection_pushdown
</td>
<td>
TRUE
</td>
<td>
projection pushdown
</td>
</tr>
<tr>
<td>
_projection_pushdown_debug
</td>
<td>
0
</td>
<td>
level for projection pushdown debugging
</td>
</tr>
<tr>
<td>
_prop_old_enabled
</td>
<td>
FALSE
</td>
<td>
Shift to pre 11g propagation behaviour
</td>
</tr>
<tr>
<td>
_protect_frame_heaps
</td>
<td>
FALSE
</td>
<td>
Protect cursor frame heaps
</td>
</tr>
<tr>
<td>
_push_join_predicate
</td>
<td>
TRUE
</td>
<td>
enable pushing join predicate inside a view
</td>
</tr>
<tr>
<td>
_push_join_union_view
</td>
<td>
TRUE
</td>
<td>
enable pushing join predicate inside a union
all view
</td>
</tr>
<tr>
<td>
_push_join_union_view2
</td>
<td>
TRUE
</td>
<td>
enable pushing join predicate inside a union
view
</td>
</tr>
<tr>
<td>
_px_async_getgranule
</td>
<td>
FALSE
</td>
<td>
asynchronous get granule in the slave
</td>
</tr>
<tr>
<td>
_px_bind_peek_sharing
</td>
<td>
TRUE
</td>
<td>
enables sharing of px cursors that were built
 using bind peeking
</td>
</tr>
<tr>
<td>
_px_broadcast_fudge_factor
</td>
<td>
100
</td>
<td>
set the tq broadcasting fudge factor percenta
ge
</td>
</tr>
<tr>
<td>
_px_buffer_ttl
</td>
<td>
30
</td>
<td>
ttl for px mesg buffers in seconds
</td>
</tr>
<tr>
<td>
_px_compilation_debug
</td>
<td>
0
</td>
<td>
debug level for parallel compilation
</td>
</tr>
<tr>
<td>
_px_compilation_trace
</td>
<td>
0
</td>
<td>
tracing level for parallel compilation
</td>
</tr>
<tr>
<td>
_px_dump_12805_source
</td>
<td>
TRUE
</td>
<td>
enables or disables tracing of 12805 signal s
ource
</td>
</tr>
<tr>
<td>
_px_dynamic_opt
</td>
<td>
TRUE
</td>
<td>
turn off/on restartable qerpx dynamic optimiz
ation
</td>
</tr>
<tr>
<td>
_px_dynamic_sample_size
</td>
<td>
50
</td>
<td>
num of samples for restartable qerpx dynamic
optimization
</td>
</tr>
<tr>
<td>
_px_execution_services_enabled
</td>
<td>
TRUE
</td>
<td>
enable service-based constraint of px slave a
llocation
</td>
</tr>
<tr>
<td>
_px_granule_size
</td>
<td>
100000
</td>
<td>
default size of a rowid range granule (in KB)
</td>
</tr>
<tr>
<td>
_px_index_sampling
</td>
<td>
200
</td>
<td>
parallel query sampling for index create (100
000 = 100%)
</td>
</tr>
<tr>
<td>
_px_io_process_bandwidth
</td>
<td>
200
</td>
<td>
IO process bandwidth in MB/sec for computing
DOP
</td>
</tr>
<tr>
<td>
_px_io_system_bandwidth
</td>
<td>
0
</td>
<td>
total IO system bandwidth in MB/sec for compu
ting DOP
</td>
</tr>
<tr>
<td>
_px_kxib_tracing
</td>
<td>
0
</td>
<td>
turn on kxib tracing
</td>
</tr>
<tr>
<td>
_px_load_publish_interval
</td>
<td>
200
</td>
<td>
interval at which LMON will check whether to
publish PX load
</td>
</tr>
<tr>
<td>
_px_loc_msg_cost
</td>
<td>
1000
</td>
<td>
CPU cost to send a PX message via shared memo
ry
</td>
</tr>
<tr>
<td>
_px_max_granules_per_slave
</td>
<td>
100
</td>
<td>
maximum number of rowid range granules to gen
erate per slave
</td>
</tr>
<tr>
<td>
_px_min_granules_per_slave
</td>
<td>
13
</td>
<td>
minimum number of rowid range granules to gen
erate per slave
</td>
</tr>
<tr>
<td>
_px_minus_intersect
</td>
<td>
TRUE
</td>
<td>
enables pq for minus/interect operators
</td>
</tr>
<tr>
<td>
_px_net_msg_cost
</td>
<td>
10000
</td>
<td>
CPU cost to send a PX message over the intern
connect
</td>
</tr>
<tr>
<td>
_px_no_granule_sort
</td>
<td>
FALSE
</td>
<td>
prevent parallel partition granules to be sor
ted on size
</td>
</tr>
<tr>
<td>
_px_no_stealing
</td>
<td>
FALSE
</td>
<td>
prevent parallel granule stealing in shared n
othing environment
</td>
</tr>
<tr>
<td>
_px_nss_planb
</td>
<td>
TRUE
</td>
<td>
enables or disables NSS Plan B reparse with o
utline
</td>
</tr>
<tr>
<td>
_px_proc_constrain
</td>
<td>
TRUE
</td>
<td>
reduce parallel_max_servers if greater than (
processes - fudge)
</td>
</tr>
<tr>
<td>
_px_pwg_enabled
</td>
<td>
TRUE
</td>
<td>
parallel partition wise group by enabled
</td>
</tr>
<tr>
<td>
_px_rownum_pd
</td>
<td>
TRUE
</td>
<td>
turn off/on parallel rownum pushdown optimiza
tion
</td>
</tr>
<tr>
<td>
_px_send_timeout
</td>
<td>
300
</td>
<td>
IPC message  send timeout value in seconds
</td>
</tr>
<tr>
<td>
_px_slaves_share_cursors
</td>
<td>
0
</td>
<td>
slaves share cursors with QC
</td>
</tr>
<tr>
<td>
_px_trace
</td>
<td>
none
</td>
<td>
px trace parameter
</td>
</tr>
<tr>
<td>
_px_ual_serial_input
</td>
<td>
TRUE
</td>
<td>
enables new pq for UNION operators
</td>
</tr>
<tr>
<td>
_px_xtgranule_size
</td>
<td>
10000
</td>
<td>
default size of a external table granule (in
KB)
</td>
</tr>
<tr>
<td>
_qa_control
</td>
<td>
0
</td>
<td>
Oracle internal parameter to control QA
</td>
</tr>
<tr>
<td>
_qa_lrg_type
</td>
<td>
0
</td>
<td>
Oracle internal parameter to specify QA lrg t
ype
</td>
</tr>
<tr>
<td>
_query_cost_rewrite
</td>
<td>
TRUE
</td>
<td>
perform the cost based rewrite with materiali
zed views
</td>
</tr>
<tr>
<td>
_query_execution_cache_max_size
</td>
<td>
65536
</td>
<td>
max size of query execution cache
</td>
</tr>
<tr>
<td>
_query_mmvrewrite_maxcmaps
</td>
<td>
20
</td>
<td>
query mmv rewrite maximum number of cmaps per
 dmap in query disjunct
</td>
</tr>
<tr>
<td>
_query_mmvrewrite_maxdmaps
</td>
<td>
10
</td>
<td>
query mmv rewrite maximum number of dmaps per
 query disjunct
</td>
</tr>
<tr>
<td>
_query_mmvrewrite_maxinlists
</td>
<td>
5
</td>
<td>
query mmv rewrite maximum number of in-lists
per disjunct
</td>
</tr>
<tr>
<td>
_query_mmvrewrite_maxintervals
</td>
<td>
5
</td>
<td>
query mmv rewrite maximum number of intervals
 per disjunct
</td>
</tr>
<tr>
<td>
_query_mmvrewrite_maxmergedcmaps
</td>
<td>
50
</td>
<td>
query mmv rewrite maximum number of merged cm
aps
</td>
</tr>
<tr>
<td>
_query_mmvrewrite_maxpreds
</td>
<td>
10
</td>
<td>
query mmv rewrite maximum number of predicate
s per disjunct
</td>
</tr>
<tr>
<td>
_query_mmvrewrite_maxqryinlistvals
</td>
<td>
500
</td>
<td>
query mmv rewrite maximum number of query in-
list values
</td>
</tr>
<tr>
<td>
_query_mmvrewrite_maxregperm
</td>
<td>
512
</td>
<td>
query mmv rewrite maximum number of region pe
rmutations
</td>
</tr>
<tr>
<td>
_query_rewrite_1
</td>
<td>
TRUE
</td>
<td>
perform query rewrite before&amp;after or only be
fore view merging
</td>
</tr>
<tr>
<td>
_query_rewrite_2
</td>
<td>
TRUE
</td>
<td>
perform query rewrite before&amp;after or only af
ter view merging
</td>
</tr>
<tr>
<td>
_query_rewrite_drj
</td>
<td>
TRUE
</td>
<td>
mv rewrite and drop redundant joins
</td>
</tr>
<tr>
<td>
_query_rewrite_expression
</td>
<td>
TRUE
</td>
<td>
rewrite with cannonical form for expressions
</td>
</tr>
<tr>
<td>
_query_rewrite_fpc
</td>
<td>
TRUE
</td>
<td>
mv rewrite fresh partition containment
</td>
</tr>
<tr>
<td>
_query_rewrite_fudge
</td>
<td>
90
</td>
<td>
cost based query rewrite with MVs fudge facto
r
</td>
</tr>
<tr>
<td>
_query_rewrite_jgmigrate
</td>
<td>
TRUE
</td>
<td>
mv rewrite with jg migration
</td>
</tr>
<tr>
<td>
_query_rewrite_maxdisjunct
</td>
<td>
257
</td>
<td>
query rewrite max disjuncts
</td>
</tr>
<tr>
<td>
_query_rewrite_or_error
</td>
<td>
FALSE
</td>
<td>
allow query rewrite, if referenced tables are
 not dataless
</td>
</tr>
<tr>
<td>
_query_rewrite_setopgrw_enable
</td>
<td>
TRUE
</td>
<td>
perform general rewrite using set operator su
mmaries
</td>
</tr>
<tr>
<td>
_query_rewrite_vop_cleanup
</td>
<td>
TRUE
</td>
<td>
prune frocol chain before rewrite after view-
merging
</td>
</tr>
<tr>
<td>
_rcfg_parallel_fixwrite
</td>
<td>
TRUE
</td>
<td>
if TRUE enables parallel fixwrite at reconfig
uration
</td>
</tr>
<tr>
<td>
_rcfg_parallel_replay
</td>
<td>
TRUE
</td>
<td>
if TRUE enables parallel replay and cleanup a
t reconfiguration
</td>
</tr>
<tr>
<td>
_rcfg_parallel_verify
</td>
<td>
TRUE
</td>
<td>
if TRUE enables parallel verify at reconfigur
ation
</td>
</tr>
<tr>
<td>
_rdbms_compatibility
</td>
<td>
10.1
</td>
<td>
default RDBMS compatibility level
</td>
</tr>
<tr>
<td>
_rdbms_internal_fplib_enabled
</td>
<td>
FALSE
</td>
<td>
enable SAGE FPLIB filtering within rdbms
</td>
</tr>
<tr>
<td>
_rdbms_internal_fplib_raise_errors
</td>
<td>
FALSE
</td>
<td>
enable reraising of any exceptions in SAGE FP
LIB
</td>
</tr>
<tr>
<td>
_readable_standby_mode
</td>
<td>
SLFLUSH
</td>
<td>
readable standby mode
</td>
</tr>
<tr>
<td>
_readable_standby_sync_timeout
</td>
<td>
10
</td>
<td>
readable standby query scn sync timeout
</td>
</tr>
<tr>
<td>
_real_time_apply_sim
</td>
<td>
0
</td>
<td>
Simulation value with real time apply
</td>
</tr>
<tr>
<td>
_realfree_heap_max_size
</td>
<td>
32768
</td>
<td>
minimum max total heap size, in Kbytes
</td>
</tr>
<tr>
<td>
_realfree_heap_mode
</td>
<td>
0
</td>
<td>
mode flags for real-free heap
</td>
</tr>
<tr>
<td>
_realfree_heap_pagesize_hint
</td>
<td>
65536
</td>
<td>
hint for real-free page size in bytes
</td>
</tr>
<tr>
<td>
_recoverable_recovery_batch_percent
</td>
<td>
50
</td>
<td>
Recoverable recovery batch size (percentage o
f buffer cache)
</td>
</tr>
<tr>
<td>
_recovery_asserts
</td>
<td>
FALSE
</td>
<td>
if TRUE, enable expensive integrity checks
</td>
</tr>
<tr>
<td>
_recovery_percentage
</td>
<td>
50
</td>
<td>
recovery buffer cache percentage
</td>
</tr>
<tr>
<td>
_recovery_verify_writes
</td>
<td>
FALSE
</td>
<td>
enable thread recovery write verify
</td>
</tr>
<tr>
<td>
_recursive_imu_transactions
</td>
<td>
FALSE
</td>
<td>
recursive transactions may be IMU
</td>
</tr>
<tr>
<td>
_redo_compatibility_check
</td>
<td>
FALSE
</td>
<td>
general and redo/undo compatibility sanity ch
eck
</td>
</tr>
<tr>
<td>
_redo_read_from_memory
</td>
<td>
TRUE
</td>
<td>
Enable reading redo from memory
</td>
</tr>
<tr>
<td>
_redo_transport_compress_all
</td>
<td>
FALSE
</td>
<td>
Is ASYNC LNS compression allowed?
</td>
</tr>
<tr>
<td>
_release_insert_threshold
</td>
<td>
5
</td>
<td>
maximum number of unusable blocks to unlink f
rom freelist
</td>
</tr>
<tr>
<td>
_reliable_block_sends
</td>
<td>
FALSE
</td>
<td>
if TRUE, block sends across interconnect are
reliable
</td>
</tr>
<tr>
<td>
_remove_aggr_subquery
</td>
<td>
TRUE
</td>
<td>
enables removal of subsumed aggregated subque
ry
</td>
</tr>
<tr>
<td>
_replace_virtual_columns
</td>
<td>
TRUE
</td>
<td>
replace expressions with virtual columns
</td>
</tr>
<tr>
<td>
_resource_manager_always_off
</td>
<td>
FALSE
</td>
<td>
disable the resource manager always
</td>
</tr>
<tr>
<td>
_resource_manager_always_on
</td>
<td>
TRUE
</td>
<td>
enable the resource manager always
</td>
</tr>
<tr>
<td>
_restore_spfile
</td>
<td>
&nbsp;
</td>
<td>
restore spfile to this location
</td>
</tr>
<tr>
<td>
_result_cache_auto_execution_threshold
</td>
<td>
1
</td>
<td>
result cache auto execution threshold
</td>
</tr>
<tr>
<td>
_result_cache_auto_size_threshold
</td>
<td>
100
</td>
<td>
result cache auto max size allowed
</td>
</tr>
<tr>
<td>
_result_cache_auto_time_distance
</td>
<td>
300
</td>
<td>
result cache auto time distance
</td>
</tr>
<tr>
<td>
_result_cache_auto_time_threshold
</td>
<td>
1000
</td>
<td>
result cache auto time threshold
</td>
</tr>
<tr>
<td>
_result_cache_block_size
</td>
<td>
1024
</td>
<td>
result cache block size
</td>
</tr>
<tr>
<td>
_result_cache_timeout
</td>
<td>
60
</td>
<td>
maximum time (sec) a session waits for a resu
lt
</td>
</tr>
<tr>
<td>
_reuse_index_loop
</td>
<td>
5
</td>
<td>
number of blocks being examine for index bloc
k reuse
</td>
</tr>
<tr>
<td>
_right_outer_hash_enable
</td>
<td>
TRUE
</td>
<td>
Right Outer/Semi/Anti Hash Enabled
</td>
</tr>
<tr>
<td>
_rman_io_priority
</td>
<td>
3
</td>
<td>
priority at which rman backup i/o's are done
</td>
</tr>
<tr>
<td>
_rman_restore_through_link
</td>
<td>
FALSE
</td>
<td>
RMAN restore through link
</td>
</tr>
<tr>
<td>
_rollback_segment_count
</td>
<td>
0
</td>
<td>
number of undo segments
</td>
</tr>
<tr>
<td>
_rollback_segment_initial
</td>
<td>
1
</td>
<td>
starting undo segment number
</td>
</tr>
<tr>
<td>
_rollback_stopat
</td>
<td>
0
</td>
<td>
stop at -position to step rollback
</td>
</tr>
<tr>
<td>
_row_cache_cursors
</td>
<td>
20
</td>
<td>
number of cached cursors for row cache manage
ment
</td>
</tr>
<tr>
<td>
_row_cr
</td>
<td>
TRUE
</td>
<td>
enable row cr for all sql
</td>
</tr>
<tr>
<td>
_row_locking
</td>
<td>
always
</td>
<td>
row-locking
</td>
</tr>
<tr>
<td>
_row_shipping_explain
</td>
<td>
FALSE
</td>
<td>
enable row shipping explain plan support
</td>
</tr>
<tr>
<td>
_row_shipping_threshold
</td>
<td>
80
</td>
<td>
row shipping column selection threshold
</td>
</tr>
<tr>
<td>
_rowsource_execution_statistics
</td>
<td>
FALSE
</td>
<td>
if TRUE, Oracle will collect rowsource statis
tics
</td>
</tr>
<tr>
<td>
_rowsource_profiling_statistics
</td>
<td>
TRUE
</td>
<td>
if TRUE, Oracle will capture active row sourc
es in v$active_session_history
</td>
</tr>
<tr>
<td>
_rowsource_statistics_sampfreq
</td>
<td>
128
</td>
<td>
frequency of rowsource statistic sampling (mu
st be a power of 2)
</td>
</tr>
<tr>
<td>
_rowsrc_trace_level
</td>
<td>
0
</td>
<td>
Row source tree tracing level
</td>
</tr>
<tr>
<td>
_rtc_infeasible_threshold
</td>
<td>
10
</td>
<td>
Redo Transport Compression infeasible thresho
ld
</td>
</tr>
<tr>
<td>
_sage_enabled
</td>
<td>
1
</td>
<td>
enable real SAGE functionality
</td>
</tr>
<tr>
<td>
_sage_fcre
</td>
<td>
TRUE
</td>
<td>
Allow optimized file creation path for SAGE
</td>
</tr>
<tr>
<td>
_sample_rows_per_block
</td>
<td>
4
</td>
<td>
number of rows per block used for sampling IO
 optimization
</td>
</tr>
<tr>
<td>
_scatter_gcs_resources
</td>
<td>
FALSE
</td>
<td>
if TRUE, gcs resources are scattered uniforml
y across sub pools
</td>
</tr>
<tr>
<td>
_scatter_gcs_shadows
</td>
<td>
FALSE
</td>
<td>
if TRUE, gcs shadows are scattered uniformly
across sub pools
</td>
</tr>
<tr>
<td>
_scn_wait_interface_max_backoff_time_secs
</td>
<td>
600
</td>
<td>
max exponential backoff time for scn wait int
erface in kta
</td>
</tr>
<tr>
<td>
_scn_wait_interface_max_timeout_secs
</td>
<td>
2147483647
</td>
<td>
max timeout for scn wait interface in kta
</td>
</tr>
<tr>
<td>
_sdiag_crash
</td>
<td>
NONE
</td>
<td>
sql diag crash
</td>
</tr>
<tr>
<td>
_sec_enable_test_rpcs
</td>
<td>
FALSE
</td>
<td>
Whether to enable the test RPCs
</td>
</tr>
<tr>
<td>
_second_spare_parameter
</td>
<td>
&nbsp;
</td>
<td>
second spare parameter - integer
</td>
</tr>
<tr>
<td>
_securefile_timers
</td>
<td>
FALSE
</td>
<td>
collect kdlu timers and accumulate per layers
</td>
</tr>
<tr>
<td>
_selectivity_for_srf_enabled
</td>
<td>
FALSE
</td>
<td>
enable/disable selectivity for storage reduct
ion factor
</td>
</tr>
<tr>
<td>
_selfjoin_mv_duplicates
</td>
<td>
TRUE
</td>
<td>
control rewrite self-join algorithm
</td>
</tr>
<tr>
<td>
_selftune_checkpoint_write_pct
</td>
<td>
3
</td>
<td>
Percentage of total physical i/os for self-tu
ne ckpt
</td>
</tr>
<tr>
<td>
_selftune_checkpointing_lag
</td>
<td>
300
</td>
<td>
Self-tune checkpointing lag the tail of the r
edo log
</td>
</tr>
<tr>
<td>
_send_ast_to_foreground
</td>
<td>
TRUE
</td>
<td>
if TRUE, send ast message to foreground
</td>
</tr>
<tr>
<td>
_send_close_with_block
</td>
<td>
TRUE
</td>
<td>
if TRUE, send close with block even with dire
ct sends
</td>
</tr>
<tr>
<td>
_send_requests_to_pi
</td>
<td>
TRUE
</td>
<td>
if TRUE, try to send CR requests to PI buffer
s
</td>
</tr>
<tr>
<td>
_serial_direct_read
</td>
<td>
FALSE
</td>
<td>
enable direct read in serial
</td>
</tr>
<tr>
<td>
_serial_recovery
</td>
<td>
FALSE
</td>
<td>
force serial recovery or parallel recovery
</td>
</tr>
<tr>
<td>
_serializable
</td>
<td>
FALSE
</td>
<td>
serializable
</td>
</tr>
<tr>
<td>
_session_cached_instantiations
</td>
<td>
60
</td>
<td>
Number of pl/sql instantiations to cache in a
 session.
</td>
</tr>
<tr>
<td>
_session_context_size
</td>
<td>
10000
</td>
<td>
session app context size
</td>
</tr>
<tr>
<td>
_session_idle_bit_latches
</td>
<td>
0
</td>
<td>
one latch per session or a latch per group of
 sessions
</td>
</tr>
<tr>
<td>
_session_idle_check_interval
</td>
<td>
60
</td>
<td>
Resource Manager session idle limit check int
erval in seconds
</td>
</tr>
<tr>
<td>
_session_kept_cursor_pins
</td>
<td>
0
</td>
<td>
Number of cursors pins to keep in a session
</td>
</tr>
<tr>
<td>
_session_wait_history
</td>
<td>
10
</td>
<td>
enable session wait history collection
</td>
</tr>
<tr>
<td>
_seventh_spare_parameter
</td>
<td>
&nbsp;
</td>
<td>
seventh spare parameter - string list
</td>
</tr>
<tr>
<td>
_sga_clear_dump
</td>
<td>
FALSE
</td>
<td>
Allow dumping encrypted blocks in clear for d
ebugging
</td>
</tr>
<tr>
<td>
_sga_early_trace
</td>
<td>
0
</td>
<td>
sga early trace event
</td>
</tr>
<tr>
<td>
_sga_locking
</td>
<td>
none
</td>
<td>
sga granule locking state
</td>
</tr>
<tr>
<td>
_shared_io_pool_buf_size
</td>
<td>
1048576
</td>
<td>
Shared IO pool buffer size
</td>
</tr>
<tr>
<td>
_shared_io_pool_debug_trc
</td>
<td>
0
</td>
<td>
trace kcbi debug info to tracefile
</td>
</tr>
<tr>
<td>
_shared_io_pool_size
</td>
<td>
0
</td>
<td>
Size of shared IO pool
</td>
</tr>
<tr>
<td>
_shared_io_set_value
</td>
<td>
FALSE
</td>
<td>
shared io pool size set internal value - over
write zero user size
</td>
</tr>
<tr>
<td>
_shared_iop_max_size
</td>
<td>
536870912
</td>
<td>
maximum shared io pool size
</td>
</tr>
<tr>
<td>
_shared_pool_max_size
</td>
<td>
0
</td>
<td>
shared pool maximum size when auto SGA enable
d
</td>
</tr>
<tr>
<td>
_shared_pool_minsize_on
</td>
<td>
FALSE
</td>
<td>
shared pool minimum size when auto SGA enable
d
</td>
</tr>
<tr>
<td>
_shared_pool_reserved_min_alloc
</td>
<td>
4400
</td>
<td>
minimum allocation size in bytes for reserved
 area of shared pool
</td>
</tr>
<tr>
<td>
_shared_pool_reserved_pct
</td>
<td>
5
</td>
<td>
percentage memory of the shared pool allocate
d for the reserved area
</td>
</tr>
<tr>
<td>
_shared_server_load_balance
</td>
<td>
0
</td>
<td>
shared server load balance
</td>
</tr>
<tr>
<td>
_shared_server_num_queues
</td>
<td>
2
</td>
<td>
number of shared server common queues
</td>
</tr>
<tr>
<td>
_short_stack_timeout_ms
</td>
<td>
30000
</td>
<td>
short stack timeout in ms
</td>
</tr>
<tr>
<td>
_shrunk_aggs_disable_threshold
</td>
<td>
60
</td>
<td>
percentage of exceptions at which to switch t
o full length aggs
</td>
</tr>
<tr>
<td>
_shrunk_aggs_enabled
</td>
<td>
TRUE
</td>
<td>
enable use of variable sized buffers for non-
distinct aggregates
</td>
</tr>
<tr>
<td>
_side_channel_batch_size
</td>
<td>
200
</td>
<td>
number of messages to batch in a side channel
 message (DFS)
</td>
</tr>
<tr>
<td>
_side_channel_batch_timeout
</td>
<td>
6
</td>
<td>
timeout before shipping out the batched side
channelmessages in seconds
</td>
</tr>
<tr>
<td>
_side_channel_batch_timeout_ms
</td>
<td>
500
</td>
<td>
timeout before shipping out the batched side
channelmessages in milliseconds
</td>
</tr>
<tr>
<td>
_simple_view_merging
</td>
<td>
TRUE
</td>
<td>
control simple view merging performed by the
optimizer
</td>
</tr>
<tr>
<td>
_simulate_mem_transfer
</td>
<td>
FALSE
</td>
<td>
simulate auto memory sga/pga transfers
</td>
</tr>
<tr>
<td>
_simulator_bucket_mindelta
</td>
<td>
8192
</td>
<td>
LRU bucket minimum delta
</td>
</tr>
<tr>
<td>
_simulator_internal_bound
</td>
<td>
10
</td>
<td>
simulator internal bound percent
</td>
</tr>
<tr>
<td>
_simulator_lru_rebalance_sizthr
</td>
<td>
5
</td>
<td>
LRU list rebalance threshold (size)
</td>
</tr>
<tr>
<td>
_simulator_lru_rebalance_thresh
</td>
<td>
10240
</td>
<td>
LRU list rebalance threshold (count)
</td>
</tr>
<tr>
<td>
_simulator_lru_scan_count
</td>
<td>
8
</td>
<td>
LRU scan count
</td>
</tr>
<tr>
<td>
_simulator_pin_inval_maxcnt
</td>
<td>
16
</td>
<td>
maximum count of invalid chunks on pin list
</td>
</tr>
<tr>
<td>
_simulator_reserved_heap_count
</td>
<td>
4096
</td>
<td>
simulator reserved heap count
</td>
</tr>
<tr>
<td>
_simulator_reserved_obj_count
</td>
<td>
1024
</td>
<td>
simulator reserved object count
</td>
</tr>
<tr>
<td>
_simulator_sampling_factor
</td>
<td>
2
</td>
<td>
sampling factor for the simulator
</td>
</tr>
<tr>
<td>
_simulator_upper_bound_multiple
</td>
<td>
2
</td>
<td>
upper bound multiple of pool size
</td>
</tr>
<tr>
<td>
_single_process
</td>
<td>
FALSE
</td>
<td>
run without detached processes
</td>
</tr>
<tr>
<td>
_siop_flashback_scandepth
</td>
<td>
20
</td>
<td>
Shared IO pool flashback io completion scan d
epth
</td>
</tr>
<tr>
<td>
_sixth_spare_parameter
</td>
<td>
&nbsp;
</td>
<td>
sixth spare parameter - string list
</td>
</tr>
<tr>
<td>
_skgxp_reaping
</td>
<td>
1000
</td>
<td>
tune skgxp OSD reaping limit
</td>
</tr>
<tr>
<td>
_skgxp_udp_ach_reaping_time
</td>
<td>
120
</td>
<td>
time in minutes before idle ach's are reaped
</td>
</tr>
<tr>
<td>
_skgxp_udp_ack_delay
</td>
<td>
0
</td>
<td>
Enables delayed acks
</td>
</tr>
<tr>
<td>
_skgxp_udp_enable_dynamic_credit_mgmt
</td>
<td>
0
</td>
<td>
Enables dynamic credit management
</td>
</tr>
<tr>
<td>
_skgxp_udp_hiwat_warn
</td>
<td>
1000
</td>
<td>
ach hiwat mark warning interval
</td>
</tr>
<tr>
<td>
_skgxp_udp_interface_detection_time_secs
</td>
<td>
60
</td>
<td>
time in seconds between interface detection c
hecks
</td>
</tr>
<tr>
<td>
_skgxp_udp_keep_alive_ping_timer_secs
</td>
<td>
300
</td>
<td>
connection idle time in seconds before keep a
live is initiated. min: 30 sec max: 1800 sec
default: 300 sec
</td>
</tr>
<tr>
<td>
_skgxp_udp_lmp_mtusize
</td>
<td>
0
</td>
<td>
MTU size for UDP LMP testing
</td>
</tr>
<tr>
<td>
_skgxp_udp_lmp_on
</td>
<td>
FALSE
</td>
<td>
enable UDP long message protection
</td>
</tr>
<tr>
<td>
_skgxp_udp_timed_wait_buffering
</td>
<td>
1024
</td>
<td>
diagnostic log buffering space (in bytes) for
 timed wait (0 means unbufferd
</td>
</tr>
<tr>
<td>
_skgxp_udp_timed_wait_seconds
</td>
<td>
5
</td>
<td>
time in seconds before timed wait is invoked
</td>
</tr>
<tr>
<td>
_skgxp_udp_use_tcb
</td>
<td>
TRUE
</td>
<td>
disable use of high speek timer
</td>
</tr>
<tr>
<td>
_skip_assume_msg
</td>
<td>
TRUE
</td>
<td>
if TRUE, skip assume message for consigns at
the master
</td>
</tr>
<tr>
<td>
_slave_mapping_enabled
</td>
<td>
TRUE
</td>
<td>
enable slave mapping when TRUE
</td>
</tr>
<tr>
<td>
_slave_mapping_group_size
</td>
<td>
0
</td>
<td>
force the number of slave group in a slave ma
pper
</td>
</tr>
<tr>
<td>
_small_table_threshold
</td>
<td>
149
</td>
<td>
threshold level of table size for direct read
s
</td>
</tr>
<tr>
<td>
_smm_advice_enabled
</td>
<td>
TRUE
</td>
<td>
if TRUE, enable v$pga_advice
</td>
</tr>
<tr>
<td>
_smm_advice_log_size
</td>
<td>
0
</td>
<td>
overwrites default size of the PGA advice wor
karea history log
</td>
</tr>
<tr>
<td>
_smm_auto_cost_enabled
</td>
<td>
TRUE
</td>
<td>
if TRUE, use the AUTO size policy cost functi
ons
</td>
</tr>
<tr>
<td>
_smm_auto_max_io_size
</td>
<td>
248
</td>
<td>
Maximum IO size (in KB) used by sort/hash-joi
n in auto mode
</td>
</tr>
<tr>
<td>
_smm_auto_min_io_size
</td>
<td>
56
</td>
<td>
Minimum IO size (in KB) used by sort/hash-joi
n in auto mode
</td>
</tr>
<tr>
<td>
_smm_bound
</td>
<td>
0
</td>
<td>
overwrites memory manager automatically compu
ted bound
</td>
</tr>
<tr>
<td>
_smm_control
</td>
<td>
0
</td>
<td>
provides controls on the memory manager
</td>
</tr>
<tr>
<td>
_smm_freeable_retain
</td>
<td>
5120
</td>
<td>
value in KB of the instance freeable PGA memo
ry to retain
</td>
</tr>
<tr>
<td>
_smm_isort_cap
</td>
<td>
102400
</td>
<td>
maximum work area for insertion sort(v1)
</td>
</tr>
<tr>
<td>
_smm_max_size
</td>
<td>
104850
</td>
<td>
maximum work area size in auto mode (serial)
</td>
</tr>
<tr>
<td>
_smm_min_size
</td>
<td>
1024
</td>
<td>
minimum work area size in auto mode
</td>
</tr>
<tr>
<td>
_smm_px_max_size
</td>
<td>
524288
</td>
<td>
maximum work area size in auto mode (global)
</td>
</tr>
<tr>
<td>
_smm_retain_size
</td>
<td>
0
</td>
<td>
work area retain size in SGA for shared serve
r sessions (0 for AUTO)
</td>
</tr>
<tr>
<td>
_smm_trace
</td>
<td>
0
</td>
<td>
Turn on/off tracing for SQL memory manager
</td>
</tr>
<tr>
<td>
_smon_internal_errlimit
</td>
<td>
100
</td>
<td>
limit of SMON internal errors
</td>
</tr>
<tr>
<td>
_smon_undo_seg_rescan_limit
</td>
<td>
10
</td>
<td>
limit of SMON continous undo segments re-scan
</td>
</tr>
<tr>
<td>
_smu_debug_mode
</td>
<td>
0
</td>
<td>
&lt;debug-flag&gt; - set debug event for testing SM
U operations
</td>
</tr>
<tr>
<td>
_smu_error_simulation_site
</td>
<td>
0
</td>
<td>
site ID of error simulation in KTU code
</td>
</tr>
<tr>
<td>
_smu_error_simulation_type
</td>
<td>
0
</td>
<td>
error type for error simulation in KTU code
</td>
</tr>
<tr>
<td>
_smu_timeouts
</td>
<td>
&nbsp;
</td>
<td>
comma-separated *AND double-quoted* list of A
UM timeouts: mql, tur, sess_exprn, qry_exprn,
 slot_intvl
</td>
</tr>
<tr>
<td>
_sort_elimination_cost_ratio
</td>
<td>
0
</td>
<td>
cost ratio for sort eimination under first_ro
ws mode
</td>
</tr>
<tr>
<td>
_sort_multiblock_read_count
</td>
<td>
2
</td>
<td>
multi-block read count for sort
</td>
</tr>
<tr>
<td>
_space_align_size
</td>
<td>
1048576
</td>
<td>
space align size
</td>
</tr>
<tr>
<td>
_spin_count
</td>
<td>
2000
</td>
<td>
Amount to spin waiting for a latch
</td>
</tr>
<tr>
<td>
_spr_max_rules
</td>
<td>
10000
</td>
<td>
maximum number of rules in sql spreadsheet
</td>
</tr>
<tr>
<td>
_spr_push_pred_refspr
</td>
<td>
TRUE
</td>
<td>
push predicates through reference spreadsheet
</td>
</tr>
<tr>
<td>
_spr_use_AW_AS
</td>
<td>
TRUE
</td>
<td>
enable AW for hash table in spreadsheet
</td>
</tr>
<tr>
<td>
_spr_use_hash_table
</td>
<td>
FALSE
</td>
<td>
use hash table for spreadsheet
</td>
</tr>
<tr>
<td>
_sql_analyze_parse_model
</td>
<td>
2
</td>
<td>
SQL Analyze Parse Model control parameter
</td>
</tr>
<tr>
<td>
_sql_connect_capability_override
</td>
<td>
0
</td>
<td>
SQL Connect Capability Table Override
</td>
</tr>
<tr>
<td>
_sql_connect_capability_table
</td>
<td>
&nbsp;
</td>
<td>
SQL Connect Capability Table (testing only)
</td>
</tr>
<tr>
<td>
_sql_hash_debug
</td>
<td>
0
</td>
<td>
Hash value of the SQL statement to debug
</td>
</tr>
<tr>
<td>
_sql_model_unfold_forloops
</td>
<td>
RUN_TIME
</td>
<td>
specifies compile-time unfolding of sql model
 forloops
</td>
</tr>
<tr>
<td>
_sql_plan_baseline_capture_on_1_exec
</td>
<td>
FALSE
</td>
<td>
With auto-capture on, create new SQL plan bas
eline on first exec
</td>
</tr>
<tr>
<td>
_sqlexec_progression_cost
</td>
<td>
1000
</td>
<td>
sql execution progression monitoring cost thr
eshold
</td>
</tr>
<tr>
<td>
_sqlmon_max_plan
</td>
<td>
40
</td>
<td>
Maximum number of plans entry that can be mon
itored. Defaults to 20 per CPU
</td>
</tr>
<tr>
<td>
_sqlmon_max_planlines
</td>
<td>
300
</td>
<td>
Number of plan lines beyond which a plan cann
ot be monitored
</td>
</tr>
<tr>
<td>
_sqlmon_threshold
</td>
<td>
5
</td>
<td>
CPU/IO time threshold before a statement is m
onitored. 0 is disabled
</td>
</tr>
<tr>
<td>
_sqltune_category_parsed
</td>
<td>
DEFAULT
</td>
<td>
Parsed category qualifier for applying hintse
ts
</td>
</tr>
<tr>
<td>
_srvntfn_job_deq_timeout
</td>
<td>
60
</td>
<td>
srvntfn job deq timeout
</td>
</tr>
<tr>
<td>
_srvntfn_jobsubmit_interval
</td>
<td>
3
</td>
<td>
srvntfn job submit interval
</td>
</tr>
<tr>
<td>
_srvntfn_max_concurrent_jobs
</td>
<td>
20
</td>
<td>
srvntfn max concurrent jobs
</td>
</tr>
<tr>
<td>
_srvntfn_q_msgcount
</td>
<td>
50
</td>
<td>
srvntfn q msg count for job exit
</td>
</tr>
<tr>
<td>
_srvntfn_q_msgcount_inc
</td>
<td>
100
</td>
<td>
srvntfn q msg count increase for job submit
</td>
</tr>
<tr>
<td>
_sscr_dir
</td>
<td>
&nbsp;
</td>
<td>
Session State Capture and Restore DIRectory o
bject
</td>
</tr>
<tr>
<td>
_sscr_osdir
</td>
<td>
&nbsp;
</td>
<td>
Session State Capture and Restore OS DIRector
y
</td>
</tr>
<tr>
<td>
_sta_control
</td>
<td>
0
</td>
<td>
SQL Tuning Advisory control parameter
</td>
</tr>
<tr>
<td>
_stack_guard_level
</td>
<td>
0
</td>
<td>
stack guard level
</td>
</tr>
<tr>
<td>
_static_backgrounds
</td>
<td>
&nbsp;
</td>
<td>
static backgrounds
</td>
</tr>
<tr>
<td>
_statistics_based_srf_enabled
</td>
<td>
TRUE
</td>
<td>
enable/disable the use of statistics for stor
age reduction factor
</td>
</tr>
<tr>
<td>
_step_down_limit_in_pct
</td>
<td>
1
</td>
<td>
step down limit in percentage
</td>
</tr>
<tr>
<td>
_stn_trace
</td>
<td>
0
</td>
<td>
SQL tracing parameter
</td>
</tr>
<tr>
<td>
_storage_predicate_access_predicate
</td>
<td>
0
</td>
<td>
put storage predicate into access predicate i
n explain plan
</td>
</tr>
<tr>
<td>
_streams_pool_max_size
</td>
<td>
0
</td>
<td>
streams pool maximum size when auto SGA enabl
ed
</td>
</tr>
<tr>
<td>
_subquery_pruning_cost_factor
</td>
<td>
20
</td>
<td>
subquery pruning cost factor
</td>
</tr>
<tr>
<td>
_subquery_pruning_enabled
</td>
<td>
TRUE
</td>
<td>
enable the use of subquery predicates to perf
orm pruning
</td>
</tr>
<tr>
<td>
_subquery_pruning_mv_enabled
</td>
<td>
FALSE
</td>
<td>
enable the use of subquery predicates with MV
s to perform pruning
</td>
</tr>
<tr>
<td>
_subquery_pruning_reduction
</td>
<td>
50
</td>
<td>
subquery pruning reduction factor
</td>
</tr>
<tr>
<td>
_swrf_metric_frequent_mode
</td>
<td>
FALSE
</td>
<td>
Enable/disable SWRF Metric Frequent Mode Coll
ection
</td>
</tr>
<tr>
<td>
_swrf_mmon_dbfus
</td>
<td>
TRUE
</td>
<td>
Enable/disable SWRF MMON DB Feature Usage
</td>
</tr>
<tr>
<td>
_swrf_mmon_flush
</td>
<td>
TRUE
</td>
<td>
Enable/disable SWRF MMON FLushing
</td>
</tr>
<tr>
<td>
_swrf_mmon_metrics
</td>
<td>
TRUE
</td>
<td>
Enable/disable SWRF MMON Metrics Collection
</td>
</tr>
<tr>
<td>
_swrf_on_disk_enabled
</td>
<td>
TRUE
</td>
<td>
Parameter to enable/disable SWRF
</td>
</tr>
<tr>
<td>
_swrf_test_action
</td>
<td>
0
</td>
<td>
test action parameter for SWRF
</td>
</tr>
<tr>
<td>
_swrf_test_dbfus
</td>
<td>
FALSE
</td>
<td>
Enable/disable DB Feature Usage Testing
</td>
</tr>
<tr>
<td>
_synonym_repoint_tracing
</td>
<td>
FALSE
</td>
<td>
whether to trace metadata comparisons for syn
onym repointing
</td>
</tr>
<tr>
<td>
_sysaux_test_param
</td>
<td>
1
</td>
<td>
test parameter for SYSAUX
</td>
</tr>
<tr>
<td>
_system_index_caching
</td>
<td>
0
</td>
<td>
optimizer percent system index caching
</td>
</tr>
<tr>
<td>
_system_trig_enabled
</td>
<td>
TRUE
</td>
<td>
are system triggers enabled
</td>
</tr>
<tr>
<td>
_ta_lns_wait_for_arch_log
</td>
<td>
20
</td>
<td>
LNS Wait time for arhcived version of online
log
</td>
</tr>
<tr>
<td>
_table_lookup_prefetch_size
</td>
<td>
40
</td>
<td>
table lookup prefetch vector size
</td>
</tr>
<tr>
<td>
_table_lookup_prefetch_thresh
</td>
<td>
2
</td>
<td>
table lookup prefetch threshold
</td>
</tr>
<tr>
<td>
_table_scan_cost_plus_one
</td>
<td>
TRUE
</td>
<td>
bump estimated full table scan and index ffs
cost by one
</td>
</tr>
<tr>
<td>
_target_rba_max_lag_percentage
</td>
<td>
90
</td>
<td>
target rba max log lag percentage
</td>
</tr>
<tr>
<td>
_tdb_debug_mode
</td>
<td>
16
</td>
<td>
set debug mode for testing transportable data
base
</td>
</tr>
<tr>
<td>
_temp_tran_block_threshold
</td>
<td>
100
</td>
<td>
number of blocks for a dimension before we te
mp transform
</td>
</tr>
<tr>
<td>
_temp_tran_cache
</td>
<td>
TRUE
</td>
<td>
determines if temp table is created with cach
e option
</td>
</tr>
<tr>
<td>
_test_ksusigskip
</td>
<td>
5
</td>
<td>
test the function ksusigskip
</td>
</tr>
<tr>
<td>
_test_param_1
</td>
<td>
25
</td>
<td>
test parmeter 1 - integer
</td>
</tr>
<tr>
<td>
_test_param_2
</td>
<td>
&nbsp;
</td>
<td>
test parameter 2 - string
</td>
</tr>
<tr>
<td>
_test_param_3
</td>
<td>
&nbsp;
</td>
<td>
test parameter 3 - string
</td>
</tr>
<tr>
<td>
_test_param_4
</td>
<td>
&nbsp;
</td>
<td>
test parameter 4 - string list
</td>
</tr>
<tr>
<td>
_test_param_5
</td>
<td>
25
</td>
<td>
test parmeter 5 - deprecated integer
</td>
</tr>
<tr>
<td>
_test_param_6
</td>
<td>
0
</td>
<td>
test parmeter 6 - size (ub8)
</td>
</tr>
<tr>
<td>
_test_spacebg
</td>
<td>
0
</td>
<td>
test space management background task
</td>
</tr>
<tr>
<td>
_third_spare_parameter
</td>
<td>
&nbsp;
</td>
<td>
third spare parameter - integer
</td>
</tr>
<tr>
<td>
_threshold_alerts_enable
</td>
<td>
1
</td>
<td>
if 1, issue threshold-based alerts
</td>
</tr>
<tr>
<td>
_timemodel_collection
</td>
<td>
TRUE
</td>
<td>
enable timemodel collection
</td>
</tr>
<tr>
<td>
_timeout_actions_enabled
</td>
<td>
TRUE
</td>
<td>
enables or disables KSU timeout actions
</td>
</tr>
<tr>
<td>
_timer_precision
</td>
<td>
20
</td>
<td>
VKTM sleep time in milli-sec
</td>
</tr>
<tr>
<td>
_total_large_extent_memory
</td>
<td>
0
</td>
<td>
Total memory for allocating large extents
</td>
</tr>
<tr>
<td>
_tq_dump_period
</td>
<td>
0
</td>
<td>
time period for duping of TQ statistics (s)
</td>
</tr>
<tr>
<td>
_trace_buffer_wait_timeouts
</td>
<td>
0
</td>
<td>
trace buffer busy wait timeouts
</td>
</tr>
<tr>
<td>
_trace_buffers
</td>
<td>
ALL:256
</td>
<td>
trace buffer sizes per process
</td>
</tr>
<tr>
<td>
_trace_dump_all_procs
</td>
<td>
FALSE
</td>
<td>
if TRUE on error buckets of all processes wil
l be dumped to the current trace file
</td>
</tr>
<tr>
<td>
_trace_dump_client_buckets
</td>
<td>
TRUE
</td>
<td>
if TRUE dump client (ie. non-kst) buckets
</td>
</tr>
<tr>
<td>
_trace_dump_cur_proc_only
</td>
<td>
FALSE
</td>
<td>
if TRUE on error just dump our process bucket
</td>
</tr>
<tr>
<td>
_trace_dump_static_only
</td>
<td>
FALSE
</td>
<td>
if TRUE filter trace dumps to always loaded d
lls
</td>
</tr>
<tr>
<td>
_trace_events
</td>
<td>
&nbsp;
</td>
<td>
trace events enabled at startup
</td>
</tr>
<tr>
<td>
_trace_files_public
</td>
<td>
FALSE
</td>
<td>
Create publicly accessible trace files
</td>
</tr>
<tr>
<td>
_trace_kqlidp
</td>
<td>
FALSE
</td>
<td>
trace kqlidp0 operation
</td>
</tr>
<tr>
<td>
_trace_navigation_scope
</td>
<td>
global
</td>
<td>
enabling trace navigation linking
</td>
</tr>
<tr>
<td>
_trace_pin_time
</td>
<td>
0
</td>
<td>
trace how long a current pin is held
</td>
</tr>
<tr>
<td>
_trace_pool_size
</td>
<td>
&nbsp;
</td>
<td>
trace pool size in bytes
</td>
</tr>
<tr>
<td>
_trace_processes
</td>
<td>
ALL
</td>
<td>
enable KST tracing in process
</td>
</tr>
<tr>
<td>
_trace_virtual_columns
</td>
<td>
FALSE
</td>
<td>
trace virtual columns exprs
</td>
</tr>
<tr>
<td>
_transaction_auditing
</td>
<td>
TRUE
</td>
<td>
transaction auditing records generated in the
 redo log
</td>
</tr>
<tr>
<td>
_transaction_recovery_servers
</td>
<td>
0
</td>
<td>
max number of parallel recovery slaves that m
ay be used
</td>
</tr>
<tr>
<td>
_truncate_optimization_enabled
</td>
<td>
TRUE
</td>
<td>
do truncate optimization if set to TRUE
</td>
</tr>
<tr>
<td>
_tsenc_tracing
</td>
<td>
0
</td>
<td>
Enable TS encryption tracing
</td>
</tr>
<tr>
<td>
_tsm_connect_string
</td>
<td>
&nbsp;
</td>
<td>
TSM test connect string
</td>
</tr>
<tr>
<td>
_tsm_disable_auto_cleanup
</td>
<td>
1
</td>
<td>
Disable TSM auto cleanup actions
</td>
</tr>
<tr>
<td>
_tts_allow_charset_mismatch
</td>
<td>
FALSE
</td>
<td>
allow plugging in a tablespace with an incomp
atible character set
</td>
</tr>
<tr>
<td>
_two_pass
</td>
<td>
TRUE
</td>
<td>
enable two-pass thread recovery
</td>
</tr>
<tr>
<td>
_two_pass_reverse_polish_enabled
</td>
<td>
TRUE
</td>
<td>
uses two-pass reverse polish alg. to generate
 canonical forms
</td>
</tr>
<tr>
<td>
_uga_cga_large_extent_size
</td>
<td>
262144
</td>
<td>
UGA/CGA large extent size
</td>
</tr>
<tr>
<td>
_ultrafast_latch_statistics
</td>
<td>
TRUE
</td>
<td>
maintain fast-path statistics for ultrafast l
atches
</td>
</tr>
<tr>
<td>
_undo_autotune
</td>
<td>
TRUE
</td>
<td>
enable auto tuning of undo_retention
</td>
</tr>
<tr>
<td>
_undo_block_compression
</td>
<td>
TRUE
</td>
<td>
enable undo block compression
</td>
</tr>
<tr>
<td>
_undo_debug_mode
</td>
<td>
0
</td>
<td>
debug flag for undo related operations
</td>
</tr>
<tr>
<td>
_undo_debug_usage
</td>
<td>
0
</td>
<td>
invoke undo usage functions for testing
</td>
</tr>
<tr>
<td>
_union_rewrite_for_gs
</td>
<td>
YES_GSET_MVS
</td>
<td>
expand queries with GSets into UNIONs for rew
rite
</td>
</tr>
<tr>
<td>
_unnest_subquery
</td>
<td>
TRUE
</td>
<td>
enables unnesting of correlated subqueries
</td>
</tr>
<tr>
<td>
_unused_block_compression
</td>
<td>
TRUE
</td>
<td>
enable unused block compression
</td>
</tr>
<tr>
<td>
_update_datafile_headers_with_space_informati
on
</td>
<td>
FALSE
</td>
<td>
user requested update of datafile headers of
locally managed datafiles with space informat
ion
</td>
</tr>
<tr>
<td>
_use_best_fit
</td>
<td>
FALSE
</td>
<td>
use best fit to allocate space
</td>
</tr>
<tr>
<td>
_use_column_stats_for_function
</td>
<td>
TRUE
</td>
<td>
enable the use of column statistics for DDP f
unctions
</td>
</tr>
<tr>
<td>
_use_ism
</td>
<td>
TRUE
</td>
<td>
Enable Shared Page Tables - ISM
</td>
</tr>
<tr>
<td>
_use_ism_for_pga
</td>
<td>
TRUE
</td>
<td>
Use ISM for allocating large extents
</td>
</tr>
<tr>
<td>
_use_nosegment_indexes
</td>
<td>
FALSE
</td>
<td>
use nosegment indexes in explain plan
</td>
</tr>
<tr>
<td>
_use_realfree_heap
</td>
<td>
TRUE
</td>
<td>
use real-free based allocator for PGA memory
</td>
</tr>
<tr>
<td>
_use_seq_process_cache
</td>
<td>
TRUE
</td>
<td>
whether to use process local seq cache
</td>
</tr>
<tr>
<td>
_use_vector_post
</td>
<td>
TRUE
</td>
<td>
use vector post
</td>
</tr>
<tr>
<td>
_use_zero_copy_io
</td>
<td>
TRUE
</td>
<td>
Should network vector IO interface be used fo
r data transfer
</td>
</tr>
<tr>
<td>
_validate_flashback_database
</td>
<td>
FALSE
</td>
<td>
Scan database to validate result of flashback
 database
</td>
</tr>
<tr>
<td>
_vendor_lib_loc
</td>
<td>
&nbsp;
</td>
<td>
Vendor library search root directory
</td>
</tr>
<tr>
<td>
_verify_flashback_redo
</td>
<td>
TRUE
</td>
<td>
Verify that the redo logs needed for flashbac
k are available
</td>
</tr>
<tr>
<td>
_verify_undo_quota
</td>
<td>
FALSE
</td>
<td>
TRUE - verify consistency of undo quota stati
stics
</td>
</tr>
<tr>
<td>
_very_large_partitioned_table
</td>
<td>
1024
</td>
<td>
very_large_partitioned_table
</td>
</tr>
<tr>
<td>
_virtual_column_overload_allowed
</td>
<td>
TRUE
</td>
<td>
overload virtual columns expression
</td>
</tr>
<tr>
<td>
_wait_breakup_threshold_csecs
</td>
<td>
600
</td>
<td>
Wait breakup threshold (in centiseconds)
</td>
</tr>
<tr>
<td>
_wait_breakup_time_csecs
</td>
<td>
300
</td>
<td>
Wait breakup time (in centiseconds)
</td>
</tr>
<tr>
<td>
_wait_for_sync
</td>
<td>
TRUE
</td>
<td>
wait for sync on commit MUST BE ALWAYS TRUE
</td>
</tr>
<tr>
<td>
_walk_insert_threshold
</td>
<td>
0
</td>
<td>
maximum number of unusable blocks to walk acr
oss freelist
</td>
</tr>
<tr>
<td>
_watchpoint_on
</td>
<td>
FALSE
</td>
<td>
is the watchpointing feature turned on?
</td>
</tr>
<tr>
<td>
_wcr_control
</td>
<td>
0
</td>
<td>
Oracle internal test WCR parameter used ONLY
for testing!
</td>
</tr>
<tr>
<td>
_windowfunc_optimization_settings
</td>
<td>
0
</td>
<td>
settings for window function optimizations
</td>
</tr>
<tr>
<td>
_with_subquery
</td>
<td>
OPTIMIZER
</td>
<td>
WITH subquery transformation
</td>
</tr>
<tr>
<td>
_write_clones
</td>
<td>
3
</td>
<td>
write clones flag
</td>
</tr>
<tr>
<td>
_xpl_peeked_binds_log_size
</td>
<td>
8192
</td>
<td>
maximum bytes for logging peeked bind values
for V$SQL_PLAN (0 = OFF)
</td>
</tr>
<tr>
<td>
_xpl_trace
</td>
<td>
0
</td>
<td>
Explain Plan tracing parameter
</td>
</tr>
<tr>
<td>
_xsolapi_auto_materialization_bound
</td>
<td>
20
</td>
<td>
OLAP API lower bound for auto materialization
.
</td>
</tr>
<tr>
<td>
_xsolapi_auto_materialization_type
</td>
<td>
PRED_AND_RC
</td>
<td>
OLAP API behavior for auto materialization
</td>
</tr>
<tr>
<td>
_xsolapi_build_trace
</td>
<td>
FALSE
</td>
<td>
OLAP API output build info to trace file
</td>
</tr>
<tr>
<td>
_xsolapi_debug_output
</td>
<td>
SUPPRESS
</td>
<td>
OLAP API debug output disposition
</td>
</tr>
<tr>
<td>
_xsolapi_densify_cubes
</td>
<td>
TABULAR
</td>
<td>
OLAP API cube densification
</td>
</tr>
<tr>
<td>
_xsolapi_dimension_group_creation
</td>
<td>
OVERFETCH
</td>
<td>
OLAP API symmetric overfetch
</td>
</tr>
<tr>
<td>
_xsolapi_dml_trace
</td>
<td>
FALSE
</td>
<td>
OLAP API output dml commands and expressions
to trace file
</td>
</tr>
<tr>
<td>
_xsolapi_fetch_type
</td>
<td>
PARTIAL
</td>
<td>
OLAP API fetch type
</td>
</tr>
<tr>
<td>
_xsolapi_fix_vptrs
</td>
<td>
FALSE
</td>
<td>
OLAP API Enable vptr fixing logic in shared s
erver mode
</td>
</tr>
<tr>
<td>
_xsolapi_generate_with_clause
</td>
<td>
FALSE
</td>
<td>
OLAP API generates WITH clause?
</td>
</tr>
<tr>
<td>
_xsolapi_hierarchy_value_type
</td>
<td>
unique
</td>
<td>
OLAP API hierarchy value type
</td>
</tr>
<tr>
<td>
_xsolapi_load_at_process_start
</td>
<td>
NEVER
</td>
<td>
When to load OLAP API library at server proce
ss start
</td>
</tr>
<tr>
<td>
_xsolapi_materialization_rowcache_min_rows_fo
r_use
</td>
<td>
1
</td>
<td>
OLAP API min number of rows required to use r
owcache in query materialization
</td>
</tr>
<tr>
<td>
_xsolapi_materialize_sources
</td>
<td>
TRUE
</td>
<td>
OLAP API Enable source materialization
</td>
</tr>
<tr>
<td>
_xsolapi_metadata_reader_mode
</td>
<td>
11_ONLY
</td>
<td>
OLAP API metadata reader mode
</td>
</tr>
<tr>
<td>
_xsolapi_odbo_mode
</td>
<td>
FALSE
</td>
<td>
OLAP API uses ODBO mode?
</td>
</tr>
<tr>
<td>
_xsolapi_opt_aw_position
</td>
<td>
TRUE
</td>
<td>
OLAP API enables AW position and count optimi
zation?
</td>
</tr>
<tr>
<td>
_xsolapi_optimize_suppression
</td>
<td>
TRUE
</td>
<td>
OLAP API optimizes suppressions?
</td>
</tr>
<tr>
<td>
_xsolapi_precompute_subquery
</td>
<td>
TRUE
</td>
<td>
OLAP API precomputes subqueries?
</td>
</tr>
<tr>
<td>
_xsolapi_remove_columns_for_materialization
</td>
<td>
TRUE
</td>
<td>
OLAP API removes columns for materialization?
</td>
</tr>
<tr>
<td>
_xsolapi_set_nls
</td>
<td>
TRUE
</td>
<td>
OLAP API sets NLS?
</td>
</tr>
<tr>
<td>
_xsolapi_share_executors
</td>
<td>
TRUE
</td>
<td>
OLAP API share executors?
</td>
</tr>
<tr>
<td>
_xsolapi_source_trace
</td>
<td>
FALSE
</td>
<td>
OLAP API output Source definitions to trace f
ile
</td>
</tr>
<tr>
<td>
_xsolapi_sql_all_multi_join_non_base_hints
</td>
<td>
&nbsp;
</td>
<td>
OLAP API multi-join non-base hints
</td>
</tr>
<tr>
<td>
_xsolapi_sql_all_non_base_hints
</td>
<td>
&nbsp;
</td>
<td>
OLAP API non-base hints
</td>
</tr>
<tr>
<td>
_xsolapi_sql_auto_dimension_hints
</td>
<td>
FALSE
</td>
<td>
OLAP API enable automatic dimension hints
</td>
</tr>
<tr>
<td>
_xsolapi_sql_auto_measure_hints
</td>
<td>
TRUE
</td>
<td>
OLAP API enable automatic measure hints
</td>
</tr>
<tr>
<td>
_xsolapi_sql_dimension_hints
</td>
<td>
&nbsp;
</td>
<td>
OLAP API dimension hints
</td>
</tr>
<tr>
<td>
_xsolapi_sql_enable_aw_join
</td>
<td>
TRUE
</td>
<td>
OLAP API enables AW join?
</td>
</tr>
<tr>
<td>
_xsolapi_sql_enable_aw_qdr_merge
</td>
<td>
TRUE
</td>
<td>
OLAP API enables AW QDR merge?
</td>
</tr>
<tr>
<td>
_xsolapi_sql_hints
</td>
<td>
&nbsp;
</td>
<td>
OLAP API generic hints
</td>
</tr>
<tr>
<td>
_xsolapi_sql_measure_hints
</td>
<td>
&nbsp;
</td>
<td>
OLAP API measure hints
</td>
</tr>
<tr>
<td>
_xsolapi_sql_minus_threshold
</td>
<td>
1000
</td>
<td>
OLAP API SQL MINUS threshold
</td>
</tr>
<tr>
<td>
_xsolapi_sql_optimize
</td>
<td>
TRUE
</td>
<td>
OLAP API enable optimization
</td>
</tr>
<tr>
<td>
_xsolapi_sql_prepare_stmt_cache_size
</td>
<td>
16
</td>
<td>
OLAP API prepare statement cache size
</td>
</tr>
<tr>
<td>
_xsolapi_sql_remove_columns
</td>
<td>
TRUE
</td>
<td>
OLAP API enable remove unused columns optimiz
ations
</td>
</tr>
<tr>
<td>
_xsolapi_sql_result_set_cache_size
</td>
<td>
32
</td>
<td>
OLAP API result set cache size
</td>
</tr>
<tr>
<td>
_xsolapi_sql_symmetric_predicate
</td>
<td>
TRUE
</td>
<td>
OLAP API enable symmetric predicate for dimen
sion groups
</td>
</tr>
<tr>
<td>
_xsolapi_sql_top_dimension_hints
</td>
<td>
&nbsp;
</td>
<td>
OLAP API top dimension hints
</td>
</tr>
<tr>
<td>
_xsolapi_sql_top_measure_hints
</td>
<td>
&nbsp;
</td>
<td>
OLAP API top measure hints
</td>
</tr>
<tr>
<td>
_xsolapi_sql_use_bind_variables
</td>
<td>
TRUE
</td>
<td>
OLAP API enable bind variables optimization
</td>
</tr>
<tr>
<td>
_xsolapi_stringify_order_levels
</td>
<td>
FALSE
</td>
<td>
OLAP API stringifies order levels?
</td>
</tr>
<tr>
<td>
_xsolapi_support_mtm
</td>
<td>
FALSE
</td>
<td>
OLAP API MTM mapping classes supported?
</td>
</tr>
<tr>
<td>
_xsolapi_suppression_aw_mask_threshold
</td>
<td>
1000
</td>
<td>
OLAP API suppression AW mask threshold
</td>
</tr>
<tr>
<td>
_xsolapi_suppression_chunk_size
</td>
<td>
4000
</td>
<td>
OLAP API suppression chunk size
</td>
</tr>
<tr>
<td>
_xsolapi_use_models
</td>
<td>
TRUE
</td>
<td>
OLAP API uses models?
</td>
</tr>
<tr>
<td>
_xsolapi_use_olap_dml
</td>
<td>
TRUE
</td>
<td>
OLAP API uses OLAP DML?
</td>
</tr>
<tr>
<td>
_xsolapi_use_olap_dml_for_rank
</td>
<td>
TRUE
</td>
<td>
OLAP API uses OLAP DML for rank?
</td>
</tr>
<tr>
<td>
_xt_coverage
</td>
<td>
none
</td>
<td>
external tables code coverage parameter
</td>
</tr>
<tr>
<td>
_xt_trace
</td>
<td>
none
</td>
<td>
external tables trace parameter
</td>
</tr>
<tr>
<td>
_xtbuffer_size
</td>
<td>
0
</td>
<td>
buffer size in KB needed for populate/query o
peration
</td>
</tr>
<tr>
<td>
_xtts_allow_pre10
</td>
<td>
FALSE
</td>
<td>
allow cross platform for pre10 compatible tab
lespace
</td>
</tr>
<tr>
<td>
_xtts_set_platform_info
</td>
<td>
FALSE
</td>
<td>
set cross platform info during file header re
ad
</td>
</tr>
<tr>
<td>
_yield_check_interval
</td>
<td>
100000
</td>
<td>
interval to check whether actses should yield
</td>
</tr>
</table>
<p>

1627 rows selected.<br>
<br>


