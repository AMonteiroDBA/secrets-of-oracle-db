<p>
<table border='1' width='90%' align='center' summary='Script output'>
<tr>
<th scope="col">
NAME
</th>
<th scope="col">
VALUE
</th>
<th scope="col">
DESCRIPTION
</th>
</tr>
<tr>
<td>
_4031_dump_bitvec
</td>
<td>
67194879
</td>
<td>
bitvec to specify dumps prior to 4031 error
</td>
</tr>
<tr>
<td>
_4031_dump_interval
</td>
<td>
300
</td>
<td>
Dump 4031 error once for each n-second interv
al
</td>
</tr>
<tr>
<td>
_4031_max_dumps
</td>
<td>
100
</td>
<td>
Maximum number of 4031 dumps for this process
</td>
</tr>
<tr>
<td>
_4031_sga_dump_interval
</td>
<td>
3600
</td>
<td>
Dump 4031 SGA heapdump error once for each n-
second interval
</td>
</tr>
<tr>
<td>
_4031_sga_max_dumps
</td>
<td>
10
</td>
<td>
Maximum number of SGA heapdumps
</td>
</tr>
<tr>
<td>
_NUMA_instance_mapping
</td>
<td>
Not specified
</td>
<td>
Set of nodes that this instance should run on
</td>
</tr>
<tr>
<td>
_NUMA_pool_size
</td>
<td>
Not specified
</td>
<td>
aggregate size in bytes of NUMA pool
</td>
</tr>
<tr>
<td>
_PX_use_large_pool
</td>
<td>
FALSE
</td>
<td>
Use Large Pool as source of PX buffers
</td>
</tr>
<tr>
<td>
__db_cache_size
</td>
<td>
50331648
</td>
<td>
Actual size of DEFAULT buffer pool for standa
rd block size buffers
</td>
</tr>
<tr>
<td>
__dg_broker_service_names
</td>
<td>
TEN_XPT
</td>
<td>
service names for broker use
</td>
</tr>
<tr>
<td>
__java_pool_size
</td>
<td>
0
</td>
<td>
Actual size in bytes of java pool
</td>
</tr>
<tr>
<td>
__large_pool_size
</td>
<td>
0
</td>
<td>
Actual size in bytes of large pool
</td>
</tr>
<tr>
<td>
__shared_pool_size
</td>
<td>
54525952
</td>
<td>
Actual size in bytes of shared pool
</td>
</tr>
<tr>
<td>
__streams_pool_size
</td>
<td>
0
</td>
<td>
Actual size in bytes of streams pool
</td>
</tr>
<tr>
<td>
_abort_recovery_on_join
</td>
<td>
FALSE
</td>
<td>
if TRUE, abort recovery on join reconfigurati
ons
</td>
</tr>
<tr>
<td>
_accept_versions
</td>
<td>
&nbsp;
</td>
<td>
List of parameters for rolling operation
</td>
</tr>
<tr>
<td>
_active_standby_fast_reconfiguration
</td>
<td>
TRUE
</td>
<td>
if TRUE optimize dlm reconfiguration for acti
ve/standby OPS
</td>
</tr>
<tr>
<td>
_adaptive_direct_read
</td>
<td>
TRUE
</td>
<td>
Adaptive Direct Read
</td>
</tr>
<tr>
<td>
_adaptive_fetch_enabled
</td>
<td>
TRUE
</td>
<td>
enable/disable adaptive fetch in parallel gro
up by
</td>
</tr>
<tr>
<td>
_add_stale_mv_to_dependency_list
</td>
<td>
TRUE
</td>
<td>
add stale mv to dependency list
</td>
</tr>
<tr>
<td>
_addm_auto_enable
</td>
<td>
TRUE
</td>
<td>
governs whether ADDM gets run automatically a
fter every AWR snapshot
</td>
</tr>
<tr>
<td>
_addm_skiprules
</td>
<td>
&nbsp;
</td>
<td>
comma-separated list of ADDM nodes to skip
</td>
</tr>
<tr>
<td>
_addm_version_check
</td>
<td>
TRUE
</td>
<td>
governs whether ADDM checks the input AWR sna
pshot version
</td>
</tr>
<tr>
<td>
_adjust_literal_replacement
</td>
<td>
FALSE
</td>
<td>
If TRUE, we will adjust the SQL/PLUS output
</td>
</tr>
<tr>
<td>
_affinity_on
</td>
<td>
TRUE
</td>
<td>
enable/disable affinity at run time
</td>
</tr>
<tr>
<td>
_aiowait_timeouts
</td>
<td>
100
</td>
<td>
Number of aiowait timeouts before error is re
ported
</td>
</tr>
<tr>
<td>
_alert_expiration
</td>
<td>
604800
</td>
<td>
seconds before an alert message is moved to e
xception queue
</td>
</tr>
<tr>
<td>
_alert_message_cleanup
</td>
<td>
1
</td>
<td>
Enable Alert Message Cleanup
</td>
</tr>
<tr>
<td>
_alert_message_purge
</td>
<td>
1
</td>
<td>
Enable Alert Message Purge
</td>
</tr>
<tr>
<td>
_alert_post_background
</td>
<td>
1
</td>
<td>
Enable Background Alert Posting
</td>
</tr>
<tr>
<td>
_all_shared_dblinks
</td>
<td>
&nbsp;
</td>
<td>
treat all dblinks as shared
</td>
</tr>
<tr>
<td>
_allocate_creation_order
</td>
<td>
FALSE
</td>
<td>
should files be examined in creation order du
ring allocation
</td>
</tr>
<tr>
<td>
_allocation_update_interval
</td>
<td>
3
</td>
<td>
interval at which successful search in L1 sho
uld be updated
</td>
</tr>
<tr>
<td>
_allow_commutativity
</td>
<td>
TRUE
</td>
<td>
allow for commutativity of +, * when comparin
g expressions
</td>
</tr>
<tr>
<td>
_allow_error_simulation
</td>
<td>
FALSE
</td>
<td>
Allow error simulation for testing
</td>
</tr>
<tr>
<td>
_allow_level_without_connect_by
</td>
<td>
FALSE
</td>
<td>
allow level without connect by
</td>
</tr>
<tr>
<td>
_allow_read_only_corruption
</td>
<td>
FALSE
</td>
<td>
allow read-only open even if database is corr
upt
</td>
</tr>
<tr>
<td>
_allow_resetlogs_corruption
</td>
<td>
FALSE
</td>
<td>
allow resetlogs even if it will cause corrupt
ion
</td>
</tr>
<tr>
<td>
_allow_terminal_recovery_corruption
</td>
<td>
FALSE
</td>
<td>
Finish terminal recovery even if it may cause
 corruption
</td>
</tr>
<tr>
<td>
_alternate_iot_leaf_block_split_points
</td>
<td>
TRUE
</td>
<td>
enable alternate index-organized table leaf-b
lock split-points
</td>
</tr>
<tr>
<td>
_always_anti_join
</td>
<td>
CHOOSE
</td>
<td>
always use this method for anti-join when pos
sible
</td>
</tr>
<tr>
<td>
_always_semi_join
</td>
<td>
CHOOSE
</td>
<td>
always use this method for semi-join when pos
sible
</td>
</tr>
<tr>
<td>
_always_star_transformation
</td>
<td>
FALSE
</td>
<td>
always favor use of star transformation
</td>
</tr>
<tr>
<td>
_app_ctx_vers
</td>
<td>
FALSE
</td>
<td>
enable app ctx versioning
</td>
</tr>
<tr>
<td>
_aq_tm_scanlimit
</td>
<td>
0
</td>
<td>
scan limit for Time Managers to clean up IOT
</td>
</tr>
<tr>
<td>
_arch_io_slaves
</td>
<td>
0
</td>
<td>
ARCH I/O slaves
</td>
</tr>
<tr>
<td>
_array_update_vector_read_enabled
</td>
<td>
FALSE
</td>
<td>
Enable array update vector read
</td>
</tr>
<tr>
<td>
_ash_disk_filter_ratio
</td>
<td>
10
</td>
<td>
Ratio of the number of in-memory samples to t
he number of samples actually written to disk
</td>
</tr>
<tr>
<td>
_ash_disk_write_enable
</td>
<td>
TRUE
</td>
<td>
To enable or disable Active Session History f
lushing
</td>
</tr>
<tr>
<td>
_ash_dummy_test_param
</td>
<td>
0
</td>
<td>
Oracle internal dummy ASH parameter used ONLY
 for testing!
</td>
</tr>
<tr>
<td>
_ash_eflush_trigger
</td>
<td>
66
</td>
<td>
The percentage above which if the in-memory A
SH is full the emergency flusher will be trig
gered
</td>
</tr>
<tr>
<td>
_ash_enable
</td>
<td>
TRUE
</td>
<td>
To enable or disable Active Session sampling
and flushing
</td>
</tr>
<tr>
<td>
_ash_sample_all
</td>
<td>
FALSE
</td>
<td>
To enable or disable sampling every connected
 session including ones waiting for idle wait
s
</td>
</tr>
<tr>
<td>
_ash_sampling_interval
</td>
<td>
1000
</td>
<td>
Time interval between two successive Active S
ession samples in millisecs
</td>
</tr>
<tr>
<td>
_ash_size
</td>
<td>
1048618
</td>
<td>
To set the size of the in-memory Active Sessi
on History buffers
</td>
</tr>
<tr>
<td>
_asm_acd_chunks
</td>
<td>
1
</td>
<td>
initial ACD chunks created
</td>
</tr>
<tr>
<td>
_asm_allow_only_raw_disks
</td>
<td>
TRUE
</td>
<td>
Discovery only raw devices
</td>
</tr>
<tr>
<td>
_asm_allow_resilver_corruption
</td>
<td>
FALSE
</td>
<td>
Enable disk resilvering for external redundan
cy
</td>
</tr>
<tr>
<td>
_asm_ausize
</td>
<td>
1048576
</td>
<td>
allocation unit size
</td>
</tr>
<tr>
<td>
_asm_blksize
</td>
<td>
4096
</td>
<td>
metadata block size
</td>
</tr>
<tr>
<td>
_asm_disk_repair_time
</td>
<td>
14400
</td>
<td>
seconds to wait before dropping a failing dis
k
</td>
</tr>
<tr>
<td>
_asm_droptimeout
</td>
<td>
60
</td>
<td>
timeout before offlined disks get dropped (in
 3s ticks)
</td>
</tr>
<tr>
<td>
_asm_emulmax
</td>
<td>
10000
</td>
<td>
max number of concurrent disks to emulate I/O
 errors
</td>
</tr>
<tr>
<td>
_asm_emultimeout
</td>
<td>
0
</td>
<td>
timeout before emulation begins (in 3s ticks)
</td>
</tr>
<tr>
<td>
_asm_kfdpevent
</td>
<td>
0
</td>
<td>
KFDP event
</td>
</tr>
<tr>
<td>
_asm_libraries
</td>
<td>
ufs
</td>
<td>
library search order for discovery
</td>
</tr>
<tr>
<td>
_asm_maxio
</td>
<td>
1048576
</td>
<td>
Maximum size of individual I/O request
</td>
</tr>
<tr>
<td>
_asm_stripesize
</td>
<td>
131072
</td>
<td>
ASM file stripe size
</td>
</tr>
<tr>
<td>
_asm_stripewidth
</td>
<td>
8
</td>
<td>
ASM file stripe width
</td>
</tr>
<tr>
<td>
_asm_wait_time
</td>
<td>
18
</td>
<td>
Max/imum time to wait before asmb exits
</td>
</tr>
<tr>
<td>
_asmlib_test
</td>
<td>
0
</td>
<td>
Osmlib test event
</td>
</tr>
<tr>
<td>
_asmsid
</td>
<td>
asm
</td>
<td>
ASM instance id
</td>
</tr>
<tr>
<td>
_assm_default
</td>
<td>
TRUE
</td>
<td>
ASSM default
</td>
</tr>
<tr>
<td>
_async_recovery_claims
</td>
<td>
TRUE
</td>
<td>
if TRUE, issue recovery claims asynchronously
</td>
</tr>
<tr>
<td>
_async_recovery_reads
</td>
<td>
TRUE
</td>
<td>
if TRUE, issue recovery reads asynchronously
</td>
</tr>
<tr>
<td>
_avoid_prepare
</td>
<td>
TRUE
</td>
<td>
if TRUE, do not prepare a buffer when the mas
ter is local
</td>
</tr>
<tr>
<td>
_awr_corrupt_mode
</td>
<td>
FALSE
</td>
<td>
AWR Corrupt Mode
</td>
</tr>
<tr>
<td>
_awr_disabled_flush_tables
</td>
<td>
&nbsp;
</td>
<td>
Disable flushing of specified AWR tables
</td>
</tr>
<tr>
<td>
_awr_flush_threshold_metrics
</td>
<td>
FALSE
</td>
<td>
Enable/Disable Flushing AWR Workload Metrics
</td>
</tr>
<tr>
<td>
_awr_flush_workload_metrics
</td>
<td>
FALSE
</td>
<td>
Enable/Disable Flushing AWR Workload Metrics
</td>
</tr>
<tr>
<td>
_awr_mmon_cpuusage
</td>
<td>
TRUE
</td>
<td>
Enable/disable AWR MMON CPU Usage Tracking
</td>
</tr>
<tr>
<td>
_awr_restrict_mode
</td>
<td>
FALSE
</td>
<td>
AWR Restrict Mode
</td>
</tr>
<tr>
<td>
_awr_sql_child_limit
</td>
<td>
200
</td>
<td>
Setting for AWR SQL Child Limit
</td>
</tr>
<tr>
<td>
_b_tree_bitmap_plans
</td>
<td>
TRUE
</td>
<td>
enable the use of bitmap plans for tables w.
only B-tree indexes
</td>
</tr>
<tr>
<td>
_backup_disk_io_slaves
</td>
<td>
0
</td>
<td>
BACKUP Disk I/O slaves
</td>
</tr>
<tr>
<td>
_backup_io_pool_size
</td>
<td>
1048576
</td>
<td>
memory to reserve from the large pool
</td>
</tr>
<tr>
<td>
_backup_kgc_bufsz
</td>
<td>
0
</td>
<td>
specifies buffer size to be used for kgc comp
ression
</td>
</tr>
<tr>
<td>
_backup_kgc_niters
</td>
<td>
0
</td>
<td>
specifies number of iterations used for kgc c
ompression
</td>
</tr>
<tr>
<td>
_backup_kgc_type
</td>
<td>
0
</td>
<td>
specifies compression type used for kgc compr
ession
</td>
</tr>
<tr>
<td>
_backup_ksfq_bufcnt
</td>
<td>
0
</td>
<td>
number of the ksfq buffers used for backup/re
store
</td>
</tr>
<tr>
<td>
_backup_ksfq_bufsz
</td>
<td>
0
</td>
<td>
size of the ksfq buffer used for backup/resto
re
</td>
</tr>
<tr>
<td>
_backup_max_gap_size
</td>
<td>
4294967294
</td>
<td>
largest gap in an incremental/optimized backu
p buffer, in bytes
</td>
</tr>
<tr>
<td>
_bct_bitmaps_per_file
</td>
<td>
8
</td>
<td>
number of bitmaps to store for each datafile
</td>
</tr>
<tr>
<td>
_bct_buffer_allocation_max
</td>
<td>
104857600
</td>
<td>
maximum size of all change tracking buffer al
locations, in bytes
</td>
</tr>
<tr>
<td>
_bct_buffer_allocation_min_extents
</td>
<td>
1
</td>
<td>
mininum number of extents to allocate per buf
fer allocation
</td>
</tr>
<tr>
<td>
_bct_buffer_allocation_size
</td>
<td>
2097152
</td>
<td>
size of one change tracking buffer allocation
, in bytes
</td>
</tr>
<tr>
<td>
_bct_chunk_size
</td>
<td>
0
</td>
<td>
change tracking datafile chunk size, in bytes
</td>
</tr>
<tr>
<td>
_bct_crash_reserve_size
</td>
<td>
262144
</td>
<td>
change tracking reserved crash recovery SGA s
pace, in bytes
</td>
</tr>
<tr>
<td>
_bct_file_block_size
</td>
<td>
0
</td>
<td>
block size of change tracking file, in bytes
</td>
</tr>
<tr>
<td>
_bct_file_extent_size
</td>
<td>
0
</td>
<td>
extent size of change tracking file, in bytes
</td>
</tr>
<tr>
<td>
_bct_fixtab_file
</td>
<td>
&nbsp;
</td>
<td>
change tracking file for fixed tables
</td>
</tr>
<tr>
<td>
_bct_initial_private_dba_buffer_size
</td>
<td>
0
</td>
<td>
initial number of entries in the private chan
ge tracking dba buffers
</td>
</tr>
<tr>
<td>
_bct_public_dba_buffer_size
</td>
<td>
0
</td>
<td>
total size of all public change tracking dba
buffers, in bytes
</td>
</tr>
<tr>
<td>
_bitmap_or_improvement_enabled
</td>
<td>
TRUE
</td>
<td>
controls extensions to partition pruning for
general predicates
</td>
</tr>
<tr>
<td>
_block_change_tracking
</td>
<td>
TRUE
</td>
<td>
change tracking possible
</td>
</tr>
<tr>
<td>
_blocks_per_cache_server
</td>
<td>
128
</td>
<td>
number of consecutive blocks per global cache
 server
</td>
</tr>
<tr>
<td>
_bloom_filter_debug
</td>
<td>
0
</td>
<td>
debug level for bloom filtering
</td>
</tr>
<tr>
<td>
_bloom_filter_enabled
</td>
<td>
TRUE
</td>
<td>
enables or disables bloom filter
</td>
</tr>
<tr>
<td>
_bt_mmv_query_rewrite_enabled
</td>
<td>
TRUE
</td>
<td>
allow rewrites with multiple MVs and base tab
les
</td>
</tr>
<tr>
<td>
_buffer_busy_wait_timeout
</td>
<td>
100
</td>
<td>
buffer busy wait time in centiseconds
</td>
</tr>
<tr>
<td>
_bufq_flow_control_thrsh
</td>
<td>
0
</td>
<td>
flow control threshold value
</td>
</tr>
<tr>
<td>
_bufq_max_msg_sz
</td>
<td>
0
</td>
<td>
maximum size of the message allowed in memory
</td>
</tr>
<tr>
<td>
_bufq_stop_flow_control
</td>
<td>
FALSE
</td>
<td>
Stop enforcing flow control for buffered queu
es
</td>
</tr>
<tr>
<td>
_build_deferred_mv_skipping_mvlog_update
</td>
<td>
FALSE
</td>
<td>
DEFERRED MV creation skipping MV log setup up
date
</td>
</tr>
<tr>
<td>
_bump_highwater_mark_count
</td>
<td>
0
</td>
<td>
how many blocks should we allocate per free l
ist on advancing HWM
</td>
</tr>
<tr>
<td>
_bwr_for_flushed_pi
</td>
<td>
TRUE
</td>
<td>
if TRUE, generate a BWR for a flushed PI
</td>
</tr>
<tr>
<td>
_cache_stats_monitor
</td>
<td>
FALSE
</td>
<td>
if TRUE, enable cache stats monitoring
</td>
</tr>
<tr>
<td>
_cgs_reconfig_timeout
</td>
<td>
120
</td>
<td>
CGS reconfiguration timeout interval
</td>
</tr>
<tr>
<td>
_cgs_send_timeout
</td>
<td>
300
</td>
<td>
CGS send timeout value
</td>
</tr>
<tr>
<td>
_check_block_after_checksum
</td>
<td>
TRUE
</td>
<td>
perform block check after checksum if both ar
e turned on
</td>
</tr>
<tr>
<td>
_check_ts_threshold
</td>
<td>
0
</td>
<td>
check tablespace thresholds
</td>
</tr>
<tr>
<td>
_cleanup_rollback_entries
</td>
<td>
100
</td>
<td>
no. of undo entries to apply per transaction
cleanup
</td>
</tr>
<tr>
<td>
_close_cached_open_cursors
</td>
<td>
FALSE
</td>
<td>
close cursors cached by PL/SQL at each commit
</td>
</tr>
<tr>
<td>
_cluster_library
</td>
<td>
clss
</td>
<td>
cluster library selection
</td>
</tr>
<tr>
<td>
_collapse_wait_history
</td>
<td>
FALSE
</td>
<td>
collapse wait history
</td>
</tr>
<tr>
<td>
_collect_undo_stats
</td>
<td>
TRUE
</td>
<td>
Collect Statistics v$undostat
</td>
</tr>
<tr>
<td>
_column_compression_factor
</td>
<td>
0
</td>
<td>
Column compression ratio
</td>
</tr>
<tr>
<td>
_column_elimination_off
</td>
<td>
FALSE
</td>
<td>
turn off predicate-only column elimination
</td>
</tr>
<tr>
<td>
_column_tracking_level
</td>
<td>
1
</td>
<td>
column usage tracking
</td>
</tr>
<tr>
<td>
_compilation_call_heap_extent_size
</td>
<td>
16384
</td>
<td>
Size of the compilation call heaps extents
</td>
</tr>
<tr>
<td>
_complex_view_merging
</td>
<td>
TRUE
</td>
<td>
enable complex view merging
</td>
</tr>
<tr>
<td>
_controlfile_block_size
</td>
<td>
0
</td>
<td>
control file block size in bytes
</td>
</tr>
<tr>
<td>
_controlfile_enqueue_dump
</td>
<td>
FALSE
</td>
<td>
dump the system states after controlfile enqu
eue timeout
</td>
</tr>
<tr>
<td>
_controlfile_enqueue_timeout
</td>
<td>
900
</td>
<td>
control file enqueue timeout in seconds
</td>
</tr>
<tr>
<td>
_controlfile_section_init_size
</td>
<td>
&nbsp;
</td>
<td>
control file initial section size
</td>
</tr>
<tr>
<td>
_controlfile_section_max_expand
</td>
<td>
&nbsp;
</td>
<td>
control file max expansion rate
</td>
</tr>
<tr>
<td>
_controlfile_update_check
</td>
<td>
OFF
</td>
<td>
controlfile update sanity check
</td>
</tr>
<tr>
<td>
_convert_set_to_join
</td>
<td>
FALSE
</td>
<td>
enables conversion of set operator to join
</td>
</tr>
<tr>
<td>
_coord_message_buffer
</td>
<td>
0
</td>
<td>
parallel recovery coordinator side extra mess
age buffer size
</td>
</tr>
<tr>
<td>
_corrupted_rollback_segments
</td>
<td>
&nbsp;
</td>
<td>
corrupted undo segment list
</td>
</tr>
<tr>
<td>
_cost_equality_semi_join
</td>
<td>
TRUE
</td>
<td>
enables costing of equality semi-join
</td>
</tr>
<tr>
<td>
_cpu_to_io
</td>
<td>
0
</td>
<td>
divisor for converting CPU cost to I/O cost
</td>
</tr>
<tr>
<td>
_cr_grant_global_role
</td>
<td>
TRUE
</td>
<td>
if TRUE, grant lock for CR requests when bloc
k is in global role
</td>
</tr>
<tr>
<td>
_cr_grant_local_role
</td>
<td>
AUTO
</td>
<td>
turn 3-way CR grants off, make it automatic,
or turn it on
</td>
</tr>
<tr>
<td>
_cr_server_log_flush
</td>
<td>
TRUE
</td>
<td>
if TRUE, flush redo log before serving a CR b
uffer
</td>
</tr>
<tr>
<td>
_ctas_hwm_brokered_loads
</td>
<td>
TRUE
</td>
<td>
Enable HWM brokered CTAS
</td>
</tr>
<tr>
<td>
_cursor_bind_capture_area_size
</td>
<td>
400
</td>
<td>
maximum size of the cursor bind capture area
</td>
</tr>
<tr>
<td>
_cursor_bind_capture_interval
</td>
<td>
900
</td>
<td>
interval (in seconds) between two bind captur
e for a cursor
</td>
</tr>
<tr>
<td>
_cursor_cache_frame_bind_memory
</td>
<td>
FALSE
</td>
<td>
frame &amp; bind buffer caching
</td>
</tr>
<tr>
<td>
_cursor_db_buffers_pinned
</td>
<td>
117
</td>
<td>
additional number of buffers a cursor can pin
 at once
</td>
</tr>
<tr>
<td>
_cursor_plan_enabled
</td>
<td>
TRUE
</td>
<td>
enable collection and display of cursor plans
</td>
</tr>
<tr>
<td>
_cursor_plan_hash_version
</td>
<td>
1
</td>
<td>
version of cursor plan hash value
</td>
</tr>
<tr>
<td>
_cursor_plan_unparse_enabled
</td>
<td>
TRUE
</td>
<td>
enables/disables using unparse to build proje
ction/predicates
</td>
</tr>
<tr>
<td>
_cursor_stats_bucket
</td>
<td>
15
</td>
<td>
Hash table buckets for cursor stats (2^).
</td>
</tr>
<tr>
<td>
_cursor_stats_heap
</td>
<td>
4
</td>
<td>
Heaps/latches for cursor stats.
</td>
</tr>
<tr>
<td>
_db_aging_cool_count
</td>
<td>
1
</td>
<td>
Touch count set when buffer cooled
</td>
</tr>
<tr>
<td>
_db_aging_freeze_cr
</td>
<td>
FALSE
</td>
<td>
Make CR buffers always be too cold to keep in
 cache
</td>
</tr>
<tr>
<td>
_db_aging_hot_criteria
</td>
<td>
2
</td>
<td>
Touch count which sends a buffer to head of r
eplacement list
</td>
</tr>
<tr>
<td>
_db_aging_stay_count
</td>
<td>
0
</td>
<td>
Touch count set when buffer moved to head of
replacement list
</td>
</tr>
<tr>
<td>
_db_aging_touch_time
</td>
<td>
3
</td>
<td>
Touch count which sends a buffer to head of r
eplacement list
</td>
</tr>
<tr>
<td>
_db_always_check_system_ts
</td>
<td>
TRUE
</td>
<td>
Always perform block check and checksum for S
ystem tablespace
</td>
</tr>
<tr>
<td>
_db_block_adjcheck
</td>
<td>
TRUE
</td>
<td>
adjacent cache buffer checks - low blkchk ove
rwrite parameter
</td>
</tr>
<tr>
<td>
_db_block_adjchk_level
</td>
<td>
79331840
</td>
<td>
adjacent cache buffer check level
</td>
</tr>
<tr>
<td>
_db_block_align_direct_read
</td>
<td>
TRUE
</td>
<td>
Align Direct Reads
</td>
</tr>
<tr>
<td>
_db_block_buffers
</td>
<td>
5988
</td>
<td>
Number of database blocks cached in memory: h
idden parameter
</td>
</tr>
<tr>
<td>
_db_block_cache_clone
</td>
<td>
FALSE
</td>
<td>
Always clone data blocks on get (for debuggin
g)
</td>
</tr>
<tr>
<td>
_db_block_cache_history
</td>
<td>
0
</td>
<td>
buffer header tracing (non-zero only when deb
ugging)
</td>
</tr>
<tr>
<td>
_db_block_cache_history_level
</td>
<td>
2
</td>
<td>
buffer header tracing level
</td>
</tr>
<tr>
<td>
_db_block_cache_num_umap
</td>
<td>
0
</td>
<td>
number of unmapped buffers (for tracking swap
 calls on blocks)
</td>
</tr>
<tr>
<td>
_db_block_cache_protect
</td>
<td>
FALSE
</td>
<td>
protect database blocks (true only when debug
ging)
</td>
</tr>
<tr>
<td>
_db_block_cache_protect_internal
</td>
<td>
0
</td>
<td>
protect database blocks (for strictly interna
l use only)
</td>
</tr>
<tr>
<td>
_db_block_check_for_debug
</td>
<td>
FALSE
</td>
<td>
Check more and dump block before image for de
bugging
</td>
</tr>
<tr>
<td>
_db_block_check_objtyp
</td>
<td>
TRUE
</td>
<td>
check objd and typ on cache disk read
</td>
</tr>
<tr>
<td>
_db_block_do_full_mbreads
</td>
<td>
FALSE
</td>
<td>
do full block read even if some blocks are in
 cache
</td>
</tr>
<tr>
<td>
_db_block_hash_buckets
</td>
<td>
16384
</td>
<td>
Number of database block hash buckets
</td>
</tr>
<tr>
<td>
_db_block_hash_latches
</td>
<td>
1024
</td>
<td>
Number of database block hash latches
</td>
</tr>
<tr>
<td>
_db_block_hi_priority_batch_size
</td>
<td>
0
</td>
<td>
Fraction of writes for high priority reasons
</td>
</tr>
<tr>
<td>
_db_block_known_clean_pct
</td>
<td>
2
</td>
<td>
Initial Percentage of buffers to maintain kno
wn clean
</td>
</tr>
<tr>
<td>
_db_block_lru_latches
</td>
<td>
8
</td>
<td>
number of lru latches
</td>
</tr>
<tr>
<td>
_db_block_max_cr_dba
</td>
<td>
6
</td>
<td>
Maximum Allowed Number of CR buffers per dba
</td>
</tr>
<tr>
<td>
_db_block_max_scan_pct
</td>
<td>
40
</td>
<td>
Percentage of buffers to inspect when looking
 for free
</td>
</tr>
<tr>
<td>
_db_block_med_priority_batch_size
</td>
<td>
0
</td>
<td>
Fraction of writes for medium priority reason
s
</td>
</tr>
<tr>
<td>
_db_block_numa
</td>
<td>
1
</td>
<td>
Number of NUMA nodes
</td>
</tr>
<tr>
<td>
_db_block_prefetch_limit
</td>
<td>
0
</td>
<td>
Prefetch limit in blocks
</td>
</tr>
<tr>
<td>
_db_block_prefetch_quota
</td>
<td>
10
</td>
<td>
Prefetch quota as a percent of cache size
</td>
</tr>
<tr>
<td>
_db_block_table_scan_buffer_size
</td>
<td>
4194304
</td>
<td>
Size of shared table scan read buffer
</td>
</tr>
<tr>
<td>
_db_block_temp_redo
</td>
<td>
FALSE
</td>
<td>
generate redo for temp blocks
</td>
</tr>
<tr>
<td>
_db_block_trace_protect
</td>
<td>
FALSE
</td>
<td>
trace buffer protect calls
</td>
</tr>
<tr>
<td>
_db_cache_advice_batch_size
</td>
<td>
128
</td>
<td>
cache advisory simulation batch size
</td>
</tr>
<tr>
<td>
_db_cache_advice_sample_factor
</td>
<td>
4
</td>
<td>
cache advisory sampling factor
</td>
</tr>
<tr>
<td>
_db_cache_crx_check
</td>
<td>
FALSE
</td>
<td>
check for costly crx examination functions
</td>
</tr>
<tr>
<td>
_db_cache_pre_warm
</td>
<td>
TRUE
</td>
<td>
Buffer Cache Pre-Warm Enabled : hidden parame
ter
</td>
</tr>
<tr>
<td>
_db_cache_process_cr_pin_max
</td>
<td>
&nbsp;
</td>
<td>
maximum number of cr pins a process may have
</td>
</tr>
<tr>
<td>
_db_change_notification_enable
</td>
<td>
TRUE
</td>
<td>
enable db change notification
</td>
</tr>
<tr>
<td>
_db_fast_obj_check
</td>
<td>
FALSE
</td>
<td>
enable fast object drop sanity check
</td>
</tr>
<tr>
<td>
_db_fast_obj_ckpt
</td>
<td>
TRUE
</td>
<td>
enable fast object checkpoint
</td>
</tr>
<tr>
<td>
_db_fast_obj_truncate
</td>
<td>
TRUE
</td>
<td>
enable fast object truncate
</td>
</tr>
<tr>
<td>
_db_file_direct_io_count
</td>
<td>
1048576
</td>
<td>
Sequential I/O buf size
</td>
</tr>
<tr>
<td>
_db_file_exec_read_count
</td>
<td>
16
</td>
<td>
multiblock read count for regular clients
</td>
</tr>
<tr>
<td>
_db_file_format_io_buffers
</td>
<td>
4
</td>
<td>
Block formatting I/O buf count
</td>
</tr>
<tr>
<td>
_db_file_noncontig_mblock_read_count
</td>
<td>
11
</td>
<td>
number of noncontiguous db blocks to be prefe
tched
</td>
</tr>
<tr>
<td>
_db_file_optimizer_read_count
</td>
<td>
16
</td>
<td>
multiblock read count for regular clients
</td>
</tr>
<tr>
<td>
_db_handles
</td>
<td>
250
</td>
<td>
System-wide simultaneous buffer operations
</td>
</tr>
<tr>
<td>
_db_handles_cached
</td>
<td>
5
</td>
<td>
Buffer handles cached each process
</td>
</tr>
<tr>
<td>
_db_hot_block_tracking
</td>
<td>
FALSE
</td>
<td>
track hot blocks for hash latch contention
</td>
</tr>
<tr>
<td>
_db_index_block_checking
</td>
<td>
TRUE
</td>
<td>
index block checking override parameter
</td>
</tr>
<tr>
<td>
_db_large_dirty_queue
</td>
<td>
25
</td>
<td>
Number of buffers which force dirty queue to
be written
</td>
</tr>
<tr>
<td>
_db_lost_write_checking
</td>
<td>
FALSE
</td>
<td>
Enable scn based lost write detection mechani
sm
</td>
</tr>
<tr>
<td>
_db_mttr_advice
</td>
<td>
ON
</td>
<td>
MTTR advisory
</td>
</tr>
<tr>
<td>
_db_mttr_partitions
</td>
<td>
0
</td>
<td>
number of partitions for MTTR advisory
</td>
</tr>
<tr>
<td>
_db_mttr_sample_factor
</td>
<td>
64
</td>
<td>
MTTR simulation sampling factor
</td>
</tr>
<tr>
<td>
_db_mttr_sim_target
</td>
<td>
&nbsp;
</td>
<td>
MTTR simulation targets
</td>
</tr>
<tr>
<td>
_db_mttr_sim_trace_size
</td>
<td>
256
</td>
<td>
MTTR simulation trace size
</td>
</tr>
<tr>
<td>
_db_mttr_trace_to_alert
</td>
<td>
FALSE
</td>
<td>
dump trace entries to alert file
</td>
</tr>
<tr>
<td>
_db_obj_ckpt_ordered
</td>
<td>
FALSE
</td>
<td>
fast object checkpoint ordered by lrba
</td>
</tr>
<tr>
<td>
_db_obj_enable_ksr
</td>
<td>
TRUE
</td>
<td>
enable ksr in object checkpoint/reuse
</td>
</tr>
<tr>
<td>
_db_percent_hot_default
</td>
<td>
50
</td>
<td>
Percent of default buffer pool considered hot
</td>
</tr>
<tr>
<td>
_db_percent_hot_keep
</td>
<td>
0
</td>
<td>
Percent of keep buffer pool considered hot
</td>
</tr>
<tr>
<td>
_db_percent_hot_recycle
</td>
<td>
0
</td>
<td>
Percent of recycle buffer pool considered hot
</td>
</tr>
<tr>
<td>
_db_percpu_create_cachesize
</td>
<td>
2
</td>
<td>
size of cache created per cpu in deferred cac
he create
</td>
</tr>
<tr>
<td>
_db_recovery_temporal_file_dest
</td>
<td>
&nbsp;
</td>
<td>
default database recovery temporal file locat
ion
</td>
</tr>
<tr>
<td>
_db_row_overlap_checking
</td>
<td>
TRUE
</td>
<td>
row overlap checking override parameter for d
ata/index blocks
</td>
</tr>
<tr>
<td>
_db_todefer_cache_create
</td>
<td>
TRUE
</td>
<td>
buffer cache deferred create
</td>
</tr>
<tr>
<td>
_db_writer_chunk_writes
</td>
<td>
0
</td>
<td>
Number of writes DBWR should wait for
</td>
</tr>
<tr>
<td>
_db_writer_coalesce_area_size
</td>
<td>
491520
</td>
<td>
Size of memory allocated to dbwriter for coal
escing writes
</td>
</tr>
<tr>
<td>
_db_writer_coalesce_write_limit
</td>
<td>
131072
</td>
<td>
Limit on size of coalesced write
</td>
</tr>
<tr>
<td>
_db_writer_flush_imu
</td>
<td>
TRUE
</td>
<td>
If FALSE, DBWR will not downgrade IMU txns fo
r AGING
</td>
</tr>
<tr>
<td>
_db_writer_histogram_statistics
</td>
<td>
FALSE
</td>
<td>
maintain dbwr histogram statistics in x$kcbbh
s
</td>
</tr>
<tr>
<td>
_db_writer_max_writes
</td>
<td>
0
</td>
<td>
Max number of outstanding DB Writer IOs
</td>
</tr>
<tr>
<td>
_db_writer_verify_writes
</td>
<td>
FALSE
</td>
<td>
Enable lost write detection mechanism
</td>
</tr>
<tr>
<td>
_dbg_proc_startup
</td>
<td>
FALSE
</td>
<td>
debug process startup
</td>
</tr>
<tr>
<td>
_dbwr_async_io
</td>
<td>
TRUE
</td>
<td>
Enable dbwriter asynchronous writes
</td>
</tr>
<tr>
<td>
_dbwr_scan_interval
</td>
<td>
300
</td>
<td>
dbwriter scan interval
</td>
</tr>
<tr>
<td>
_dbwr_tracing
</td>
<td>
0
</td>
<td>
Enable dbwriter tracing
</td>
</tr>
<tr>
<td>
_dead_process_scan_interval
</td>
<td>
10
</td>
<td>
PMON dead process scan interval
</td>
</tr>
<tr>
<td>
_debug_enable
</td>
<td>
FALSE
</td>
<td>
wait for debug
</td>
</tr>
<tr>
<td>
_dedicated_server_poll_count
</td>
<td>
10
</td>
<td>
dedicated server poll count
</td>
</tr>
<tr>
<td>
_dedicated_server_post_wait
</td>
<td>
FALSE
</td>
<td>
dedicated server post/wait
</td>
</tr>
<tr>
<td>
_dedicated_server_post_wait_call
</td>
<td>
FALSE
</td>
<td>
dedicated server post/wait call
</td>
</tr>
<tr>
<td>
_default_encrypt_alg
</td>
<td>
0
</td>
<td>
default encryption algorithm
</td>
</tr>
<tr>
<td>
_default_non_equality_sel_check
</td>
<td>
TRUE
</td>
<td>
sanity check on default selectivity for like/
range predicate
</td>
</tr>
<tr>
<td>
_delay_index_maintain
</td>
<td>
TRUE
</td>
<td>
delays index maintenance until after MV is re
freshed
</td>
</tr>
<tr>
<td>
_diag_daemon
</td>
<td>
TRUE
</td>
<td>
start DIAG daemon
</td>
</tr>
<tr>
<td>
_diag_diagnostics
</td>
<td>
TRUE
</td>
<td>
Turn off diag diagnostics
</td>
</tr>
<tr>
<td>
_dimension_skip_null
</td>
<td>
TRUE
</td>
<td>
control dimension skip when null feature
</td>
</tr>
<tr>
<td>
_disable_adaptive_shrunk_aggregation
</td>
<td>
FALSE
</td>
<td>
adaptive shrunk aggregation
</td>
</tr>
<tr>
<td>
_disable_datalayer_sampling
</td>
<td>
FALSE
</td>
<td>
disable datalayer sampling
</td>
</tr>
<tr>
<td>
_disable_duplex_link
</td>
<td>
FALSE
</td>
<td>
Turn off connection duplexing
</td>
</tr>
<tr>
<td>
_disable_fast_aggregation
</td>
<td>
FALSE
</td>
<td>
fast aggregation
</td>
</tr>
<tr>
<td>
_disable_file_locks
</td>
<td>
FALSE
</td>
<td>
disable file locks for control, data, redo lo
g files
</td>
</tr>
<tr>
<td>
_disable_function_based_index
</td>
<td>
FALSE
</td>
<td>
disable function-based index matching
</td>
</tr>
<tr>
<td>
_disable_health_check
</td>
<td>
FALSE
</td>
<td>
Disable Health Check
</td>
</tr>
<tr>
<td>
_disable_image_check
</td>
<td>
FALSE
</td>
<td>
Disable Oracle executable image checking
</td>
</tr>
<tr>
<td>
_disable_incremental_checkpoints
</td>
<td>
FALSE
</td>
<td>
Disable incremental checkpoints for thread re
covery
</td>
</tr>
<tr>
<td>
_disable_incremental_recovery_ckpt
</td>
<td>
FALSE
</td>
<td>
Disable incremental recovery checkpoint mecha
nism
</td>
</tr>
<tr>
<td>
_disable_instance_params_check
</td>
<td>
FALSE
</td>
<td>
disable instance type check for ksp
</td>
</tr>
<tr>
<td>
_disable_interface_checking
</td>
<td>
FALSE
</td>
<td>
disable interface checking at startup
</td>
</tr>
<tr>
<td>
_disable_kcbhxor_osd
</td>
<td>
FALSE
</td>
<td>
disable kcbh(c)xor OSD functionality
</td>
</tr>
<tr>
<td>
_disable_latch_free_SCN_writes_via_32cas
</td>
<td>
FALSE
</td>
<td>
disable latch-free SCN writes using 32-bit co
mpare &amp; swap
</td>
</tr>
<tr>
<td>
_disable_latch_free_SCN_writes_via_64cas
</td>
<td>
FALSE
</td>
<td>
disable latch-free SCN writes using 64-bit co
mpare &amp; swap
</td>
</tr>
<tr>
<td>
_disable_logging
</td>
<td>
FALSE
</td>
<td>
Disable logging
</td>
</tr>
<tr>
<td>
_disable_multiple_block_sizes
</td>
<td>
FALSE
</td>
<td>
disable multiple block size support (for debu
gging)
</td>
</tr>
<tr>
<td>
_disable_ntlog_events
</td>
<td>
FALSE
</td>
<td>
Disable logging to NT event log
</td>
</tr>
<tr>
<td>
_disable_odm
</td>
<td>
FALSE
</td>
<td>
disable odm feature
</td>
</tr>
<tr>
<td>
_disable_recoverable_recovery
</td>
<td>
FALSE
</td>
<td>
Disable the new recoverable recovery mechanis
m
</td>
</tr>
<tr>
<td>
_disable_recovery_read_skip
</td>
<td>
FALSE
</td>
<td>
Disable the read optimization during media re
covery
</td>
</tr>
<tr>
<td>
_disable_sample_io_optim
</td>
<td>
FALSE
</td>
<td>
disable row sampling IO optimization
</td>
</tr>
<tr>
<td>
_disable_savepoint_reset
</td>
<td>
FALSE
</td>
<td>
disable the fix for bug 1402161
</td>
</tr>
<tr>
<td>
_disable_selftune_checkpointing
</td>
<td>
FALSE
</td>
<td>
Disable self-tune checkpointing
</td>
</tr>
<tr>
<td>
_disable_streams_pool_auto_tuning
</td>
<td>
FALSE
</td>
<td>
disable streams pool auto tuning
</td>
</tr>
<tr>
<td>
_disable_system_state
</td>
<td>
4294967294
</td>
<td>
disable system state dump
</td>
</tr>
<tr>
<td>
_disable_txn_alert
</td>
<td>
0
</td>
<td>
disable txn layer alert
</td>
</tr>
<tr>
<td>
_discrete_transactions_enabled
</td>
<td>
FALSE
</td>
<td>
enable OLTP mode
</td>
</tr>
<tr>
<td>
_dispatcher_rate_scale
</td>
<td>
&nbsp;
</td>
<td>
scale to display rate statistic (100ths of a
second)
</td>
</tr>
<tr>
<td>
_dispatcher_rate_ttl
</td>
<td>
&nbsp;
</td>
<td>
time-to-live for rate statistic (100ths of a
second)
</td>
</tr>
<tr>
<td>
_distinct_view_unnesting
</td>
<td>
FALSE
</td>
<td>
enables unnesting of in subquery into distinc
t view
</td>
</tr>
<tr>
<td>
_distributed_recovery_connection_hold_time
</td>
<td>
200
</td>
<td>
number of seconds RECO holds outbound connect
ions open
</td>
</tr>
<tr>
<td>
_dlm_send_timeout
</td>
<td>
30000
</td>
<td>
DLM send timeout value
</td>
</tr>
<tr>
<td>
_dlmtrace
</td>
<td>
&nbsp;
</td>
<td>
Trace string of global enqueue type(s)
</td>
</tr>
<tr>
<td>
_dm_max_shared_pool_pct
</td>
<td>
1
</td>
<td>
max percentage of the shared pool to use for
a mining model
</td>
</tr>
<tr>
<td>
_dml_monitoring_enabled
</td>
<td>
TRUE
</td>
<td>
enable modification monitoring
</td>
</tr>
<tr>
<td>
_domain_index_batch_size
</td>
<td>
2000
</td>
<td>
maximum number of rows from one call to domai
n index fetch routine
</td>
</tr>
<tr>
<td>
_domain_index_dml_batch_size
</td>
<td>
200
</td>
<td>
maximum number of rows for one call to domain
 index dml routines
</td>
</tr>
<tr>
<td>
_drop_table_granule
</td>
<td>
256
</td>
<td>
drop_table_granule
</td>
</tr>
<tr>
<td>
_drop_table_optimization_enabled
</td>
<td>
TRUE
</td>
<td>
reduce SGA memory use during drop of a partit
ioned table
</td>
</tr>
<tr>
<td>
_ds_iocount_iosize
</td>
<td>
6553664
</td>
<td>
Dynamic Sampling Service defaults: #IOs and I
O Size
</td>
</tr>
<tr>
<td>
_dss_cache_flush
</td>
<td>
FALSE
</td>
<td>
enable full cache flush for parallel executio
n
</td>
</tr>
<tr>
<td>
_dtree_area_size
</td>
<td>
131072
</td>
<td>
size of Decision Tree Classification work are
a
</td>
</tr>
<tr>
<td>
_dtree_binning_enabled
</td>
<td>
TRUE
</td>
<td>
Decision Tree Binning Enabled
</td>
</tr>
<tr>
<td>
_dtree_bintest_id
</td>
<td>
0
</td>
<td>
Decision Tree Binning Test ID
</td>
</tr>
<tr>
<td>
_dtree_compressbmp_enabled
</td>
<td>
TRUE
</td>
<td>
Decision Tree Using Compressed Bitmaps Enable
d
</td>
</tr>
<tr>
<td>
_dtree_max_surrogates
</td>
<td>
1
</td>
<td>
maximum number of surrogates
</td>
</tr>
<tr>
<td>
_dtree_pruning_enabled
</td>
<td>
TRUE
</td>
<td>
Decision Tree Pruning Enabled
</td>
</tr>
<tr>
<td>
_dummy_instance
</td>
<td>
FALSE
</td>
<td>
dummy instance started by RMAN
</td>
</tr>
<tr>
<td>
_dump_common_subexpressions
</td>
<td>
FALSE
</td>
<td>
dump common subexpressions
</td>
</tr>
<tr>
<td>
_dump_connect_by_loop_data
</td>
<td>
FALSE
</td>
<td>
dump connect by loop error message into trc f
ile
</td>
</tr>
<tr>
<td>
_dump_cursor_heap_sizes
</td>
<td>
FALSE
</td>
<td>
dump comp/exec heap sizes to tryace file
</td>
</tr>
<tr>
<td>
_dump_interval_limit
</td>
<td>
120
</td>
<td>
trace dump time interval limit (in seconds)
</td>
</tr>
<tr>
<td>
_dump_max_limit
</td>
<td>
5
</td>
<td>
max number of dump within dump interval
</td>
</tr>
<tr>
<td>
_dump_qbc_tree
</td>
<td>
0
</td>
<td>
dump top level query parse tree to trace
</td>
</tr>
<tr>
<td>
_dump_rcvr_ipc
</td>
<td>
TRUE
</td>
<td>
if TRUE enables IPC dump at instance eviction
 time
</td>
</tr>
<tr>
<td>
_dump_system_state_scope
</td>
<td>
local
</td>
<td>
scope of sysstate dump during instance termin
ation
</td>
</tr>
<tr>
<td>
_dump_trace_scope
</td>
<td>
global
</td>
<td>
scope of trace dump during a process crash
</td>
</tr>
<tr>
<td>
_dynamic_rls_policies
</td>
<td>
TRUE
</td>
<td>
rls policies are dynamic
</td>
</tr>
<tr>
<td>
_dynamic_stats_threshold
</td>
<td>
30
</td>
<td>
delay threshold (in seconds) between sending
statistics messages
</td>
</tr>
<tr>
<td>
_eliminate_common_subexpr
</td>
<td>
TRUE
</td>
<td>
enables elimination of common sub-expressions
</td>
</tr>
<tr>
<td>
_enable_NUMA_optimization
</td>
<td>
TRUE
</td>
<td>
Enable NUMA specific optimizations
</td>
</tr>
<tr>
<td>
_enable_block_level_transaction_recovery
</td>
<td>
TRUE
</td>
<td>
enable block level recovery
</td>
</tr>
<tr>
<td>
_enable_cscn_caching
</td>
<td>
FALSE
</td>
<td>
enable commit SCN caching for all transaction
s
</td>
</tr>
<tr>
<td>
_enable_default_affinity
</td>
<td>
0
</td>
<td>
to enable default implementation of affinity
osds
</td>
</tr>
<tr>
<td>
_enable_dml_lock_escalation
</td>
<td>
TRUE
</td>
<td>
enable dml lock escalation against partitione
d tables if TRUE
</td>
</tr>
<tr>
<td>
_enable_exchange_validation_using_check
</td>
<td>
TRUE
</td>
<td>
use check constraints on the table for valida
tion
</td>
</tr>
<tr>
<td>
_enable_fast_ref_after_mv_tbs
</td>
<td>
FALSE
</td>
<td>
enable fast refresh after move tablespace
</td>
</tr>
<tr>
<td>
_enable_hash_overflow
</td>
<td>
FALSE
</td>
<td>
TRUE - enable hash cluster overflow based on
SIZE
</td>
</tr>
<tr>
<td>
_enable_hwm_sync
</td>
<td>
TRUE
</td>
<td>
enable HWM synchronization
</td>
</tr>
<tr>
<td>
_enable_kgh_policy
</td>
<td>
FALSE
</td>
<td>
temporary to disable/enable kgh policy
</td>
</tr>
<tr>
<td>
_enable_list_io
</td>
<td>
FALSE
</td>
<td>
Enable List I/O
</td>
</tr>
<tr>
<td>
_enable_nativenet_tcpip
</td>
<td>
FALSE
</td>
<td>
Enable skgxp driver usage for native net
</td>
</tr>
<tr>
<td>
_enable_refresh_schedule
</td>
<td>
TRUE
</td>
<td>
enable or disable MV refresh scheduling (reve
rt to 9.2 behavior)
</td>
</tr>
<tr>
<td>
_enable_reliable_latch_waits
</td>
<td>
TRUE
</td>
<td>
Enable reliable latch waits
</td>
</tr>
<tr>
<td>
_enable_rlb
</td>
<td>
TRUE
</td>
<td>
enable RLB metrics processing
</td>
</tr>
<tr>
<td>
_enable_tablespace_alerts
</td>
<td>
TRUE
</td>
<td>
enable tablespace alerts
</td>
</tr>
<tr>
<td>
_enable_type_dep_selectivity
</td>
<td>
TRUE
</td>
<td>
enable type dependent selectivity estimates
</td>
</tr>
<tr>
<td>
_enqueue_debug_multi_instance
</td>
<td>
FALSE
</td>
<td>
debug enqueue multi instance
</td>
</tr>
<tr>
<td>
_enqueue_hash
</td>
<td>
155
</td>
<td>
enqueue hash table length
</td>
</tr>
<tr>
<td>
_enqueue_hash_chain_latches
</td>
<td>
2
</td>
<td>
enqueue hash chain latches
</td>
</tr>
<tr>
<td>
_enqueue_locks
</td>
<td>
990
</td>
<td>
locks for managed enqueues
</td>
</tr>
<tr>
<td>
_enqueue_resources
</td>
<td>
484
</td>
<td>
resources for enqueues
</td>
</tr>
<tr>
<td>
_expand_aggregates
</td>
<td>
TRUE
</td>
<td>
expand aggregates
</td>
</tr>
<tr>
<td>
_explain_rewrite_mode
</td>
<td>
FALSE
</td>
<td>
allow additional messages to be generated dur
ing explain rewrite
</td>
</tr>
<tr>
<td>
_extended_pruning_enabled
</td>
<td>
TRUE
</td>
<td>
do runtime pruning in iterator if set to TRUE
</td>
</tr>
<tr>
<td>
_fair_remote_cvt
</td>
<td>
FALSE
</td>
<td>
if TRUE enables fair remote convert
</td>
</tr>
<tr>
<td>
_fairness_threshold
</td>
<td>
4
</td>
<td>
number of times to CR serve before downgradin
g lock
</td>
</tr>
<tr>
<td>
_fast_dual_enabled
</td>
<td>
TRUE
</td>
<td>
enable/disable fast dual
</td>
</tr>
<tr>
<td>
_fast_full_scan_enabled
</td>
<td>
TRUE
</td>
<td>
enable/disable index fast full scan
</td>
</tr>
<tr>
<td>
_fast_start_instance_recovery_target
</td>
<td>
0
</td>
<td>
cluster availability target time in RAC envir
onment
</td>
</tr>
<tr>
<td>
_fic_algorithm_set
</td>
<td>
automatic
</td>
<td>
Set Frequent Itemset Counting Algorithm
</td>
</tr>
<tr>
<td>
_fic_area_size
</td>
<td>
131072
</td>
<td>
size of Frequent Itemset Counting work area
</td>
</tr>
<tr>
<td>
_fic_max_length
</td>
<td>
20
</td>
<td>
Frequent Itemset Counting Maximum Itemset Len
gth
</td>
</tr>
<tr>
<td>
_fic_min_bmsize
</td>
<td>
1024
</td>
<td>
Frequent Itemset Counting Minimum BITMAP Size
</td>
</tr>
<tr>
<td>
_fic_outofmem_candidates
</td>
<td>
FALSE
</td>
<td>
Frequent Itemset Counting Out Of Memory Candi
dates Generation
</td>
</tr>
<tr>
<td>
_fifth_spare_parameter
</td>
<td>
&nbsp;
</td>
<td>
fifth spare parameter - string
</td>
</tr>
<tr>
<td>
_filemap_dir
</td>
<td>
&nbsp;
</td>
<td>
FILEMAP directory
</td>
</tr>
<tr>
<td>
_first_spare_parameter
</td>
<td>
&nbsp;
</td>
<td>
first spare parameter - integer
</td>
</tr>
<tr>
<td>
_flashback_allow_noarchivelog
</td>
<td>
FALSE
</td>
<td>
Allow enabling flashback on noarchivelog data
base
</td>
</tr>
<tr>
<td>
_flashback_barrier_interval
</td>
<td>
1800
</td>
<td>
Flashback barrier interval in seconds
</td>
</tr>
<tr>
<td>
_flashback_copy_latches
</td>
<td>
10
</td>
<td>
Number of flashback copy latches
</td>
</tr>
<tr>
<td>
_flashback_fuzzy_barrier
</td>
<td>
TRUE
</td>
<td>
Use flashback fuzzy barrier
</td>
</tr>
<tr>
<td>
_flashback_generation_buffer_size
</td>
<td>
8388608
</td>
<td>
flashback generation buffer size
</td>
</tr>
<tr>
<td>
_flashback_hint_barrier_percent
</td>
<td>
20
</td>
<td>
Flashback hint barrier percent
</td>
</tr>
<tr>
<td>
_flashback_log_io_error_behavior
</td>
<td>
0
</td>
<td>
Specify Flashback log I/O error behavior
</td>
</tr>
<tr>
<td>
_flashback_log_min_size
</td>
<td>
100
</td>
<td>
Minimum flashback log size
</td>
</tr>
<tr>
<td>
_flashback_log_size
</td>
<td>
1000
</td>
<td>
Flashback log size
</td>
</tr>
<tr>
<td>
_flashback_logfile_enqueue_timeout
</td>
<td>
600
</td>
<td>
flashback logfile enqueue timeout for opens
</td>
</tr>
<tr>
<td>
_flashback_max_log_size
</td>
<td>
0
</td>
<td>
Maximum flashback log size in bytes (OS limit
)
</td>
</tr>
<tr>
<td>
_flashback_max_n_log_per_thread
</td>
<td>
2048
</td>
<td>
Maximum number of flashback logs per flashbac
k thread
</td>
</tr>
<tr>
<td>
_flashback_n_log_per_thread
</td>
<td>
128
</td>
<td>
Desired number of flashback logs per flashbac
k thread
</td>
</tr>
<tr>
<td>
_flashback_standby_barrier_interval
</td>
<td>
1800
</td>
<td>
Flashback standby barrier interval in seconds
</td>
</tr>
<tr>
<td>
_flashback_verbose_info
</td>
<td>
FALSE
</td>
<td>
Print verbose information about flashback dat
abase
</td>
</tr>
<tr>
<td>
_flashback_write_size_qm
</td>
<td>
4
</td>
<td>
Desired flashback write size in quarter MB
</td>
</tr>
<tr>
<td>
_force_datefold_trunc
</td>
<td>
FALSE
</td>
<td>
force use of trunc for datefolding rewrite
</td>
</tr>
<tr>
<td>
_force_rewrite_enable
</td>
<td>
FALSE
</td>
<td>
control new query rewrite features
</td>
</tr>
<tr>
<td>
_force_temptables_for_gsets
</td>
<td>
FALSE
</td>
<td>
executes concatenation of rollups using temp
tables
</td>
</tr>
<tr>
<td>
_fourth_spare_parameter
</td>
<td>
&nbsp;
</td>
<td>
fourth spare parameter - string
</td>
</tr>
<tr>
<td>
_full_pwise_join_enabled
</td>
<td>
TRUE
</td>
<td>
enable full partition-wise join when TRUE
</td>
</tr>
<tr>
<td>
_gby_hash_aggregation_enabled
</td>
<td>
TRUE
</td>
<td>
enable group-by and aggregation using hash sc
heme
</td>
</tr>
<tr>
<td>
_gby_onekey_enabled
</td>
<td>
TRUE
</td>
<td>
enable use of one comparison of all group by
keys
</td>
</tr>
<tr>
<td>
_gc_affinity_limit
</td>
<td>
50
</td>
<td>
dynamic affinity limit
</td>
</tr>
<tr>
<td>
_gc_affinity_minimum
</td>
<td>
1200
</td>
<td>
dynamic affinity minimum activity per minute
</td>
</tr>
<tr>
<td>
_gc_affinity_time
</td>
<td>
10
</td>
<td>
if non zero, enable dynamic object affinity
</td>
</tr>
<tr>
<td>
_gc_check_bscn
</td>
<td>
TRUE
</td>
<td>
if TRUE, check for stale blocks
</td>
</tr>
<tr>
<td>
_gc_coalesce_recovery_reads
</td>
<td>
TRUE
</td>
<td>
if TRUE, coalesce recovery reads
</td>
</tr>
<tr>
<td>
_gc_defer_time
</td>
<td>
3
</td>
<td>
how long to defer down converts for hot buffe
rs
</td>
</tr>
<tr>
<td>
_gc_dynamic_affinity_locks
</td>
<td>
TRUE
</td>
<td>
if TRUE, get dynamic affinity locks
</td>
</tr>
<tr>
<td>
_gc_element_percent
</td>
<td>
103
</td>
<td>
global cache element percent
</td>
</tr>
<tr>
<td>
_gc_global_lru
</td>
<td>
AUTO
</td>
<td>
turn global lru off, make it automatic, or tu
rn it on
</td>
</tr>
<tr>
<td>
_gc_integrity_checks
</td>
<td>
1
</td>
<td>
set the integrity check level
</td>
</tr>
<tr>
<td>
_gc_keep_recovery_buffers
</td>
<td>
TRUE
</td>
<td>
if TRUE, make recovery buffers current
</td>
</tr>
<tr>
<td>
_gc_latches
</td>
<td>
8
</td>
<td>
number of latches per LMS process
</td>
</tr>
<tr>
<td>
_gc_maximum_bids
</td>
<td>
0
</td>
<td>
maximum number of bids which can be prepared
</td>
</tr>
<tr>
<td>
_gc_statistics
</td>
<td>
TRUE
</td>
<td>
if TRUE, kcl statistics are maintained
</td>
</tr>
<tr>
<td>
_gc_undo_affinity
</td>
<td>
TRUE
</td>
<td>
if TRUE, enable dynamic undo affinity
</td>
</tr>
<tr>
<td>
_gc_undo_affinity_locks
</td>
<td>
TRUE
</td>
<td>
if TRUE, get affinity locks for undo
</td>
</tr>
<tr>
<td>
_gc_use_cr
</td>
<td>
TRUE
</td>
<td>
if TRUE, allow CR pins on PI and WRITING buff
ers
</td>
</tr>
<tr>
<td>
_gc_vector_read
</td>
<td>
TRUE
</td>
<td>
if TRUE, vector read current buffers
</td>
</tr>
<tr>
<td>
_gcs_fast_reconfig
</td>
<td>
TRUE
</td>
<td>
if TRUE, enable fast reconfiguration for gcs
locks
</td>
</tr>
<tr>
<td>
_gcs_latches
</td>
<td>
0
</td>
<td>
number of gcs resource hash latches to be all
ocated per LMS process
</td>
</tr>
<tr>
<td>
_gcs_process_in_recovery
</td>
<td>
TRUE
</td>
<td>
if TRUE, process gcs requests during instance
 recovery
</td>
</tr>
<tr>
<td>
_gcs_resources
</td>
<td>
&nbsp;
</td>
<td>
number of gcs resources to be allocated
</td>
</tr>
<tr>
<td>
_gcs_shadow_locks
</td>
<td>
&nbsp;
</td>
<td>
number of pcm shadow locks to be allocated
</td>
</tr>
<tr>
<td>
_generalized_pruning_enabled
</td>
<td>
TRUE
</td>
<td>
controls extensions to partition pruning for
general predicates
</td>
</tr>
<tr>
<td>
_ges_dd_debug
</td>
<td>
TRUE
</td>
<td>
if TRUE enables GES deadlock detection debug
diagnostics
</td>
</tr>
<tr>
<td>
_ges_diagnostics
</td>
<td>
TRUE
</td>
<td>
if TRUE enables GES diagnostics
</td>
</tr>
<tr>
<td>
_ges_health_check
</td>
<td>
1
</td>
<td>
if greater than 0 enables GES system health c
heck
</td>
</tr>
<tr>
<td>
_groupby_nopushdown_cut_ratio
</td>
<td>
3
</td>
<td>
groupby nopushdown cut ratio
</td>
</tr>
<tr>
<td>
_groupby_orderby_combine
</td>
<td>
5000
</td>
<td>
groupby/orderby don't combine threshold
</td>
</tr>
<tr>
<td>
_gs_anti_semi_join_allowed
</td>
<td>
TRUE
</td>
<td>
enable anti/semi join for the GS query
</td>
</tr>
<tr>
<td>
_hang_analysis_num_call_stacks
</td>
<td>
3
</td>
<td>
hang analysis num call stacks
</td>
</tr>
<tr>
<td>
_hang_detection
</td>
<td>
0
</td>
<td>
Hang Management detection interval
</td>
</tr>
<tr>
<td>
_hard_protection
</td>
<td>
FALSE
</td>
<td>
if TRUE enable H.A.R.D specific format change
s
</td>
</tr>
<tr>
<td>
_hash_join_enabled
</td>
<td>
TRUE
</td>
<td>
enable/disable hash join
</td>
</tr>
<tr>
<td>
_hash_multiblock_io_count
</td>
<td>
0
</td>
<td>
number of blocks hash join will read/write at
 once
</td>
</tr>
<tr>
<td>
_high_server_threshold
</td>
<td>
0
</td>
<td>
high server thresholds
</td>
</tr>
<tr>
<td>
_hj_bit_filter_threshold
</td>
<td>
50
</td>
<td>
hash-join bit filtering threshold (0 always e
nabled)
</td>
</tr>
<tr>
<td>
_hwm_sync_threshold
</td>
<td>
10
</td>
<td>
HWM synchronization threshold in percentage
</td>
</tr>
<tr>
<td>
_idl_conventional_index_maintenance
</td>
<td>
TRUE
</td>
<td>
enable conventional index maintenance for ins
ert direct load
</td>
</tr>
<tr>
<td>
_idxrb_rowincr
</td>
<td>
100000000
</td>
<td>
proportionality constant for dop vs. rows in
index rebuild
</td>
</tr>
<tr>
<td>
_ignore_desc_in_index
</td>
<td>
FALSE
</td>
<td>
ignore DESC in indexes, sort those columns as
cending anyhow
</td>
</tr>
<tr>
<td>
_immediate_commit_propagation
</td>
<td>
TRUE
</td>
<td>
if TRUE, propagate commit SCN immediately
</td>
</tr>
<tr>
<td>
_improved_outerjoin_card
</td>
<td>
TRUE
</td>
<td>
improved outer-join cardinality calculation
</td>
</tr>
<tr>
<td>
_improved_row_length_enabled
</td>
<td>
TRUE
</td>
<td>
enable the improvements for computing the ave
rage row length
</td>
</tr>
<tr>
<td>
_imr_active
</td>
<td>
TRUE
</td>
<td>
Activate Instance Membership Recovery feature
</td>
</tr>
<tr>
<td>
_imr_disk_voting_interval
</td>
<td>
3
</td>
<td>
Maximum wait for IMR disk voting (seconds)
</td>
</tr>
<tr>
<td>
_imr_max_reconfig_delay
</td>
<td>
300
</td>
<td>
Maximum Reconfiguration delay (seconds)
</td>
</tr>
<tr>
<td>
_imr_splitbrain_res_wait
</td>
<td>
600
</td>
<td>
Maximum wait for split-brain resolution (seco
nds)
</td>
</tr>
<tr>
<td>
_imu_pools
</td>
<td>
3
</td>
<td>
in memory undo pools
</td>
</tr>
<tr>
<td>
_in_memory_undo
</td>
<td>
TRUE
</td>
<td>
Make in memory undo for top level transaction
s
</td>
</tr>
<tr>
<td>
_incremental_recovery_ckpt_min_batch
</td>
<td>
30
</td>
<td>
Minimum number of writes for incremental reco
very ckpt every 3 sec
</td>
</tr>
<tr>
<td>
_index_join_enabled
</td>
<td>
TRUE
</td>
<td>
enable the use of index joins
</td>
</tr>
<tr>
<td>
_index_prefetch_factor
</td>
<td>
100
</td>
<td>
index prefetching factor
</td>
</tr>
<tr>
<td>
_init_granule_interval
</td>
<td>
10
</td>
<td>
number of granules to process for deferred ca
che
</td>
</tr>
<tr>
<td>
_init_sql_file
</td>
<td>
%ORACLE_HOME%\RDBMS\ADMIN
\SQL.BSQ
</td>
<td>
File containing SQL statements to execute upo
n database creation
</td>
</tr>
<tr>
<td>
_inject_startup_fault
</td>
<td>
0
</td>
<td>
inject fault in the startup code
</td>
</tr>
<tr>
<td>
_insert_enable_hwm_brokered
</td>
<td>
TRUE
</td>
<td>
during parallel inserts high water marks are
brokered
</td>
</tr>
<tr>
<td>
_inst_locking_period
</td>
<td>
5
</td>
<td>
period an instance can retain a newly acquire
d level1 bitmap
</td>
</tr>
<tr>
<td>
_interconnect_checksum
</td>
<td>
TRUE
</td>
<td>
if TRUE, checksum interconnect blocks
</td>
</tr>
<tr>
<td>
_intrapart_pdml_enabled
</td>
<td>
TRUE
</td>
<td>
Enable intra-partition updates/deletes
</td>
</tr>
<tr>
<td>
_intrapart_pdml_randomlocal_enabled
</td>
<td>
TRUE
</td>
<td>
Enable intra-partition updates/deletes with r
andom local dist
</td>
</tr>
<tr>
<td>
_io_shared_pool_size
</td>
<td>
4194304
</td>
<td>
Size of I/O buffer pool from SGA
</td>
</tr>
<tr>
<td>
_io_slaves_disabled
</td>
<td>
FALSE
</td>
<td>
Do not use I/O slaves
</td>
</tr>
<tr>
<td>
_ior_serialize_fault
</td>
<td>
0
</td>
<td>
inject fault in the ior serialize code
</td>
</tr>
<tr>
<td>
_ioslave_batch_count
</td>
<td>
1
</td>
<td>
Per attempt IOs picked
</td>
</tr>
<tr>
<td>
_ioslave_issue_count
</td>
<td>
500
</td>
<td>
IOs issued before completion check
</td>
</tr>
<tr>
<td>
_job_queue_interval
</td>
<td>
5
</td>
<td>
Wakeup interval in seconds for job queue co-o
rdinator
</td>
</tr>
<tr>
<td>
_kcl_commit
</td>
<td>
TRUE
</td>
<td>
if TRUE, call kjbcommit
</td>
</tr>
<tr>
<td>
_kcl_conservative_log_flush
</td>
<td>
FALSE
</td>
<td>
if TRUE, conservatively log flush before CR s
erving
</td>
</tr>
<tr>
<td>
_kcl_debug
</td>
<td>
TRUE
</td>
<td>
if TRUE, record le history
</td>
</tr>
<tr>
<td>
_kcl_index_split
</td>
<td>
TRUE
</td>
<td>
if TRUE, reject pings on blocks in middle of
a split
</td>
</tr>
<tr>
<td>
_kcl_undo_grouping
</td>
<td>
32
</td>
<td>
grouping for undo block locks
</td>
</tr>
<tr>
<td>
_kcl_undo_locks
</td>
<td>
128
</td>
<td>
number of locks per undo segment
</td>
</tr>
<tr>
<td>
_kdbl_enable_post_allocation
</td>
<td>
FALSE
</td>
<td>
allocate dbas after populating data buffers
</td>
</tr>
<tr>
<td>
_keep_remote_column_size
</td>
<td>
FALSE
</td>
<td>
remote column size does not get modified
</td>
</tr>
<tr>
<td>
_kernel_message_network_driver
</td>
<td>
FALSE
</td>
<td>
kernel message network driver
</td>
</tr>
<tr>
<td>
_kffmap_hash_size
</td>
<td>
1024
</td>
<td>
size of kffmap_hash table
</td>
</tr>
<tr>
<td>
_kffmop_hash_size
</td>
<td>
2048
</td>
<td>
size of kffmop_hash table
</td>
</tr>
<tr>
<td>
_kghdsidx_count
</td>
<td>
1
</td>
<td>
max kghdsidx count
</td>
</tr>
<tr>
<td>
_kgl_bucket_count
</td>
<td>
9
</td>
<td>
index to the bucket count array
</td>
</tr>
<tr>
<td>
_kgl_fixed_extents
</td>
<td>
TRUE
</td>
<td>
fixed extent size for library cache memory al
locations
</td>
</tr>
<tr>
<td>
_kgl_hash_collision
</td>
<td>
FALSE
</td>
<td>
whether KGL hash collision is possible
</td>
</tr>
<tr>
<td>
_kgl_heap_size
</td>
<td>
1024
</td>
<td>
extent size for library cache heap 0
</td>
</tr>
<tr>
<td>
_kgl_keep_cache_pct
</td>
<td>
30
</td>
<td>
KGL keep cache minimum threshold
</td>
</tr>
<tr>
<td>
_kgl_keep_cache_retain_pct
</td>
<td>
20
</td>
<td>
KGL keep cache retain threshold
</td>
</tr>
<tr>
<td>
_kgl_large_heap_warning_threshold
</td>
<td>
2097152
</td>
<td>
maximum heap size before KGL writes warnings
to the alert log
</td>
</tr>
<tr>
<td>
_kgl_latch_count
</td>
<td>
0
</td>
<td>
number of library cache latches
</td>
</tr>
<tr>
<td>
_kgl_multi_instance_invalidation
</td>
<td>
TRUE
</td>
<td>
whether KGL to support multi-instance invalid
ations
</td>
</tr>
<tr>
<td>
_kgl_multi_instance_lock
</td>
<td>
TRUE
</td>
<td>
whether KGL to support multi-instance locks
</td>
</tr>
<tr>
<td>
_kgl_multi_instance_pin
</td>
<td>
TRUE
</td>
<td>
whether KGL to support multi-instance pins
</td>
</tr>
<tr>
<td>
_kgl_session_cached_objects
</td>
<td>
10
</td>
<td>
maximum length of the KGL object cache lru
</td>
</tr>
<tr>
<td>
_kgl_time_to_wait_for_locks
</td>
<td>
15
</td>
<td>
time to wait for locks and pins before timing
 out
</td>
</tr>
<tr>
<td>
_kglsim_maxmem_percent
</td>
<td>
5
</td>
<td>
max percentage of shared pool size to be used
 for KGL advice
</td>
</tr>
<tr>
<td>
_kgx_latches
</td>
<td>
512
</td>
<td>
# of mutex latches if CAS is not supported.
</td>
</tr>
<tr>
<td>
_kill_java_threads_on_eoc
</td>
<td>
FALSE
</td>
<td>
Kill Java threads and do sessionspace migrati
on at end of call
</td>
</tr>
<tr>
<td>
_kkfi_trace
</td>
<td>
FALSE
</td>
<td>
trace expression substitution
</td>
</tr>
<tr>
<td>
_kks_use_mutex_pin
</td>
<td>
FALSE
</td>
<td>
Turning on this will make KKS use mutex for c
ursor pins.
</td>
</tr>
<tr>
<td>
_kolfuseslf
</td>
<td>
FALSE
</td>
<td>
allow kolf to use slffopen
</td>
</tr>
<tr>
<td>
_kql_subheap_trace
</td>
<td>
0
</td>
<td>
tracing level for library cache subheap level
 pins
</td>
</tr>
<tr>
<td>
_ksd_test_param
</td>
<td>
999
</td>
<td>
KSD test parmeter
</td>
</tr>
<tr>
<td>
_ksdxdocmd_default_timeout_ms
</td>
<td>
30000
</td>
<td>
default timeout for internal oradebug command
s
</td>
</tr>
<tr>
<td>
_ksdxw_cini_flg
</td>
<td>
0
</td>
<td>
ksdxw context initialization flag
</td>
</tr>
<tr>
<td>
_ksdxw_nbufs
</td>
<td>
1000
</td>
<td>
ksdxw number of buffers in buffered mode
</td>
</tr>
<tr>
<td>
_ksdxw_num_pgw
</td>
<td>
10
</td>
<td>
number of watchpoints on a per-process basis
</td>
</tr>
<tr>
<td>
_ksdxw_num_sgw
</td>
<td>
10
</td>
<td>
number of watchpoints to be shared by all pro
cesses
</td>
</tr>
<tr>
<td>
_ksdxw_stack_depth
</td>
<td>
4
</td>
<td>
number of PCs to collect in the stack when wa
tchpoint is hit
</td>
</tr>
<tr>
<td>
_kse_die_timeout
</td>
<td>
60000
</td>
<td>
amount of time a dying process is spared by P
MON (in centi-secs)
</td>
</tr>
<tr>
<td>
_kse_pc_table_size
</td>
<td>
256
</td>
<td>
kse pc table cache size
</td>
</tr>
<tr>
<td>
_ksfd_verify_write
</td>
<td>
FALSE
</td>
<td>
verify asynchronous writes issued through ksf
d
</td>
</tr>
<tr>
<td>
_ksi_trace
</td>
<td>
&nbsp;
</td>
<td>
KSI trace string of lock type(s)
</td>
</tr>
<tr>
<td>
_ksmg_granule_locking_status
</td>
<td>
1
</td>
<td>
granule locking status
</td>
</tr>
<tr>
<td>
_ksmg_granule_size
</td>
<td>
4194304
</td>
<td>
granule size in bytes
</td>
</tr>
<tr>
<td>
_ksmg_lock_check_interval
</td>
<td>
&nbsp;
</td>
<td>
timeout action interval in minutes
</td>
</tr>
<tr>
<td>
_ksmg_lock_reacquire_count
</td>
<td>
5
</td>
<td>
repeat count for acquisition of locks
</td>
</tr>
<tr>
<td>
_ksu_diag_kill_time
</td>
<td>
5
</td>
<td>
number of seconds ksuitm waits before killing
 diag
</td>
</tr>
<tr>
<td>
_ksuitm_dont_kill_dumper
</td>
<td>
FALSE
</td>
<td>
delay inst. termination to allow processes to
 dump
</td>
</tr>
<tr>
<td>
_ksxp_diagmode
</td>
<td>
OFF
</td>
<td>
set to OFF to disable automatic slowsend diag
nostics
</td>
</tr>
<tr>
<td>
_ksxp_reporting_process
</td>
<td>
LMD0
</td>
<td>
reporting process for KSXP
</td>
</tr>
<tr>
<td>
_ksxp_send_timeout
</td>
<td>
300
</td>
<td>
set timeout for sends queued with the inter-i
nstance IPC
</td>
</tr>
<tr>
<td>
_ktc_debug
</td>
<td>
0
</td>
<td>
for ktc debug
</td>
</tr>
<tr>
<td>
_ktc_latches
</td>
<td>
0
</td>
<td>
number of ktc latches
</td>
</tr>
<tr>
<td>
_ktu_latches
</td>
<td>
0
</td>
<td>
number of KTU latches
</td>
</tr>
<tr>
<td>
_ku_trace
</td>
<td>
none
</td>
<td>
datapump trace parameter
</td>
</tr>
<tr>
<td>
_large_pool_min_alloc
</td>
<td>
16000
</td>
<td>
minimum allocation size in bytes for the larg
e allocation pool
</td>
</tr>
<tr>
<td>
_last_allocation_period
</td>
<td>
5
</td>
<td>
period over which an instance can retain an a
ctive level1 bitmap
</td>
</tr>
<tr>
<td>
_latch_class_0
</td>
<td>
&nbsp;
</td>
<td>
latch class 0
</td>
</tr>
<tr>
<td>
_latch_class_1
</td>
<td>
&nbsp;
</td>
<td>
latch class 1
</td>
</tr>
<tr>
<td>
_latch_class_2
</td>
<td>
&nbsp;
</td>
<td>
latch class 2
</td>
</tr>
<tr>
<td>
_latch_class_3
</td>
<td>
&nbsp;
</td>
<td>
latch class 3
</td>
</tr>
<tr>
<td>
_latch_class_4
</td>
<td>
&nbsp;
</td>
<td>
latch class 4
</td>
</tr>
<tr>
<td>
_latch_class_5
</td>
<td>
&nbsp;
</td>
<td>
latch class 5
</td>
</tr>
<tr>
<td>
_latch_class_6
</td>
<td>
&nbsp;
</td>
<td>
latch class 6
</td>
</tr>
<tr>
<td>
_latch_class_7
</td>
<td>
&nbsp;
</td>
<td>
latch class 7
</td>
</tr>
<tr>
<td>
_latch_classes
</td>
<td>
&nbsp;
</td>
<td>
latch classes override
</td>
</tr>
<tr>
<td>
_latch_miss_stat_sid
</td>
<td>
0
</td>
<td>
Sid of process for which to collect latch sta
ts
</td>
</tr>
<tr>
<td>
_latch_recovery_alignment
</td>
<td>
998
</td>
<td>
align latch recovery structures
</td>
</tr>
<tr>
<td>
_ldr_io_size
</td>
<td>
262144
</td>
<td>
size of write IOs used during a load operatio
n
</td>
</tr>
<tr>
<td>
_left_nested_loops_random
</td>
<td>
TRUE
</td>
<td>
enable random distribution method for left of
 nestedloops
</td>
</tr>
<tr>
<td>
_lgwr_async_broadcasts
</td>
<td>
TRUE
</td>
<td>
LGWR Asynchronous Broadcasts enabling boolean
 flag
</td>
</tr>
<tr>
<td>
_lgwr_async_io
</td>
<td>
FALSE
</td>
<td>
LGWR Asynchronous IO enabling boolean flag
</td>
</tr>
<tr>
<td>
_lgwr_delay_write
</td>
<td>
FALSE
</td>
<td>
LGWR write delay for debugging
</td>
</tr>
<tr>
<td>
_lgwr_io_slaves
</td>
<td>
0
</td>
<td>
LGWR I/O slaves
</td>
</tr>
<tr>
<td>
_lgwr_max_ns_wt
</td>
<td>
1
</td>
<td>
Maximum wait time for lgwr to allow NetServer
 to progress
</td>
</tr>
<tr>
<td>
_lgwr_ns_nl_max
</td>
<td>
1000
</td>
<td>
Variable to simulate network latency or buffe
r threshold
</td>
</tr>
<tr>
<td>
_lgwr_ns_nl_min
</td>
<td>
500
</td>
<td>
Variable to simulate network latency or buffe
r threshold
</td>
</tr>
<tr>
<td>
_lgwr_ns_sim_err
</td>
<td>
0
</td>
<td>
Variable to simulate errors lgwrns
</td>
</tr>
<tr>
<td>
_lgwr_ta_sim_err
</td>
<td>
0
</td>
<td>
Variable to simulate errors lgwr true async
</td>
</tr>
<tr>
<td>
_library_cache_advice
</td>
<td>
TRUE
</td>
<td>
whether KGL advice should be turned on
</td>
</tr>
<tr>
<td>
_lightweight_hdrs
</td>
<td>
TRUE
</td>
<td>
Lightweight headers for redo
</td>
</tr>
<tr>
<td>
_like_with_bind_as_equality
</td>
<td>
FALSE
</td>
<td>
treat LIKE predicate with bind as an equality
 predicate
</td>
</tr>
<tr>
<td>
_lm_activate_lms_threshold
</td>
<td>
100
</td>
<td>
threshold value to activate an additional lms
</td>
</tr>
<tr>
<td>
_lm_cache_lvl0_cleanup
</td>
<td>
0
</td>
<td>
how often to cleanup level 0 cache res (in se
c)
</td>
</tr>
<tr>
<td>
_lm_cache_res_cleanup
</td>
<td>
25
</td>
<td>
percentage of cached resources should be clea
nup
</td>
</tr>
<tr>
<td>
_lm_cache_res_type
</td>
<td>
TMHWDI
</td>
<td>
cache resource: string of lock types(s)
</td>
</tr>
<tr>
<td>
_lm_checksum_batch_msg
</td>
<td>
FALSE
</td>
<td>
GES checksum batch messages
</td>
</tr>
<tr>
<td>
_lm_contiguous_res_count
</td>
<td>
128
</td>
<td>
number of contiguous blocks that will hash to
 the same HV bucket
</td>
</tr>
<tr>
<td>
_lm_dd_interval
</td>
<td>
60
</td>
<td>
dd time interval in seconds
</td>
</tr>
<tr>
<td>
_lm_dd_scan_interval
</td>
<td>
5
</td>
<td>
dd scan interval in seconds
</td>
</tr>
<tr>
<td>
_lm_drm_max_requests
</td>
<td>
100
</td>
<td>
dynamic remastering maximum affinity requests
 processed together
</td>
</tr>
<tr>
<td>
_lm_drm_window
</td>
<td>
0
</td>
<td>
dynamic remastering bucket window size
</td>
</tr>
<tr>
<td>
_lm_drm_xlatch
</td>
<td>
0
</td>
<td>
dynamic remastering forced exclusive latches
</td>
</tr>
<tr>
<td>
_lm_dynamic_lms
</td>
<td>
FALSE
</td>
<td>
dynamic lms invocation
</td>
</tr>
<tr>
<td>
_lm_dynamic_load
</td>
<td>
TRUE
</td>
<td>
dynamic load adjustment
</td>
</tr>
<tr>
<td>
_lm_dynamic_remastering
</td>
<td>
FALSE
</td>
<td>
if TRUE enables dynamic remastering
</td>
</tr>
<tr>
<td>
_lm_enq_lock_freelist
</td>
<td>
&nbsp;
</td>
<td>
Number of ges enqueue element freelist
</td>
</tr>
<tr>
<td>
_lm_enq_rcfg
</td>
<td>
TRUE
</td>
<td>
if TRUE enables enqueue reconfiguration
</td>
</tr>
<tr>
<td>
_lm_enqueue_freelist
</td>
<td>
3
</td>
<td>
Number of enqueue freelist
</td>
</tr>
<tr>
<td>
_lm_file_affinity
</td>
<td>
&nbsp;
</td>
<td>
mapping between file id and master instance n
umber
</td>
</tr>
<tr>
<td>
_lm_global_posts
</td>
<td>
TRUE
</td>
<td>
if TRUE deliver global posts to remote nodes
</td>
</tr>
<tr>
<td>
_lm_lmd_waittime
</td>
<td>
8
</td>
<td>
default wait time for lmd in centiseconds
</td>
</tr>
<tr>
<td>
_lm_lms
</td>
<td>
0
</td>
<td>
number of background gcs server processes to
start
</td>
</tr>
<tr>
<td>
_lm_lms_waittime
</td>
<td>
8
</td>
<td>
default wait time for lms in centiseconds
</td>
</tr>
<tr>
<td>
_lm_locks
</td>
<td>
12000
</td>
<td>
number of enqueues configured for cluster dat
abase
</td>
</tr>
<tr>
<td>
_lm_master_weight
</td>
<td>
1
</td>
<td>
master resource weight for this instance
</td>
</tr>
<tr>
<td>
_lm_max_lms
</td>
<td>
0
</td>
<td>
max. number of background global cache server
 processes
</td>
</tr>
<tr>
<td>
_lm_min_lms
</td>
<td>
0
</td>
<td>
min. number of background global cache server
 processes
</td>
</tr>
<tr>
<td>
_lm_msg_batch_size
</td>
<td>
0
</td>
<td>
GES batch message size
</td>
</tr>
<tr>
<td>
_lm_msg_cache_thresholds
</td>
<td>
&nbsp;
</td>
<td>
GES message buffer caching threshold
</td>
</tr>
<tr>
<td>
_lm_msg_cleanup_interval
</td>
<td>
3000
</td>
<td>
GES message buffer cleanup interval time
</td>
</tr>
<tr>
<td>
_lm_node_join_opt
</td>
<td>
FALSE
</td>
<td>
cluster database node join optimization in re
config
</td>
</tr>
<tr>
<td>
_lm_non_fault_tolerant
</td>
<td>
FALSE
</td>
<td>
disable cluster database fault-tolerance mode
</td>
</tr>
<tr>
<td>
_lm_num_pcmhv_latches
</td>
<td>
0
</td>
<td>
number of latches covering the PCM HV buckets
 in cgs
</td>
</tr>
<tr>
<td>
_lm_num_pt_buckets
</td>
<td>
4096
</td>
<td>
number of buckets in the object affinity hash
 table
</td>
</tr>
<tr>
<td>
_lm_num_pt_latches
</td>
<td>
128
</td>
<td>
number of latches in the object affinity hash
 table
</td>
</tr>
<tr>
<td>
_lm_proc_freeze_timeout
</td>
<td>
300
</td>
<td>
reconfiguration: process freeze timeout
</td>
</tr>
<tr>
<td>
_lm_process_batching
</td>
<td>
TRUE
</td>
<td>
GES implicit process batching for IPC message
s
</td>
</tr>
<tr>
<td>
_lm_procs
</td>
<td>
320
</td>
<td>
number of client processes configured for clu
ster database
</td>
</tr>
<tr>
<td>
_lm_rcfg_timeout
</td>
<td>
180000
</td>
<td>
Reconfiguration timeout
</td>
</tr>
<tr>
<td>
_lm_rcv_buffer_size
</td>
<td>
32768
</td>
<td>
the size of receive buffer
</td>
</tr>
<tr>
<td>
_lm_res_hash_bucket
</td>
<td>
0
</td>
<td>
number of resource hash buckets
</td>
</tr>
<tr>
<td>
_lm_res_part
</td>
<td>
128
</td>
<td>
number of resource partition configured for g
cs
</td>
</tr>
<tr>
<td>
_lm_ress
</td>
<td>
6000
</td>
<td>
number of resources configured for cluster da
tabase
</td>
</tr>
<tr>
<td>
_lm_send_buffers
</td>
<td>
10000
</td>
<td>
number of cluster database send buffers
</td>
</tr>
<tr>
<td>
_lm_send_mode
</td>
<td>
auto
</td>
<td>
GES send mode
</td>
</tr>
<tr>
<td>
_lm_send_queue_batching
</td>
<td>
TRUE
</td>
<td>
GES send queue message batching
</td>
</tr>
<tr>
<td>
_lm_send_queue_length
</td>
<td>
5000
</td>
<td>
GES send queue maximum length
</td>
</tr>
<tr>
<td>
_lm_sendproxy_reserve
</td>
<td>
25
</td>
<td>
GES percentage of send proxy reserve of send
tickets
</td>
</tr>
<tr>
<td>
_lm_share_lock_opt
</td>
<td>
FALSE
</td>
<td>
if TRUE enables share lock optimization
</td>
</tr>
<tr>
<td>
_lm_sq_batch_factor
</td>
<td>
2
</td>
<td>
GES send queue minimum batching factor
</td>
</tr>
<tr>
<td>
_lm_sq_batch_type
</td>
<td>
auto
</td>
<td>
GES send queue batching mechanism
</td>
</tr>
<tr>
<td>
_lm_sq_batch_waittick
</td>
<td>
3
</td>
<td>
GES send queue batching waittime in tick
</td>
</tr>
<tr>
<td>
_lm_sync_timeout
</td>
<td>
&nbsp;
</td>
<td>
Synchronization timeout for DLM reconfigurati
on steps
</td>
</tr>
<tr>
<td>
_lm_ticket_active_sendback
</td>
<td>
&nbsp;
</td>
<td>
Flow control ticket active sendback threshold
</td>
</tr>
<tr>
<td>
_lm_tickets
</td>
<td>
1000
</td>
<td>
GES messaging tickets
</td>
</tr>
<tr>
<td>
_lm_tx_delta
</td>
<td>
16
</td>
<td>
TX lock localization delta
</td>
</tr>
<tr>
<td>
_lm_validate_resource_type
</td>
<td>
FALSE
</td>
<td>
if TRUE enables resource name validation
</td>
</tr>
<tr>
<td>
_lm_xids
</td>
<td>
352
</td>
<td>
number of transaction IDs configured for clus
ter database
</td>
</tr>
<tr>
<td>
_load_without_compile
</td>
<td>
none
</td>
<td>
Load PL/SQL or Database objects without compi
lation
</td>
</tr>
<tr>
<td>
_local_communication_costing_enabled
</td>
<td>
TRUE
</td>
<td>
enable local communication costing when TRUE
</td>
</tr>
<tr>
<td>
_local_communication_ratio
</td>
<td>
50
</td>
<td>
set the ratio between global and local commun
ication (0..100)
</td>
</tr>
<tr>
<td>
_lock_sga_areas
</td>
<td>
0
</td>
<td>
Lock specified areas of the SGA in physical m
emory
</td>
</tr>
<tr>
<td>
_log_archive_avoid_memcpy
</td>
<td>
TRUE
</td>
<td>
log archive avoid memcpy
</td>
</tr>
<tr>
<td>
_log_archive_buffer_size
</td>
<td>
2048
</td>
<td>
Size of each archival buffer in log file bloc
ks
</td>
</tr>
<tr>
<td>
_log_archive_buffers
</td>
<td>
4
</td>
<td>
Number of buffers to allocate for archiving
</td>
</tr>
<tr>
<td>
_log_archive_callout
</td>
<td>
&nbsp;
</td>
<td>
archival callout
</td>
</tr>
<tr>
<td>
_log_archive_compress_enable
</td>
<td>
FALSE
</td>
<td>
Bypass database rules for enabling archivelog
 compression
</td>
</tr>
<tr>
<td>
_log_archive_delta_sync_wait
</td>
<td>
0
</td>
<td>
iterative sleep time in centiseconds seconds
when SYNC=PARALLEL
</td>
</tr>
<tr>
<td>
_log_archive_net_timeout
</td>
<td>
0
</td>
<td>
maximum network wait time in seconds when SYN
C=PARALLEL
</td>
</tr>
<tr>
<td>
_log_archive_network_redo_size
</td>
<td>
10
</td>
<td>
Log archive network redo buffer size used by
ARCH
</td>
</tr>
<tr>
<td>
_log_archive_prot_auto_demote
</td>
<td>
FALSE
</td>
<td>
log archive protection auto demotion
</td>
</tr>
<tr>
<td>
_log_archive_security_enabled
</td>
<td>
TRUE
</td>
<td>
log archive security enabled
</td>
</tr>
<tr>
<td>
_log_blocks_during_backup
</td>
<td>
TRUE
</td>
<td>
log block images when changed during backup
</td>
</tr>
<tr>
<td>
_log_buffers_corrupt
</td>
<td>
FALSE
</td>
<td>
corrupt redo buffers before write
</td>
</tr>
<tr>
<td>
_log_buffers_debug
</td>
<td>
FALSE
</td>
<td>
debug redo buffers (slows things down)
</td>
</tr>
<tr>
<td>
_log_checkpoint_recovery_check
</td>
<td>
0
</td>
<td>
# redo blocks to verify after checkpoint
</td>
</tr>
<tr>
<td>
_log_committime_block_cleanout
</td>
<td>
FALSE
</td>
<td>
Log commit-time block cleanout
</td>
</tr>
<tr>
<td>
_log_debug_multi_instance
</td>
<td>
FALSE
</td>
<td>
debug redo multi instance code
</td>
</tr>
<tr>
<td>
_log_deletion_policy
</td>
<td>
mandatory
</td>
<td>
archivelog deletion policy for mandatory/all
destination
</td>
</tr>
<tr>
<td>
_log_io_size
</td>
<td>
0
</td>
<td>
automatically initiate log write if this many
 redo blocks in buffer
</td>
</tr>
<tr>
<td>
_log_parallelism
</td>
<td>
1
</td>
<td>
Number of log buffer strands
</td>
</tr>
<tr>
<td>
_log_parallelism_dynamic
</td>
<td>
TRUE
</td>
<td>
Enable dynamic strands
</td>
</tr>
<tr>
<td>
_log_parallelism_max
</td>
<td>
2
</td>
<td>
Maximum number of log buffer strands
</td>
</tr>
<tr>
<td>
_log_private_mul
</td>
<td>
5
</td>
<td>
Private strand multiplier for log space preal
location
</td>
</tr>
<tr>
<td>
_log_private_parallelism
</td>
<td>
FALSE
</td>
<td>
Number of private log buffer strands for zero
-copy redo
</td>
</tr>
<tr>
<td>
_log_private_parallelism_mul
</td>
<td>
10
</td>
<td>
Active sessions multiplier to deduce number o
f private strands
</td>
</tr>
<tr>
<td>
_log_simultaneous_copies
</td>
<td>
4
</td>
<td>
number of simultaneous copies into redo buffe
r(# of copy latches)
</td>
</tr>
<tr>
<td>
_log_space_errors
</td>
<td>
TRUE
</td>
<td>
should we report space errors to alert log
</td>
</tr>
<tr>
<td>
_log_switch_timeout
</td>
<td>
0
</td>
<td>
Maximum number of seconds redos in the curren
t log could span
</td>
</tr>
<tr>
<td>
_longops_enabled
</td>
<td>
TRUE
</td>
<td>
longops stats enabled
</td>
</tr>
<tr>
<td>
_low_server_threshold
</td>
<td>
0
</td>
<td>
low server thresholds
</td>
</tr>
<tr>
<td>
_master_direct_sends
</td>
<td>
31
</td>
<td>
direct sends for messages from master (DFS)
</td>
</tr>
<tr>
<td>
_mav_refresh_consistent_read
</td>
<td>
TRUE
</td>
<td>
refresh materialized views using consistent r
ead snapshot
</td>
</tr>
<tr>
<td>
_mav_refresh_double_count_prevented
</td>
<td>
FALSE
</td>
<td>
materialized view MAV refreshes avoid double
counting
</td>
</tr>
<tr>
<td>
_mav_refresh_opt
</td>
<td>
0
</td>
<td>
optimizations during refresh of materialized
views
</td>
</tr>
<tr>
<td>
_mav_refresh_unionall_tables
</td>
<td>
3
</td>
<td>
# tables for union all expansion during mater
ialized view refresh
</td>
</tr>
<tr>
<td>
_max_arch_lns_wait
</td>
<td>
120
</td>
<td>
Maximum wait by ARCH to allow NetServer to co
mplete archival
</td>
</tr>
<tr>
<td>
_max_exponential_sleep
</td>
<td>
0
</td>
<td>
max sleep during exponential backoff
</td>
</tr>
<tr>
<td>
_max_lns_shutdown_archival_time
</td>
<td>
30
</td>
<td>
Maximum time spent by LNS to archive last log
 during shutdown
</td>
</tr>
<tr>
<td>
_max_protocol_support
</td>
<td>
10000
</td>
<td>
Max occurrence protocols supported in a proce
ss
</td>
</tr>
<tr>
<td>
_max_rfs_connections
</td>
<td>
0
</td>
<td>
maximum number of connections used for remote
 archival
</td>
</tr>
<tr>
<td>
_max_shrink_obj_stats
</td>
<td>
0
</td>
<td>
number of segments for which shrink stats wil
l be maintained
</td>
</tr>
<tr>
<td>
_max_sleep_holding_latch
</td>
<td>
4
</td>
<td>
max time to sleep while holding a latch
</td>
</tr>
<tr>
<td>
_media_recovery_read_batch
</td>
<td>
128
</td>
<td>
media recovery block read batch
</td>
</tr>
<tr>
<td>
_media_recovery_reap_time
</td>
<td>
3
</td>
<td>
media recovery reap time
</td>
</tr>
<tr>
<td>
_mem_annotation_pr_lev
</td>
<td>
0
</td>
<td>
private memory annotation collection level
</td>
</tr>
<tr>
<td>
_mem_annotation_scale
</td>
<td>
1
</td>
<td>
memory annotation pre-allocation scaling
</td>
</tr>
<tr>
<td>
_mem_annotation_sh_lev
</td>
<td>
0
</td>
<td>
shared memory annotation collection level
</td>
</tr>
<tr>
<td>
_mem_annotation_store
</td>
<td>
FALSE
</td>
<td>
memory annotation in-memory store
</td>
</tr>
<tr>
<td>
_mem_std_extent_size
</td>
<td>
4096
</td>
<td>
standard extent size for fixed-size-extent he
aps
</td>
</tr>
<tr>
<td>
_memory_broker_log_stat_entries
</td>
<td>
5
</td>
<td>
memory broker num stat entries
</td>
</tr>
<tr>
<td>
_memory_broker_shrink_heaps
</td>
<td>
15
</td>
<td>
memory broker allow policy to shrink shared p
ool
</td>
</tr>
<tr>
<td>
_memory_broker_shrink_java_heaps
</td>
<td>
900
</td>
<td>
memory broker allow policy to shrink java poo
l
</td>
</tr>
<tr>
<td>
_memory_broker_shrink_streams_pool
</td>
<td>
900
</td>
<td>
memory broker allow policy to shrink streams
pool
</td>
</tr>
<tr>
<td>
_memory_broker_shrink_timeout
</td>
<td>
60000000
</td>
<td>
memory broker policy to timeout shrink shared
/java pool
</td>
</tr>
<tr>
<td>
_memory_broker_stat_interval
</td>
<td>
30
</td>
<td>
memory broker statistics gathering interval
</td>
</tr>
<tr>
<td>
_memory_management_tracing
</td>
<td>
0
</td>
<td>
trace memory management activity
</td>
</tr>
<tr>
<td>
_memory_sanity_check
</td>
<td>
0
</td>
<td>
partial granule sanity check
</td>
</tr>
<tr>
<td>
_messages
</td>
<td>
100
</td>
<td>
message queue resources - dependent on # proc
esses &amp; # buffers
</td>
</tr>
<tr>
<td>
_minimal_stats_aggregation
</td>
<td>
TRUE
</td>
<td>
prohibit stats aggregation at compile/partiti
on maintenance time
</td>
</tr>
<tr>
<td>
_minimum_blocks_to_shrink
</td>
<td>
0
</td>
<td>
minimum number freeable blocks for shrink to
be present
</td>
</tr>
<tr>
<td>
_minimum_extents_to_shrink
</td>
<td>
1
</td>
<td>
minimum number freeable extents for shrink to
 be present
</td>
</tr>
<tr>
<td>
_minimum_giga_scn
</td>
<td>
0
</td>
<td>
Minimum SCN to start with in 2^30 units
</td>
</tr>
<tr>
<td>
_mirror_redo_buffers
</td>
<td>
FALSE
</td>
<td>
Save buffers for debugging redo corruptions
</td>
</tr>
<tr>
<td>
_mmv_query_rewrite_enabled
</td>
<td>
TRUE
</td>
<td>
allow rewrites with multiple MVs and/or base
tables
</td>
</tr>
<tr>
<td>
_multi_join_key_table_lookup
</td>
<td>
TRUE
</td>
<td>
TRUE iff multi-join-key table lookup prefetch
 is enabled
</td>
</tr>
<tr>
<td>
_multiple_instance_recovery
</td>
<td>
FALSE
</td>
<td>
use multiple instances for media recovery
</td>
</tr>
<tr>
<td>
_mv_refresh_ana
</td>
<td>
0
</td>
<td>
what percent to analyze after complete/PCT re
fresh
</td>
</tr>
<tr>
<td>
_mv_refresh_costing
</td>
<td>
rule
</td>
<td>
refresh decision based on cost or on rules
</td>
</tr>
<tr>
<td>
_mv_refresh_delta_fraction
</td>
<td>
10
</td>
<td>
delta mv as fractional percentage of size of
mv
</td>
</tr>
<tr>
<td>
_mv_refresh_eut
</td>
<td>
TRUE
</td>
<td>
refresh materialized views using EUT(partitio
n)-based algorithm
</td>
</tr>
<tr>
<td>
_mv_refresh_force_parallel_query
</td>
<td>
0
</td>
<td>
force materialized view refreshes to use para
llel query
</td>
</tr>
<tr>
<td>
_mv_refresh_new_setup_disabled
</td>
<td>
FALSE
</td>
<td>
materialized view MV refresh new setup disabl
ing
</td>
</tr>
<tr>
<td>
_mv_refresh_rebuild_percentage
</td>
<td>
10
</td>
<td>
minimum percentage change required in MV to f
orce an index rebuild
</td>
</tr>
<tr>
<td>
_mv_refresh_selections
</td>
<td>
TRUE
</td>
<td>
create materialized views with selections and
 fast refresh
</td>
</tr>
<tr>
<td>
_mv_refresh_use_stats
</td>
<td>
TRUE
</td>
<td>
pass cardinality hints to refresh queries
</td>
</tr>
<tr>
<td>
_mv_refsched_timeincr
</td>
<td>
300000
</td>
<td>
proportionality constant for dop vs. time in
MV refresh
</td>
</tr>
<tr>
<td>
_mv_rolling_inv
</td>
<td>
FALSE
</td>
<td>
create/alter mv uses rolling cursor invalidat
ion instead of immediate
</td>
</tr>
<tr>
<td>
_mwin_schedule
</td>
<td>
TRUE
</td>
<td>
Enable/disable Maintenance Window Schedules
</td>
</tr>
<tr>
<td>
_nchar_imp_cnv
</td>
<td>
TRUE
</td>
<td>
NLS allow Implicit Conversion between CHAR an
d NCHAR
</td>
</tr>
<tr>
<td>
_nchar_imp_conv
</td>
<td>
TRUE
</td>
<td>
should implicit conversion bewteen clob and n
clob be allowed
</td>
</tr>
<tr>
<td>
_ncmb_readahead_enabled
</td>
<td>
0
</td>
<td>
enable multi-block readahead for an index sca
n
</td>
</tr>
<tr>
<td>
_ncmb_readahead_tracing
</td>
<td>
0
</td>
<td>
turn on multi-block readahead tracing
</td>
</tr>
<tr>
<td>
_nested_loop_fudge
</td>
<td>
100
</td>
<td>
nested loop fudge
</td>
</tr>
<tr>
<td>
_nested_mav_fast_oncommit_enabled
</td>
<td>
TRUE
</td>
<td>
nested MAV refresh fast on commit allowed
</td>
</tr>
<tr>
<td>
_new_initial_join_orders
</td>
<td>
TRUE
</td>
<td>
enable initial join orders based on new order
ing heuristics
</td>
</tr>
<tr>
<td>
_new_sort_cost_estimate
</td>
<td>
TRUE
</td>
<td>
enables the use of new cost estimate for sort
</td>
</tr>
<tr>
<td>
_newsort_enabled
</td>
<td>
TRUE
</td>
<td>
controls whether new sorts can be used as sys
tem sort
</td>
</tr>
<tr>
<td>
_newsort_ordered_pct
</td>
<td>
63
</td>
<td>
controls when new sort avoids sorting ordered
 input
</td>
</tr>
<tr>
<td>
_newsort_type
</td>
<td>
0
</td>
<td>
specifies options for the new sort algorithm
</td>
</tr>
<tr>
<td>
_no_objects
</td>
<td>
FALSE
</td>
<td>
no object features are used
</td>
</tr>
<tr>
<td>
_no_or_expansion
</td>
<td>
FALSE
</td>
<td>
OR expansion during optimization disabled
</td>
</tr>
<tr>
<td>
_no_recovery_through_resetlogs
</td>
<td>
FALSE
</td>
<td>
no recovery through this resetlogs operation
</td>
</tr>
<tr>
<td>
_notify_crs
</td>
<td>
FALSE
</td>
<td>
notify cluster ready services of startup and
shutdown
</td>
</tr>
<tr>
<td>
_ns_max_flush_wt
</td>
<td>
1
</td>
<td>
Flush wait time for NetServer to flush oustan
ding writes
</td>
</tr>
<tr>
<td>
_ns_max_send_delay
</td>
<td>
15
</td>
<td>
Data Loss Time Bound for NetServer
</td>
</tr>
<tr>
<td>
_num_longop_child_latches
</td>
<td>
2
</td>
<td>
number of child latches for long op array
</td>
</tr>
<tr>
<td>
_number_cached_attributes
</td>
<td>
10
</td>
<td>
maximum number of cached attributes per insta
nce
</td>
</tr>
<tr>
<td>
_object_statistics
</td>
<td>
TRUE
</td>
<td>
enable the object level statistics collection
</td>
</tr>
<tr>
<td>
_offline_rollback_segments
</td>
<td>
&nbsp;
</td>
<td>
offline undo segment list
</td>
</tr>
<tr>
<td>
_ogms_home
</td>
<td>
&nbsp;
</td>
<td>
GMS home directory
</td>
</tr>
<tr>
<td>
_olap_aggregate_buffer_size
</td>
<td>
1048576
</td>
<td>
OLAP Aggregate max buffer size
</td>
</tr>
<tr>
<td>
_olap_aggregate_flags
</td>
<td>
0
</td>
<td>
OLAP Aggregate debug flags
</td>
</tr>
<tr>
<td>
_olap_aggregate_function_cache_enabled
</td>
<td>
TRUE
</td>
<td>
OLAP Aggregate function cache enabler
</td>
</tr>
<tr>
<td>
_olap_aggregate_function_merge_threshold
</td>
<td>
529
</td>
<td>
OLAP Aggregate function merge threshold
</td>
</tr>
<tr>
<td>
_olap_aggregate_max_thread_tuples
</td>
<td>
5000
</td>
<td>
OLAP Aggregate max thread tuples creation
</td>
</tr>
<tr>
<td>
_olap_aggregate_min_buffer_size
</td>
<td>
1024
</td>
<td>
OLAP Aggregate min buffer size
</td>
</tr>
<tr>
<td>
_olap_aggregate_min_thread_status
</td>
<td>
64
</td>
<td>
OLAP Aggregate minimum cardinality of dimensi
ons for thread
</td>
</tr>
<tr>
<td>
_olap_aggregate_multipath_hier
</td>
<td>
FALSE
</td>
<td>
OLAP Aggregate Multi-path Hierarhies enabled
</td>
</tr>
<tr>
<td>
_olap_aggregate_statlen_thresh
</td>
<td>
1024
</td>
<td>
OLAP Aggregate status array usage threshold
</td>
</tr>
<tr>
<td>
_olap_aggregate_store_probability
</td>
<td>
100
</td>
<td>
OLAP Aggregate function storeback probability
</td>
</tr>
<tr>
<td>
_olap_aggregate_work_per_thread
</td>
<td>
1024
</td>
<td>
OLAP Aggregate max work parents
</td>
</tr>
<tr>
<td>
_olap_aggregate_worklist_max
</td>
<td>
5000
</td>
<td>
OLAP Aggregate max worklists generated at onc
e
</td>
</tr>
<tr>
<td>
_olap_allocate_errorlog_format
</td>
<td>
%8p %8y %8z %e (%n)
</td>
<td>
OLAP Allocate Errorlog Format
</td>
</tr>
<tr>
<td>
_olap_allocate_errorlog_header
</td>
<td>
Dim	 Source   Basis
%
-8d %-8s %-8b Description

-------- -------- ------
-- -----------
</td>
<td>
OLAP Allocate Errorlog Header format
</td>
</tr>
<tr>
<td>
_olap_continuous_trace_file
</td>
<td>
FALSE
</td>
<td>
Specify TRUE to enable continuous OLAP tracin
g - otherwise only exceptional events will be
 logged
</td>
</tr>
<tr>
<td>
_olap_dbgoutfile_echo_to_eventlog
</td>
<td>
FALSE
</td>
<td>
OLAP DbgOutfile copy output to event log (tra
cefile)
</td>
</tr>
<tr>
<td>
_olap_dimension_corehash_class
</td>
<td>
1
</td>
<td>
OLAP Dimension In-Core Hash Table Class
</td>
</tr>
<tr>
<td>
_olap_dimension_corehash_max
</td>
<td>
10000
</td>
<td>
OLAP Dimension In-Core Hash Table Maximum Siz
e
</td>
</tr>
<tr>
<td>
_olap_eif_export_lob_size
</td>
<td>
2147483647
</td>
<td>
OLAP EIF Export BLOB size
</td>
</tr>
<tr>
<td>
_olap_lmgen_dim_size
</td>
<td>
100
</td>
<td>
Limitmap generator dimension column size
</td>
</tr>
<tr>
<td>
_olap_lmgen_meas_size
</td>
<td>
1000
</td>
<td>
Limitmap generator measure column size
</td>
</tr>
<tr>
<td>
_olap_object_hash_class
</td>
<td>
2
</td>
<td>
OLAP Object Hash Table Class
</td>
</tr>
<tr>
<td>
_olap_page_pool_expand_rate
</td>
<td>
20
</td>
<td>
OLAP Page Pool Expand Rate
</td>
</tr>
<tr>
<td>
_olap_page_pool_hi
</td>
<td>
50
</td>
<td>
OLAP Page Pool High Watermark
</td>
</tr>
<tr>
<td>
_olap_page_pool_hit_target
</td>
<td>
100
</td>
<td>
OLAP Page Pool Hit Target
</td>
</tr>
<tr>
<td>
_olap_page_pool_low
</td>
<td>
262144
</td>
<td>
OLAP Page Pool Low Watermark
</td>
</tr>
<tr>
<td>
_olap_page_pool_pressure
</td>
<td>
90
</td>
<td>
OLAP Page Pool Pressure Threshold
</td>
</tr>
<tr>
<td>
_olap_page_pool_shrink_rate
</td>
<td>
50
</td>
<td>
OLAP Page Pool Shrink Rate
</td>
</tr>
<tr>
<td>
_olap_parallel_update_small_group
</td>
<td>
400
</td>
<td>
OLAP parallel update pagespace by group
</td>
</tr>
<tr>
<td>
_olap_parallel_update_small_threshold
</td>
<td>
1000
</td>
<td>
OLAP parallel update threshold for number of
small pagespaces
</td>
</tr>
<tr>
<td>
_olap_parallel_update_threshold
</td>
<td>
1000
</td>
<td>
OLAP parallel update threshold in pages
</td>
</tr>
<tr>
<td>
_olap_poutlog_echo_to_eventlog
</td>
<td>
FALSE
</td>
<td>
OLAP POutLog copy output to event log (tracef
ile)
</td>
</tr>
<tr>
<td>
_olap_sesscache_enabled
</td>
<td>
TRUE
</td>
<td>
OLAP Session Cache knob
</td>
</tr>
<tr>
<td>
_olap_sort_buffer_size
</td>
<td>
262144
</td>
<td>
OLAP Sort Buffer Size
</td>
</tr>
<tr>
<td>
_olap_statbool_corebits
</td>
<td>
20000000
</td>
<td>
OLAP Status Boolean max incore bits
</td>
</tr>
<tr>
<td>
_olap_statbool_threshold
</td>
<td>
8100
</td>
<td>
OLAP Status Boolean CBM threshold
</td>
</tr>
<tr>
<td>
_olap_table_function_statistics
</td>
<td>
FALSE
</td>
<td>
Specify TRUE to output OLAP table function ti
med statistics trace
</td>
</tr>
<tr>
<td>
_olap_wrap_errors
</td>
<td>
FALSE
</td>
<td>
Wrap error messages to OLAP outfile
</td>
</tr>
<tr>
<td>
_olapi_history_retention
</td>
<td>
FALSE
</td>
<td>
enable olapi history retention
</td>
</tr>
<tr>
<td>
_olapi_iface_object_history
</td>
<td>
1000
</td>
<td>
enable olapi interface object history collect
ion
</td>
</tr>
<tr>
<td>
_olapi_iface_object_history_retention
</td>
<td>
FALSE
</td>
<td>
enable olapi interface object history retenti
on
</td>
</tr>
<tr>
<td>
_olapi_iface_operation_history_retention
</td>
<td>
FALSE
</td>
<td>
enable olapi interface operation history rete
ntion
</td>
</tr>
<tr>
<td>
_olapi_interface_operation_history
</td>
<td>
1000
</td>
<td>
enable olapi interface operation history coll
ection
</td>
</tr>
<tr>
<td>
_olapi_memory_operation_history
</td>
<td>
1000
</td>
<td>
enable olapi memory alloc/free history collec
tion
</td>
</tr>
<tr>
<td>
_olapi_memory_operation_history_pause_at_seqn
o
</td>
<td>
0
</td>
<td>
enable olapi memory alloc/free history collec
tion pausing
</td>
</tr>
<tr>
<td>
_olapi_memory_operation_history_retention
</td>
<td>
FALSE
</td>
<td>
enable olapi memory operation history retenti
on
</td>
</tr>
<tr>
<td>
_olapi_session_history
</td>
<td>
300
</td>
<td>
enable olapi session history collection
</td>
</tr>
<tr>
<td>
_olapi_session_history_retention
</td>
<td>
FALSE
</td>
<td>
enable olapi session history retention
</td>
</tr>
<tr>
<td>
_old_connect_by_enabled
</td>
<td>
FALSE
</td>
<td>
enable/disable old connect by
</td>
</tr>
<tr>
<td>
_ols_cleanup_task
</td>
<td>
TRUE
</td>
<td>
Clean up unnecessary entries in OLS sessinfo
table
</td>
</tr>
<tr>
<td>
_omf
</td>
<td>
enabled
</td>
<td>
enable/disable OMF
</td>
</tr>
<tr>
<td>
_oneside_colstat_for_equijoins
</td>
<td>
TRUE
</td>
<td>
sanity check on default selectivity for like/
range predicate
</td>
</tr>
<tr>
<td>
_optim_adjust_for_part_skews
</td>
<td>
TRUE
</td>
<td>
adjust stats for skews across partitions
</td>
</tr>
<tr>
<td>
_optim_dict_stats_at_db_cr_upg
</td>
<td>
TRUE
</td>
<td>
enable/disable dictionary stats gathering at
db create/upgrade
</td>
</tr>
<tr>
<td>
_optim_enhance_nnull_detection
</td>
<td>
TRUE
</td>
<td>
TRUE to enable index [fast] full scan more of
ten
</td>
</tr>
<tr>
<td>
_optim_new_default_join_sel
</td>
<td>
TRUE
</td>
<td>
improves the way default equijoin selectivity
 are computed
</td>
</tr>
<tr>
<td>
_optim_peek_user_binds
</td>
<td>
TRUE
</td>
<td>
enable peeking of user binds
</td>
</tr>
<tr>
<td>
_optimizer_adjust_for_nulls
</td>
<td>
TRUE
</td>
<td>
adjust selectivity for null values
</td>
</tr>
<tr>
<td>
_optimizer_autostats_job
</td>
<td>
TRUE
</td>
<td>
enable/disable auto stats collection job
</td>
</tr>
<tr>
<td>
_optimizer_better_inlist_costing
</td>
<td>
ALL
</td>
<td>
enable improved costing of index access using
 in-list(s)
</td>
</tr>
<tr>
<td>
_optimizer_block_size
</td>
<td>
8192
</td>
<td>
standard block size used by optimizer
</td>
</tr>
<tr>
<td>
_optimizer_cache_stats
</td>
<td>
FALSE
</td>
<td>
cost with cache statistics
</td>
</tr>
<tr>
<td>
_optimizer_cartesian_enabled
</td>
<td>
TRUE
</td>
<td>
optimizer cartesian join enabled
</td>
</tr>
<tr>
<td>
_optimizer_cbqt_factor
</td>
<td>
50
</td>
<td>
cost factor for cost-based query transformati
on
</td>
</tr>
<tr>
<td>
_optimizer_cbqt_no_size_restriction
</td>
<td>
TRUE
</td>
<td>
disable cost based transformation query size
restriction
</td>
</tr>
<tr>
<td>
_optimizer_ceil_cost
</td>
<td>
TRUE
</td>
<td>
CEIL cost in CBO
</td>
</tr>
<tr>
<td>
_optimizer_choose_permutation
</td>
<td>
0
</td>
<td>
force the optimizer to use the specified perm
utation
</td>
</tr>
<tr>
<td>
_optimizer_complex_pred_selectivity
</td>
<td>
TRUE
</td>
<td>
enable selectivity estimation for builtin fun
ctions
</td>
</tr>
<tr>
<td>
_optimizer_compute_index_stats
</td>
<td>
TRUE
</td>
<td>
force index stats collection on index creatio
n/rebuild
</td>
</tr>
<tr>
<td>
_optimizer_correct_sq_selectivity
</td>
<td>
TRUE
</td>
<td>
force correct computation of subquery selecti
vity
</td>
</tr>
<tr>
<td>
_optimizer_cost_based_transformation
</td>
<td>
LINEAR
</td>
<td>
enables cost-based query transformation
</td>
</tr>
<tr>
<td>
_optimizer_cost_filter_pred
</td>
<td>
FALSE
</td>
<td>
enables  costing of filter predicates in IO c
ost model
</td>
</tr>
<tr>
<td>
_optimizer_cost_hjsmj_multimatch
</td>
<td>
TRUE
</td>
<td>
add cost of generating result set when #rows
per key &gt; 1
</td>
</tr>
<tr>
<td>
_optimizer_cost_model
</td>
<td>
CHOOSE
</td>
<td>
optimizer cost model
</td>
</tr>
<tr>
<td>
_optimizer_degree
</td>
<td>
0
</td>
<td>
force the optimizer to use the same degree of
 parallelism
</td>
</tr>
<tr>
<td>
_optimizer_dim_subq_join_sel
</td>
<td>
TRUE
</td>
<td>
use join selectivity in choosing star transfo
rmation dimensions
</td>
</tr>
<tr>
<td>
_optimizer_disable_strans_sanity_checks
</td>
<td>
0
</td>
<td>
disable star transformation sanity checks
</td>
</tr>
<tr>
<td>
_optimizer_dyn_smp_blks
</td>
<td>
32
</td>
<td>
number of blocks for optimizer dynamic sampli
ng
</td>
</tr>
<tr>
<td>
_optimizer_enhanced_filter_push
</td>
<td>
TRUE
</td>
<td>
push filters before trying cost-based query t
ransformation
</td>
</tr>
<tr>
<td>
_optimizer_extended_cursor_sharing
</td>
<td>
UDO
</td>
<td>
optimizer extended cursor sharing
</td>
</tr>
<tr>
<td>
_optimizer_filter_pred_pullup
</td>
<td>
TRUE
</td>
<td>
use cost-based flter predicate pull up transf
ormation
</td>
</tr>
<tr>
<td>
_optimizer_ignore_hints
</td>
<td>
FALSE
</td>
<td>
enables the embedded hints to be ignored
</td>
</tr>
<tr>
<td>
_optimizer_invalidation_period
</td>
<td>
18000
</td>
<td>
time window for invalidation of cursors of an
alyzed objects
</td>
</tr>
<tr>
<td>
_optimizer_join_elimination_enabled
</td>
<td>
TRUE
</td>
<td>
optimizer join elimination enabled
</td>
</tr>
<tr>
<td>
_optimizer_join_order_control
</td>
<td>
3
</td>
<td>
controls the optimizer join order search algo
rithm
</td>
</tr>
<tr>
<td>
_optimizer_join_sel_sanity_check
</td>
<td>
TRUE
</td>
<td>
enable/disable sanity check for multi-column
join selectivity
</td>
</tr>
<tr>
<td>
_optimizer_max_permutations
</td>
<td>
2000
</td>
<td>
optimizer maximum join permutations per query
 block
</td>
</tr>
<tr>
<td>
_optimizer_min_cache_blocks
</td>
<td>
10
</td>
<td>
set minimum cached blocks
</td>
</tr>
<tr>
<td>
_optimizer_mjc_enabled
</td>
<td>
TRUE
</td>
<td>
enable merge join cartesian
</td>
</tr>
<tr>
<td>
_optimizer_mode_force
</td>
<td>
TRUE
</td>
<td>
force setting of optimizer mode for user recu
rsive SQL also
</td>
</tr>
<tr>
<td>
_optimizer_multiple_cenv
</td>
<td>
&nbsp;
</td>
<td>
generate and run plans using several compilat
ion environments
</td>
</tr>
<tr>
<td>
_optimizer_new_join_card_computation
</td>
<td>
TRUE
</td>
<td>
compute join cardinality using non-rounded in
put values
</td>
</tr>
<tr>
<td>
_optimizer_or_expansion
</td>
<td>
DEPTH
</td>
<td>
control or expansion approach used
</td>
</tr>
<tr>
<td>
_optimizer_order_by_elimination_enabled
</td>
<td>
TRUE
</td>
<td>
Eliminates order bys from views before query
transformation
</td>
</tr>
<tr>
<td>
_optimizer_outer_to_anti_enabled
</td>
<td>
TRUE
</td>
<td>
Enable transformation of outer-join to anti-j
oin if possible
</td>
</tr>
<tr>
<td>
_optimizer_percent_parallel
</td>
<td>
101
</td>
<td>
optimizer percent parallel
</td>
</tr>
<tr>
<td>
_optimizer_push_down_distinct
</td>
<td>
0
</td>
<td>
push down distinct from query block to table
</td>
</tr>
<tr>
<td>
_optimizer_push_pred_cost_based
</td>
<td>
TRUE
</td>
<td>
use cost-based query transformation for push
pred optimization
</td>
</tr>
<tr>
<td>
_optimizer_random_plan
</td>
<td>
0
</td>
<td>
optimizer seed value for random plans
</td>
</tr>
<tr>
<td>
_optimizer_rownum_pred_based_fkr
</td>
<td>
TRUE
</td>
<td>
enable the use of first K rows due to rownum
predicate
</td>
</tr>
<tr>
<td>
_optimizer_save_stats
</td>
<td>
TRUE
</td>
<td>
enable/disable saving old versions of optimiz
er stats
</td>
</tr>
<tr>
<td>
_optimizer_search_limit
</td>
<td>
5
</td>
<td>
optimizer search limit
</td>
</tr>
<tr>
<td>
_optimizer_self_induced_cache_cost
</td>
<td>
FALSE
</td>
<td>
account for self-induced caching
</td>
</tr>
<tr>
<td>
_optimizer_skip_scan_enabled
</td>
<td>
TRUE
</td>
<td>
enable/disable index skip scan
</td>
</tr>
<tr>
<td>
_optimizer_sortmerge_join_enabled
</td>
<td>
TRUE
</td>
<td>
enable/disable sort-merge join method
</td>
</tr>
<tr>
<td>
_optimizer_squ_bottomup
</td>
<td>
TRUE
</td>
<td>
enables unnesting of subquery in a bottom-up
manner
</td>
</tr>
<tr>
<td>
_optimizer_star_tran_in_with_clause
</td>
<td>
TRUE
</td>
<td>
enable/disable star transformation in with cl
ause queries
</td>
</tr>
<tr>
<td>
_optimizer_starplan_enabled
</td>
<td>
TRUE
</td>
<td>
optimizer star plan enabled
</td>
</tr>
<tr>
<td>
_optimizer_system_stats_usage
</td>
<td>
TRUE
</td>
<td>
system statistics usage
</td>
</tr>
<tr>
<td>
_optimizer_trace
</td>
<td>
none
</td>
<td>
optimizer trace parameter
</td>
</tr>
<tr>
<td>
_optimizer_transitivity_retain
</td>
<td>
TRUE
</td>
<td>
retain equi-join pred upon transitive equalit
y pred generation
</td>
</tr>
<tr>
<td>
_optimizer_undo_changes
</td>
<td>
FALSE
</td>
<td>
undo changes to query optimizer
</td>
</tr>
<tr>
<td>
_optimizer_undo_cost_change
</td>
<td>
10.2.0.1
</td>
<td>
optimizer undo cost change
</td>
</tr>
<tr>
<td>
_or_expand_nvl_predicate
</td>
<td>
TRUE
</td>
<td>
enable OR expanded plan for NVL/DECODE predic
ate
</td>
</tr>
<tr>
<td>
_oradebug_force
</td>
<td>
FALSE
</td>
<td>
force target processes to execute oradebug co
mmands?
</td>
</tr>
<tr>
<td>
_ordered_nested_loop
</td>
<td>
TRUE
</td>
<td>
enable ordered nested loop costing
</td>
</tr>
<tr>
<td>
_ordered_semijoin
</td>
<td>
TRUE
</td>
<td>
enable ordered semi-join subquery
</td>
</tr>
<tr>
<td>
_os_sched_high_priority
</td>
<td>
1
</td>
<td>
OS high priority level
</td>
</tr>
<tr>
<td>
_other_wait_event_exclusion
</td>
<td>
&nbsp;
</td>
<td>
exclude event names from _other_wait_threshol
d calculations
</td>
</tr>
<tr>
<td>
_other_wait_threshold
</td>
<td>
0
</td>
<td>
threshold wait percentage for event wait clas
s Other
</td>
</tr>
<tr>
<td>
_outline_bitmap_tree
</td>
<td>
TRUE
</td>
<td>
BITMAP_TREE hint enabled in outline
</td>
</tr>
<tr>
<td>
_parallel_adaptive_max_users
</td>
<td>
2
</td>
<td>
maximum number of users running with default
DOP
</td>
</tr>
<tr>
<td>
_parallel_broadcast_enabled
</td>
<td>
TRUE
</td>
<td>
enable broadcasting of small inputs to hash a
nd sort merge joins
</td>
</tr>
<tr>
<td>
_parallel_default_max_instances
</td>
<td>
1
</td>
<td>
default maximum number of instances for paral
lel query
</td>
</tr>
<tr>
<td>
_parallel_execution_message_align
</td>
<td>
FALSE
</td>
<td>
Alignment of PX buffers to OS page boundary
</td>
</tr>
<tr>
<td>
_parallel_fake_class_pct
</td>
<td>
0
</td>
<td>
fake db-scheduler percent used for testing
</td>
</tr>
<tr>
<td>
_parallel_fixwrite_bucket
</td>
<td>
1000
</td>
<td>
Number of buckets for each round of fix write
</td>
</tr>
<tr>
<td>
_parallel_load_bal_unit
</td>
<td>
0
</td>
<td>
number of threads to allocate per instance
</td>
</tr>
<tr>
<td>
_parallel_load_balancing
</td>
<td>
TRUE
</td>
<td>
parallel execution load balanced slave alloca
tion
</td>
</tr>
<tr>
<td>
_parallel_min_message_pool
</td>
<td>
618624
</td>
<td>
minimum size of shared pool memory to reserve
 for pq servers
</td>
</tr>
<tr>
<td>
_parallel_recovery_stopat
</td>
<td>
32767
</td>
<td>
stop at -position- to step through SMON
</td>
</tr>
<tr>
<td>
_parallel_replay_msg_limit
</td>
<td>
4000
</td>
<td>
Number of messages for each round of parallel
 replay
</td>
</tr>
<tr>
<td>
_parallel_server_idle_time
</td>
<td>
30000
</td>
<td>
idle time before parallel query server dies (
in 1/100 sec)
</td>
</tr>
<tr>
<td>
_parallel_server_sleep_time
</td>
<td>
10
</td>
<td>
sleep time between dequeue timeouts (in 1/100
ths)
</td>
</tr>
<tr>
<td>
_parallel_slave_acquisition_wait
</td>
<td>
1
</td>
<td>
time(in seconds) to wait before retrying slav
e acquisition
</td>
</tr>
<tr>
<td>
_parallel_txn_global
</td>
<td>
FALSE
</td>
<td>
enable parallel_txn hint with updates and del
etes
</td>
</tr>
<tr>
<td>
_parallelism_cost_fudge_factor
</td>
<td>
350
</td>
<td>
set the parallelism cost fudge factor
</td>
</tr>
<tr>
<td>
_parameter_table_block_size
</td>
<td>
1024
</td>
<td>
parameter table block size
</td>
</tr>
<tr>
<td>
_partial_pwise_join_enabled
</td>
<td>
TRUE
</td>
<td>
enable partial partition-wise join when TRUE
</td>
</tr>
<tr>
<td>
_partition_view_enabled
</td>
<td>
TRUE
</td>
<td>
enable/disable partitioned views
</td>
</tr>
<tr>
<td>
_passwordfile_enqueue_timeout
</td>
<td>
900
</td>
<td>
password file enqueue timeout in seconds
</td>
</tr>
<tr>
<td>
_pct_refresh_double_count_prevented
</td>
<td>
TRUE
</td>
<td>
materialized view PCT refreshes avoid double
counting
</td>
</tr>
<tr>
<td>
_pdml_gim_sampling
</td>
<td>
5000
</td>
<td>
control separation of global index maintenanc
e for PDML
</td>
</tr>
<tr>
<td>
_pdml_gim_staggered
</td>
<td>
FALSE
</td>
<td>
slaves start on different index when doing in
dex maint
</td>
</tr>
<tr>
<td>
_pdml_slaves_diff_part
</td>
<td>
TRUE
</td>
<td>
slaves start on different partition when doin
g index maint
</td>
</tr>
<tr>
<td>
_percent_flashback_buf_partial_full
</td>
<td>
50
</td>
<td>
Percent of flashback buffer filled to be cons
idered partial full
</td>
</tr>
<tr>
<td>
_pga_large_extent_size
</td>
<td>
1048576
</td>
<td>
PGA large extent size
</td>
</tr>
<tr>
<td>
_pga_max_size
</td>
<td>
209715200
</td>
<td>
Maximum size of the PGA memory for one proces
s
</td>
</tr>
<tr>
<td>
_ping_level
</td>
<td>
3
</td>
<td>
fusion ping level
</td>
</tr>
<tr>
<td>
_pkt_enable
</td>
<td>
FALSE
</td>
<td>
enable progressive kill test
</td>
</tr>
<tr>
<td>
_pkt_pmon_interval
</td>
<td>
50
</td>
<td>
PMON process clean-up interval (cs)
</td>
</tr>
<tr>
<td>
_pkt_start
</td>
<td>
FALSE
</td>
<td>
start progressive kill test instrumention
</td>
</tr>
<tr>
<td>
_plan_outline_data
</td>
<td>
TRUE
</td>
<td>
explain plan outline data enabled
</td>
</tr>
<tr>
<td>
_plsql_anon_block_code_type
</td>
<td>
INTERPRETED
</td>
<td>
PL/SQL anonymous block code-type
</td>
</tr>
<tr>
<td>
_plsql_cache_enable
</td>
<td>
TRUE
</td>
<td>
PL/SQL Function Cache Enabled
</td>
</tr>
<tr>
<td>
_plsql_dump_buffer_events
</td>
<td>
&nbsp;
</td>
<td>
conditions upon which the PL/SQL circular buf
fer is dumped
</td>
</tr>
<tr>
<td>
_plsql_minimum_cache_hit_percent
</td>
<td>
20
</td>
<td>
plsql minimum cache hit percentage required t
o keep caching active
</td>
</tr>
<tr>
<td>
_plsql_nvl_optimize
</td>
<td>
FALSE
</td>
<td>
PL/SQL NVL optimize
</td>
</tr>
<tr>
<td>
_pmon_load_constants
</td>
<td>
300,192,64,3,10,10,0,0
</td>
<td>
server load balancing constants (S,P,D,I,L,C,
M)
</td>
</tr>
<tr>
<td>
_pre_rewrite_push_pred
</td>
<td>
TRUE
</td>
<td>
push predicates into views before rewrite
</td>
</tr>
<tr>
<td>
_precompute_gid_values
</td>
<td>
TRUE
</td>
<td>
precompute gid values and copy them before re
turning a row
</td>
</tr>
<tr>
<td>
_pred_move_around
</td>
<td>
TRUE
</td>
<td>
enables predicate move-around
</td>
</tr>
<tr>
<td>
_predicate_elimination_enabled
</td>
<td>
TRUE
</td>
<td>
allow predicate elimination if set to TRUE
</td>
</tr>
<tr>
<td>
_prescomm
</td>
<td>
FALSE
</td>
<td>
presume commit of IMU transactions
</td>
</tr>
<tr>
<td>
_print_refresh_schedule
</td>
<td>
false
</td>
<td>
enable dbms_output of materialized view refre
sh schedule
</td>
</tr>
<tr>
<td>
_private_memory_address
</td>
<td>
&nbsp;
</td>
<td>
Start address of large extent memory segment
</td>
</tr>
<tr>
<td>
_project_view_columns
</td>
<td>
TRUE
</td>
<td>
enable projecting out unreferenced columns of
 a view
</td>
</tr>
<tr>
<td>
_projection_pushdown
</td>
<td>
TRUE
</td>
<td>
projection pushdown
</td>
</tr>
<tr>
<td>
_projection_pushdown_debug
</td>
<td>
0
</td>
<td>
level for projection pushdown debugging
</td>
</tr>
<tr>
<td>
_push_join_predicate
</td>
<td>
TRUE
</td>
<td>
enable pushing join predicate inside a view
</td>
</tr>
<tr>
<td>
_push_join_union_view
</td>
<td>
TRUE
</td>
<td>
enable pushing join predicate inside a union
all view
</td>
</tr>
<tr>
<td>
_push_join_union_view2
</td>
<td>
TRUE
</td>
<td>
enable pushing join predicate inside a union
view
</td>
</tr>
<tr>
<td>
_px_async_getgranule
</td>
<td>
FALSE
</td>
<td>
asynchronous get granule in the slave
</td>
</tr>
<tr>
<td>
_px_broadcast_fudge_factor
</td>
<td>
100
</td>
<td>
set the tq broadcasting fudge factor percenta
ge
</td>
</tr>
<tr>
<td>
_px_buffer_ttl
</td>
<td>
30
</td>
<td>
ttl for px mesg buffers in seconds
</td>
</tr>
<tr>
<td>
_px_compilation_debug
</td>
<td>
0
</td>
<td>
debug level for parallel compilation
</td>
</tr>
<tr>
<td>
_px_compilation_trace
</td>
<td>
0
</td>
<td>
tracing level for parallel compilation
</td>
</tr>
<tr>
<td>
_px_dynamic_opt
</td>
<td>
TRUE
</td>
<td>
turn off/on restartable qerpx dynamic optimiz
ation
</td>
</tr>
<tr>
<td>
_px_dynamic_sample_size
</td>
<td>
50
</td>
<td>
num of samples for restartable qerpx dynamic
optimization
</td>
</tr>
<tr>
<td>
_px_granule_size
</td>
<td>
100000
</td>
<td>
default size of a rowid range granule (in KB)
</td>
</tr>
<tr>
<td>
_px_index_sampling
</td>
<td>
200
</td>
<td>
parallel query sampling for index create (100
000 = 100%)
</td>
</tr>
<tr>
<td>
_px_kxib_tracing
</td>
<td>
0
</td>
<td>
turn on kxib tracing
</td>
</tr>
<tr>
<td>
_px_load_publish_interval
</td>
<td>
200
</td>
<td>
interval at which LMON will check whether to
publish PX load
</td>
</tr>
<tr>
<td>
_px_loc_msg_cost
</td>
<td>
1000
</td>
<td>
CPU cost to send a PX message via shared memo
ry
</td>
</tr>
<tr>
<td>
_px_max_granules_per_slave
</td>
<td>
100
</td>
<td>
maximum number of rowid range granules to gen
erate per slave
</td>
</tr>
<tr>
<td>
_px_min_granules_per_slave
</td>
<td>
13
</td>
<td>
minimum number of rowid range granules to gen
erate per slave
</td>
</tr>
<tr>
<td>
_px_minus_intersect
</td>
<td>
TRUE
</td>
<td>
enables pq for minus/interect operators
</td>
</tr>
<tr>
<td>
_px_net_msg_cost
</td>
<td>
10000
</td>
<td>
CPU cost to send a PX message over the intern
connect
</td>
</tr>
<tr>
<td>
_px_no_granule_sort
</td>
<td>
FALSE
</td>
<td>
prevent parallel partition granules to be sor
ted on size
</td>
</tr>
<tr>
<td>
_px_no_stealing
</td>
<td>
FALSE
</td>
<td>
prevent parallel granule stealing in shared n
othing environment
</td>
</tr>
<tr>
<td>
_px_nss_planb
</td>
<td>
TRUE
</td>
<td>
enables or disables NSS Plan B reparse with o
utline
</td>
</tr>
<tr>
<td>
_px_proc_constrain
</td>
<td>
TRUE
</td>
<td>
reduce parallel_max_servers if greater than (
processes - fudge)
</td>
</tr>
<tr>
<td>
_px_pwg_enabled
</td>
<td>
TRUE
</td>
<td>
parallel partition wise group by enabled
</td>
</tr>
<tr>
<td>
_px_rownum_pd
</td>
<td>
TRUE
</td>
<td>
turn off/on parallel rownum pushdown optimiza
tion
</td>
</tr>
<tr>
<td>
_px_send_timeout
</td>
<td>
300
</td>
<td>
IPC message  send timeout value in seconds
</td>
</tr>
<tr>
<td>
_px_slaves_share_cursors
</td>
<td>
0
</td>
<td>
slaves share cursors with QC
</td>
</tr>
<tr>
<td>
_px_trace
</td>
<td>
none
</td>
<td>
px trace parameter
</td>
</tr>
<tr>
<td>
_px_xtgranule_size
</td>
<td>
10000
</td>
<td>
default size of a external table granule (in
KB)
</td>
</tr>
<tr>
<td>
_qa_control
</td>
<td>
0
</td>
<td>
Oracle internal parameter to control QA
</td>
</tr>
<tr>
<td>
_qa_lrg_type
</td>
<td>
0
</td>
<td>
Oracle internal parameter to specify QA lrg t
ype
</td>
</tr>
<tr>
<td>
_query_cost_rewrite
</td>
<td>
TRUE
</td>
<td>
perform the cost based rewrite with materiali
zed views
</td>
</tr>
<tr>
<td>
_query_execution_cache_max_size
</td>
<td>
65536
</td>
<td>
max size of query execution cache
</td>
</tr>
<tr>
<td>
_query_rewrite_1
</td>
<td>
TRUE
</td>
<td>
perform query rewrite before&amp;after or only be
fore view merging
</td>
</tr>
<tr>
<td>
_query_rewrite_2
</td>
<td>
TRUE
</td>
<td>
perform query rewrite before&amp;after or only af
ter view merging
</td>
</tr>
<tr>
<td>
_query_rewrite_drj
</td>
<td>
TRUE
</td>
<td>
mv rewrite and drop redundant joins
</td>
</tr>
<tr>
<td>
_query_rewrite_expression
</td>
<td>
TRUE
</td>
<td>
rewrite with cannonical form for expressions
</td>
</tr>
<tr>
<td>
_query_rewrite_fpc
</td>
<td>
TRUE
</td>
<td>
mv rewrite fresh partition containment
</td>
</tr>
<tr>
<td>
_query_rewrite_fudge
</td>
<td>
90
</td>
<td>
cost based query rewrite with MVs fudge facto
r
</td>
</tr>
<tr>
<td>
_query_rewrite_jgmigrate
</td>
<td>
TRUE
</td>
<td>
mv rewrite with jg migration
</td>
</tr>
<tr>
<td>
_query_rewrite_maxdisjunct
</td>
<td>
257
</td>
<td>
query rewrite max disjuncts
</td>
</tr>
<tr>
<td>
_query_rewrite_or_error
</td>
<td>
FALSE
</td>
<td>
allow query rewrite, if referenced tables are
 not dataless
</td>
</tr>
<tr>
<td>
_query_rewrite_setopgrw_enable
</td>
<td>
TRUE
</td>
<td>
perform general rewrite using set operator su
mmaries
</td>
</tr>
<tr>
<td>
_query_rewrite_vop_cleanup
</td>
<td>
TRUE
</td>
<td>
prune frocol chain before rewrite after view-
merging
</td>
</tr>
<tr>
<td>
_rcfg_parallel_fixwrite
</td>
<td>
TRUE
</td>
<td>
if TRUE enables parallel fixwrite at reconfig
uration
</td>
</tr>
<tr>
<td>
_rcfg_parallel_replay
</td>
<td>
TRUE
</td>
<td>
if TRUE enables parallel replay and cleanup a
t reconfiguration
</td>
</tr>
<tr>
<td>
_rcfg_parallel_verify
</td>
<td>
TRUE
</td>
<td>
if TRUE enables parallel verify at reconfigur
ation
</td>
</tr>
<tr>
<td>
_real_time_apply_arch_delay
</td>
<td>
0
</td>
<td>
Archival delay with real time apply
</td>
</tr>
<tr>
<td>
_real_time_apply_sim
</td>
<td>
0
</td>
<td>
Simulation value with real time apply
</td>
</tr>
<tr>
<td>
_realfree_heap_max_size
</td>
<td>
32768
</td>
<td>
minimum max total heap size, in Kbytes
</td>
</tr>
<tr>
<td>
_realfree_heap_mode
</td>
<td>
0
</td>
<td>
mode flags for real-free heap
</td>
</tr>
<tr>
<td>
_realfree_heap_pagesize_hint
</td>
<td>
65536
</td>
<td>
hint for real-free page size in bytes
</td>
</tr>
<tr>
<td>
_recoverable_recovery_batch_percent
</td>
<td>
50
</td>
<td>
Recoverable recovery batch size (percentage o
f buffer cache)
</td>
</tr>
<tr>
<td>
_recovery_asserts
</td>
<td>
FALSE
</td>
<td>
if TRUE, enable expensive integrity checks
</td>
</tr>
<tr>
<td>
_recovery_percentage
</td>
<td>
50
</td>
<td>
recovery buffer cache percentage
</td>
</tr>
<tr>
<td>
_recovery_verify_writes
</td>
<td>
FALSE
</td>
<td>
enable thread recovery write verify
</td>
</tr>
<tr>
<td>
_recursive_imu_transactions
</td>
<td>
FALSE
</td>
<td>
recursive transactions may be IMU
</td>
</tr>
<tr>
<td>
_redo_compatibility_check
</td>
<td>
FALSE
</td>
<td>
general and redo/undo compatibility sanity ch
eck
</td>
</tr>
<tr>
<td>
_release_insert_threshold
</td>
<td>
5
</td>
<td>
maximum number of unusable blocks to unlink f
rom freelist
</td>
</tr>
<tr>
<td>
_reliable_block_sends
</td>
<td>
FALSE
</td>
<td>
if TRUE, block sends across interconnect are
reliable
</td>
</tr>
<tr>
<td>
_remove_aggr_subquery
</td>
<td>
TRUE
</td>
<td>
enables removal of subsumed aggregated subque
ry
</td>
</tr>
<tr>
<td>
_resource_manager_always_on
</td>
<td>
TRUE
</td>
<td>
enable the resource manager always
</td>
</tr>
<tr>
<td>
_restore_spfile
</td>
<td>
&nbsp;
</td>
<td>
restore spfile to this location
</td>
</tr>
<tr>
<td>
_reuse_index_loop
</td>
<td>
5
</td>
<td>
number of blocks being examine for index bloc
k reuse
</td>
</tr>
<tr>
<td>
_right_outer_hash_enable
</td>
<td>
TRUE
</td>
<td>
Right Outer/Semi/Anti Hash Enabled
</td>
</tr>
<tr>
<td>
_rman_io_priority
</td>
<td>
3
</td>
<td>
priority at which rman backup i/o's are done
</td>
</tr>
<tr>
<td>
_rollback_segment_count
</td>
<td>
0
</td>
<td>
number of undo segments
</td>
</tr>
<tr>
<td>
_rollback_segment_initial
</td>
<td>
1
</td>
<td>
starting undo segment number
</td>
</tr>
<tr>
<td>
_rollback_stopat
</td>
<td>
0
</td>
<td>
stop at -position to step rollback
</td>
</tr>
<tr>
<td>
_row_cache_cursors
</td>
<td>
20
</td>
<td>
number of cached cursors for row cache manage
ment
</td>
</tr>
<tr>
<td>
_row_cr
</td>
<td>
TRUE
</td>
<td>
enable row cr for all sql
</td>
</tr>
<tr>
<td>
_row_locking
</td>
<td>
always
</td>
<td>
row-locking
</td>
</tr>
<tr>
<td>
_rowsource_execution_statistics
</td>
<td>
FALSE
</td>
<td>
if TRUE, Oracle will collect rowsource statis
tics
</td>
</tr>
<tr>
<td>
_rowsource_statistics_sampfreq
</td>
<td>
128
</td>
<td>
frequency of rowsource statistic sampling (mu
st be a power of 2)
</td>
</tr>
<tr>
<td>
_rowsrc_trace_level
</td>
<td>
0
</td>
<td>
Row source tree tracing level
</td>
</tr>
<tr>
<td>
_sample_rows_per_block
</td>
<td>
4
</td>
<td>
number of rows per block used for sampling IO
 optimization
</td>
</tr>
<tr>
<td>
_second_spare_parameter
</td>
<td>
&nbsp;
</td>
<td>
second spare parameter - integer
</td>
</tr>
<tr>
<td>
_selfjoin_mv_duplicates
</td>
<td>
TRUE
</td>
<td>
control rewrite self-join algorithm
</td>
</tr>
<tr>
<td>
_selftune_checkpoint_write_pct
</td>
<td>
3
</td>
<td>
Percentage of total physical i/os for self-tu
ne ckpt
</td>
</tr>
<tr>
<td>
_selftune_checkpointing_lag
</td>
<td>
300
</td>
<td>
Self-tune checkpointing lag the tail of the r
edo log
</td>
</tr>
<tr>
<td>
_send_ast_to_foreground
</td>
<td>
TRUE
</td>
<td>
if TRUE, send ast message to foreground
</td>
</tr>
<tr>
<td>
_send_close_with_block
</td>
<td>
TRUE
</td>
<td>
if TRUE, send close with block even with dire
ct sends
</td>
</tr>
<tr>
<td>
_send_requests_to_pi
</td>
<td>
TRUE
</td>
<td>
if TRUE, try to send CR requests to PI buffer
s
</td>
</tr>
<tr>
<td>
_serial_direct_read
</td>
<td>
FALSE
</td>
<td>
enable direct read in serial
</td>
</tr>
<tr>
<td>
_serial_recovery
</td>
<td>
FALSE
</td>
<td>
force serial recovery or parallel recovery
</td>
</tr>
<tr>
<td>
_serializable
</td>
<td>
FALSE
</td>
<td>
serializable
</td>
</tr>
<tr>
<td>
_session_cached_instantiations
</td>
<td>
60
</td>
<td>
Number of pl/sql instantiations to cache in a
 session.
</td>
</tr>
<tr>
<td>
_session_context_size
</td>
<td>
10000
</td>
<td>
session app context size
</td>
</tr>
<tr>
<td>
_session_idle_bit_latches
</td>
<td>
0
</td>
<td>
one latch per session or a latch per group of
 sessions
</td>
</tr>
<tr>
<td>
_session_idle_check_interval
</td>
<td>
60
</td>
<td>
Resource Manager session idle limit check int
erval in seconds
</td>
</tr>
<tr>
<td>
_session_kept_cursor_pins
</td>
<td>
0
</td>
<td>
Number of cursors pins to keep in a session
</td>
</tr>
<tr>
<td>
_session_wait_history
</td>
<td>
10
</td>
<td>
enable session wait history collection
</td>
</tr>
<tr>
<td>
_seventh_spare_parameter
</td>
<td>
&nbsp;
</td>
<td>
seventh spare parameter - string list
</td>
</tr>
<tr>
<td>
_shared_pool_max_size
</td>
<td>
0
</td>
<td>
shared pool maximum size when auto SGA enable
d
</td>
</tr>
<tr>
<td>
_shared_pool_reserved_min_alloc
</td>
<td>
4400
</td>
<td>
minimum allocation size in bytes for reserved
 area of shared pool
</td>
</tr>
<tr>
<td>
_shared_pool_reserved_pct
</td>
<td>
5
</td>
<td>
percentage memory of the shared pool allocate
d for the reserved area
</td>
</tr>
<tr>
<td>
_short_stack_timeout_ms
</td>
<td>
30000
</td>
<td>
short stack timeout in ms
</td>
</tr>
<tr>
<td>
_shrunk_aggs_disable_threshold
</td>
<td>
60
</td>
<td>
percentage of exceptions at which to switch t
o full length aggs
</td>
</tr>
<tr>
<td>
_shrunk_aggs_enabled
</td>
<td>
TRUE
</td>
<td>
enable use of variable sized buffers for non-
distinct aggregates
</td>
</tr>
<tr>
<td>
_side_channel_batch_size
</td>
<td>
200
</td>
<td>
number of messages to batch in a side channel
 message (DFS)
</td>
</tr>
<tr>
<td>
_side_channel_batch_timeout
</td>
<td>
6
</td>
<td>
timeout before shipping out the batched side
channelmessages
</td>
</tr>
<tr>
<td>
_simple_view_merging
</td>
<td>
TRUE
</td>
<td>
control simple view merging performed by the
optimizer
</td>
</tr>
<tr>
<td>
_simulator_bucket_mindelta
</td>
<td>
8192
</td>
<td>
LRU bucket minimum delta
</td>
</tr>
<tr>
<td>
_simulator_internal_bound
</td>
<td>
10
</td>
<td>
simulator internal bound percent
</td>
</tr>
<tr>
<td>
_simulator_lru_rebalance_sizthr
</td>
<td>
2
</td>
<td>
LRU list rebalance threshold (size)
</td>
</tr>
<tr>
<td>
_simulator_lru_rebalance_thresh
</td>
<td>
10240
</td>
<td>
LRU list rebalance threshold (count)
</td>
</tr>
<tr>
<td>
_simulator_lru_scan_count
</td>
<td>
8
</td>
<td>
LRU scan count
</td>
</tr>
<tr>
<td>
_simulator_pin_inval_maxcnt
</td>
<td>
16
</td>
<td>
maximum count of invalid chunks on pin list
</td>
</tr>
<tr>
<td>
_simulator_reserved_heap_count
</td>
<td>
4096
</td>
<td>
simulator reserved heap count
</td>
</tr>
<tr>
<td>
_simulator_reserved_obj_count
</td>
<td>
1024
</td>
<td>
simulator reserved object count
</td>
</tr>
<tr>
<td>
_simulator_sampling_factor
</td>
<td>
2
</td>
<td>
sampling factor for the simulator
</td>
</tr>
<tr>
<td>
_simulator_upper_bound_multiple
</td>
<td>
2
</td>
<td>
upper bound multiple of pool size
</td>
</tr>
<tr>
<td>
_single_process
</td>
<td>
FALSE
</td>
<td>
run without detached processes
</td>
</tr>
<tr>
<td>
_sixth_spare_parameter
</td>
<td>
&nbsp;
</td>
<td>
sixth spare parameter - string list
</td>
</tr>
<tr>
<td>
_skgxp_reaping
</td>
<td>
1000
</td>
<td>
tune skgxp OSD reaping limit
</td>
</tr>
<tr>
<td>
_skgxp_udp_ach_reaping_time
</td>
<td>
120
</td>
<td>
time in minutes before idle ach's are reaped
</td>
</tr>
<tr>
<td>
_skgxp_udp_hiwat_warn
</td>
<td>
1000
</td>
<td>
ach hiwat mark warning interval
</td>
</tr>
<tr>
<td>
_skgxp_udp_interface_detection_time_secs
</td>
<td>
60
</td>
<td>
time in seconds between interface detection c
hecks
</td>
</tr>
<tr>
<td>
_skgxp_udp_keep_alive_ping_timer_secs
</td>
<td>
300
</td>
<td>
connection idle time in seconds before keep a
live is initiated. min: 30 sec max: 1800 sec
default: 300 sec
</td>
</tr>
<tr>
<td>
_skgxp_udp_timed_wait_buffering
</td>
<td>
1024
</td>
<td>
diagnostic log buffering space (in bytes) for
 timed wait (0 means unbufferd
</td>
</tr>
<tr>
<td>
_skgxp_udp_timed_wait_seconds
</td>
<td>
5
</td>
<td>
time in seconds before timed wait is invoked
</td>
</tr>
<tr>
<td>
_skip_assume_msg
</td>
<td>
TRUE
</td>
<td>
if TRUE, skip assume message for consigns at
the master
</td>
</tr>
<tr>
<td>
_slave_mapping_enabled
</td>
<td>
TRUE
</td>
<td>
enable slave mapping when TRUE
</td>
</tr>
<tr>
<td>
_slave_mapping_group_size
</td>
<td>
0
</td>
<td>
force the number of slave group in a slave ma
pper
</td>
</tr>
<tr>
<td>
_small_table_threshold
</td>
<td>
119
</td>
<td>
threshold level of table size for direct read
s
</td>
</tr>
<tr>
<td>
_smm_advice_enabled
</td>
<td>
TRUE
</td>
<td>
if TRUE, enable v$pga_advice
</td>
</tr>
<tr>
<td>
_smm_advice_log_size
</td>
<td>
0
</td>
<td>
overwrites default size of the PGA advice wor
karea history log
</td>
</tr>
<tr>
<td>
_smm_auto_cost_enabled
</td>
<td>
TRUE
</td>
<td>
if TRUE, use the AUTO size policy cost functi
ons
</td>
</tr>
<tr>
<td>
_smm_auto_max_io_size
</td>
<td>
248
</td>
<td>
Maximum IO size (in KB) used by sort/hash-joi
n in auto mode
</td>
</tr>
<tr>
<td>
_smm_auto_min_io_size
</td>
<td>
56
</td>
<td>
Minimum IO size (in KB) used by sort/hash-joi
n in auto mode
</td>
</tr>
<tr>
<td>
_smm_bound
</td>
<td>
0
</td>
<td>
overwrites memory manager automatically compu
ted bound
</td>
</tr>
<tr>
<td>
_smm_control
</td>
<td>
0
</td>
<td>
provides controls on the memory manager
</td>
</tr>
<tr>
<td>
_smm_freeable_retain
</td>
<td>
5120
</td>
<td>
value in KB of the instance freeable PGA memo
ry to retain
</td>
</tr>
<tr>
<td>
_smm_isort_cap
</td>
<td>
102400
</td>
<td>
maximum work area for insertion sort(v1)
</td>
</tr>
<tr>
<td>
_smm_max_size
</td>
<td>
23961
</td>
<td>
maximum work area size in auto mode (serial)
</td>
</tr>
<tr>
<td>
_smm_min_size
</td>
<td>
128
</td>
<td>
minimum work area size in auto mode
</td>
</tr>
<tr>
<td>
_smm_px_max_size
</td>
<td>
59904
</td>
<td>
maximum work area size in auto mode (global)
</td>
</tr>
<tr>
<td>
_smm_retain_size
</td>
<td>
0
</td>
<td>
work area retain size in SGA for shared serve
r sessions (0 for AUTO)
</td>
</tr>
<tr>
<td>
_smm_trace
</td>
<td>
0
</td>
<td>
Turn on/off tracing for SQL memory manager
</td>
</tr>
<tr>
<td>
_smon_internal_errlimit
</td>
<td>
100
</td>
<td>
limit of SMON internal errors
</td>
</tr>
<tr>
<td>
_smu_debug_mode
</td>
<td>
0
</td>
<td>
&lt;debug-flag&gt; - set debug event for testing SM
U operations
</td>
</tr>
<tr>
<td>
_smu_error_simulation_site
</td>
<td>
0
</td>
<td>
site ID of error simulation in KTU code
</td>
</tr>
<tr>
<td>
_smu_error_simulation_type
</td>
<td>
0
</td>
<td>
error type for error simulation in KTU code
</td>
</tr>
<tr>
<td>
_smu_timeouts
</td>
<td>
&nbsp;
</td>
<td>
comma-separated *AND double-quoted* list of A
UM timeouts: mql, tur, sess_exprn, qry_exprn,
 slot_intvl
</td>
</tr>
<tr>
<td>
_sort_elimination_cost_ratio
</td>
<td>
0
</td>
<td>
cost ratio for sort eimination under first_ro
ws mode
</td>
</tr>
<tr>
<td>
_sort_multiblock_read_count
</td>
<td>
2
</td>
<td>
multi-block read count for sort
</td>
</tr>
<tr>
<td>
_spin_count
</td>
<td>
2000
</td>
<td>
Amount to spin waiting for a latch
</td>
</tr>
<tr>
<td>
_spr_max_rules
</td>
<td>
10000
</td>
<td>
maximum number of rules in sql spreadsheet
</td>
</tr>
<tr>
<td>
_spr_push_pred_refspr
</td>
<td>
TRUE
</td>
<td>
push predicates through reference spreadsheet
</td>
</tr>
<tr>
<td>
_spr_use_AW_AS
</td>
<td>
TRUE
</td>
<td>
enable AW for hash table in spreadsheet
</td>
</tr>
<tr>
<td>
_spr_use_hash_table
</td>
<td>
FALSE
</td>
<td>
use hash table for spreadsheet
</td>
</tr>
<tr>
<td>
_sql_connect_capability_override
</td>
<td>
0
</td>
<td>
SQL Connect Capability Table Override
</td>
</tr>
<tr>
<td>
_sql_connect_capability_table
</td>
<td>
&nbsp;
</td>
<td>
SQL Connect Capability Table (testing only)
</td>
</tr>
<tr>
<td>
_sql_hash_debug
</td>
<td>
0
</td>
<td>
Hash value of the SQL statement to debug
</td>
</tr>
<tr>
<td>
_sql_model_unfold_forloops
</td>
<td>
RUN_TIME
</td>
<td>
specifies compile-time unfolding of sql model
 forloops
</td>
</tr>
<tr>
<td>
_sqlexec_progression_cost
</td>
<td>
1000
</td>
<td>
sql execution progression monitoring cost thr
eshold
</td>
</tr>
<tr>
<td>
_sqltune_category_parsed
</td>
<td>
DEFAULT
</td>
<td>
Parsed category qualifier for applying hintse
ts
</td>
</tr>
<tr>
<td>
_sta_control
</td>
<td>
0
</td>
<td>
SQL Tuning Advisory control parameter
</td>
</tr>
<tr>
<td>
_stack_guard_level
</td>
<td>
0
</td>
<td>
stack guard level
</td>
</tr>
<tr>
<td>
_static_backgrounds
</td>
<td>
&nbsp;
</td>
<td>
static backgrounds
</td>
</tr>
<tr>
<td>
_stn_trace
</td>
<td>
0
</td>
<td>
SQL tracing parameter
</td>
</tr>
<tr>
<td>
_streams_pool_max_size
</td>
<td>
0
</td>
<td>
streams pool maximum size when auto SGA enabl
ed
</td>
</tr>
<tr>
<td>
_subquery_pruning_cost_factor
</td>
<td>
20
</td>
<td>
subquery pruning cost factor
</td>
</tr>
<tr>
<td>
_subquery_pruning_enabled
</td>
<td>
TRUE
</td>
<td>
enable the use of subquery predicates to perf
orm pruning
</td>
</tr>
<tr>
<td>
_subquery_pruning_mv_enabled
</td>
<td>
FALSE
</td>
<td>
enable the use of subquery predicates with MV
s to perform pruning
</td>
</tr>
<tr>
<td>
_subquery_pruning_reduction
</td>
<td>
50
</td>
<td>
subquery pruning reduction factor
</td>
</tr>
<tr>
<td>
_swrf_metric_frequent_mode
</td>
<td>
FALSE
</td>
<td>
Enable/disable SWRF Metric Frequent Mode Coll
ection
</td>
</tr>
<tr>
<td>
_swrf_mmon_dbfus
</td>
<td>
TRUE
</td>
<td>
Enable/disable SWRF MMON DB Feature Usage
</td>
</tr>
<tr>
<td>
_swrf_mmon_flush
</td>
<td>
TRUE
</td>
<td>
Enable/disable SWRF MMON FLushing
</td>
</tr>
<tr>
<td>
_swrf_mmon_metrics
</td>
<td>
TRUE
</td>
<td>
Enable/disable SWRF MMON Metrics Collection
</td>
</tr>
<tr>
<td>
_swrf_on_disk_enabled
</td>
<td>
TRUE
</td>
<td>
Parameter to enable/disable SWRF
</td>
</tr>
<tr>
<td>
_swrf_test_action
</td>
<td>
0
</td>
<td>
test action parameter for SWRF
</td>
</tr>
<tr>
<td>
_swrf_test_dbfus
</td>
<td>
FALSE
</td>
<td>
Enable/disable DB Feature Usage Testing
</td>
</tr>
<tr>
<td>
_synonym_repoint_tracing
</td>
<td>
FALSE
</td>
<td>
whether to trace metadata comparisons for syn
onym repointing
</td>
</tr>
<tr>
<td>
_sysaux_test_param
</td>
<td>
1
</td>
<td>
test parameter for SYSAUX
</td>
</tr>
<tr>
<td>
_system_index_caching
</td>
<td>
0
</td>
<td>
optimizer percent system index caching
</td>
</tr>
<tr>
<td>
_system_trig_enabled
</td>
<td>
TRUE
</td>
<td>
are system triggers enabled
</td>
</tr>
<tr>
<td>
_ta_lns_wait_for_arch_log
</td>
<td>
20
</td>
<td>
LNS Wait time for arhcived version of online
log
</td>
</tr>
<tr>
<td>
_table_lookup_prefetch_size
</td>
<td>
40
</td>
<td>
table lookup prefetch vector size
</td>
</tr>
<tr>
<td>
_table_lookup_prefetch_thresh
</td>
<td>
2
</td>
<td>
table lookup prefetch threshold
</td>
</tr>
<tr>
<td>
_table_scan_cost_plus_one
</td>
<td>
TRUE
</td>
<td>
bump estimated full table scan and index ffs
cost by one
</td>
</tr>
<tr>
<td>
_target_rba_max_lag_percentage
</td>
<td>
90
</td>
<td>
target rba max log lag percentage
</td>
</tr>
<tr>
<td>
_tdb_debug_mode
</td>
<td>
16
</td>
<td>
set debug mode for testing transportable data
base
</td>
</tr>
<tr>
<td>
_temp_tran_block_threshold
</td>
<td>
100
</td>
<td>
number of blocks for a dimension before we te
mp transform
</td>
</tr>
<tr>
<td>
_temp_tran_cache
</td>
<td>
TRUE
</td>
<td>
determines if temp table is created with cach
e option
</td>
</tr>
<tr>
<td>
_test_ksusigskip
</td>
<td>
5
</td>
<td>
test the function ksusigskip
</td>
</tr>
<tr>
<td>
_test_param_1
</td>
<td>
25
</td>
<td>
test parmeter 1 - integer
</td>
</tr>
<tr>
<td>
_test_param_2
</td>
<td>
&nbsp;
</td>
<td>
test parameter 2 - string
</td>
</tr>
<tr>
<td>
_test_param_3
</td>
<td>
&nbsp;
</td>
<td>
test parameter 3 - string
</td>
</tr>
<tr>
<td>
_test_param_4
</td>
<td>
&nbsp;
</td>
<td>
test parameter 4 - string list
</td>
</tr>
<tr>
<td>
_test_param_5
</td>
<td>
25
</td>
<td>
test parmeter 5 - deprecated integer
</td>
</tr>
<tr>
<td>
_test_param_6
</td>
<td>
0
</td>
<td>
test parmeter 6 - size (ub8)
</td>
</tr>
<tr>
<td>
_third_spare_parameter
</td>
<td>
&nbsp;
</td>
<td>
third spare parameter - integer
</td>
</tr>
<tr>
<td>
_threshold_alerts_enable
</td>
<td>
1
</td>
<td>
if 1, issue threshold-based alerts
</td>
</tr>
<tr>
<td>
_total_large_extent_memory
</td>
<td>
0
</td>
<td>
Total memory for allocating large extents
</td>
</tr>
<tr>
<td>
_tq_dump_period
</td>
<td>
0
</td>
<td>
time period for duping of TQ statistics (s)
</td>
</tr>
<tr>
<td>
_trace_archive
</td>
<td>
FALSE
</td>
<td>
start DIAG process
</td>
</tr>
<tr>
<td>
_trace_buffer_flushes
</td>
<td>
FALSE
</td>
<td>
trace buffer flushes if otrace cacheIO event
is set
</td>
</tr>
<tr>
<td>
_trace_buffer_gets
</td>
<td>
FALSE
</td>
<td>
trace kcb buffer gets if otrace cacheIO event
 is set
</td>
</tr>
<tr>
<td>
_trace_buffer_wait_timeouts
</td>
<td>
0
</td>
<td>
trace buffer busy wait timeouts
</td>
</tr>
<tr>
<td>
_trace_buffer_wrap_timestamp
</td>
<td>
TRUE
</td>
<td>
enable KST timestamp on trace buffer wrap
</td>
</tr>
<tr>
<td>
_trace_buffers
</td>
<td>
ALL:256
</td>
<td>
trace buffer sizes per process
</td>
</tr>
<tr>
<td>
_trace_cr_buffer_creates
</td>
<td>
FALSE
</td>
<td>
trace cr buffer creates if otrace cacheIO eve
nt is set
</td>
</tr>
<tr>
<td>
_trace_events
</td>
<td>
&nbsp;
</td>
<td>
trace events enabled at startup
</td>
</tr>
<tr>
<td>
_trace_file_size
</td>
<td>
65536
</td>
<td>
maximum size of trace file (in bytes)
</td>
</tr>
<tr>
<td>
_trace_files_public
</td>
<td>
FALSE
</td>
<td>
Create publicly accessible trace files
</td>
</tr>
<tr>
<td>
_trace_flush_processes
</td>
<td>
ALL
</td>
<td>
trace data archived by DIAG for these process
es
</td>
</tr>
<tr>
<td>
_trace_multi_block_reads
</td>
<td>
FALSE
</td>
<td>
trace multi_block reads if otrace cacheIO eve
nt is set
</td>
</tr>
<tr>
<td>
_trace_navigation_scope
</td>
<td>
global
</td>
<td>
enabling trace navigation linking
</td>
</tr>
<tr>
<td>
_trace_options
</td>
<td>
text,multiple
</td>
<td>
trace data flush options
</td>
</tr>
<tr>
<td>
_trace_pin_time
</td>
<td>
0
</td>
<td>
trace how long a current pin is held
</td>
</tr>
<tr>
<td>
_trace_processes
</td>
<td>
ALL
</td>
<td>
enable KST tracing in process
</td>
</tr>
<tr>
<td>
_transaction_auditing
</td>
<td>
TRUE
</td>
<td>
transaction auditing records generated in the
 redo log
</td>
</tr>
<tr>
<td>
_transaction_recovery_servers
</td>
<td>
0
</td>
<td>
max number of parallel recovery slaves that m
ay be used
</td>
</tr>
<tr>
<td>
_truncate_optimization_enabled
</td>
<td>
TRUE
</td>
<td>
do truncate optimization if set to TRUE
</td>
</tr>
<tr>
<td>
_tsm_connect_string
</td>
<td>
&nbsp;
</td>
<td>
TSM test connect string
</td>
</tr>
<tr>
<td>
_tsm_disable_auto_cleanup
</td>
<td>
1
</td>
<td>
Disable TSM auto cleanup actions
</td>
</tr>
<tr>
<td>
_tts_allow_charset_mismatch
</td>
<td>
FALSE
</td>
<td>
allow plugging in a tablespace with an incomp
atible character set
</td>
</tr>
<tr>
<td>
_two_pass
</td>
<td>
TRUE
</td>
<td>
enable two-pass thread recovery
</td>
</tr>
<tr>
<td>
_two_pass_reverse_polish_enabled
</td>
<td>
TRUE
</td>
<td>
uses two-pass reverse polish alg. to generate
 canonical forms
</td>
</tr>
<tr>
<td>
_uga_cga_large_extent_size
</td>
<td>
262144
</td>
<td>
UGA/CGA large extent size
</td>
</tr>
<tr>
<td>
_ultrafast_latch_statistics
</td>
<td>
TRUE
</td>
<td>
maintain fast-path statistics for ultrafast l
atches
</td>
</tr>
<tr>
<td>
_undo_autotune
</td>
<td>
TRUE
</td>
<td>
enable auto tuning of undo_retention
</td>
</tr>
<tr>
<td>
_undo_debug_mode
</td>
<td>
0
</td>
<td>
debug flag for undo related operations
</td>
</tr>
<tr>
<td>
_undo_debug_usage
</td>
<td>
0
</td>
<td>
invoke undo usage functions for testing
</td>
</tr>
<tr>
<td>
_union_rewrite_for_gs
</td>
<td>
YES_GSET_MVS
</td>
<td>
expand queries with GSets into UNIONs for rew
rite
</td>
</tr>
<tr>
<td>
_unnest_subquery
</td>
<td>
TRUE
</td>
<td>
enables unnesting of correlated subqueries
</td>
</tr>
<tr>
<td>
_unused_block_compression
</td>
<td>
FALSE
</td>
<td>
enable unused block compression
</td>
</tr>
<tr>
<td>
_use_column_stats_for_function
</td>
<td>
TRUE
</td>
<td>
enable the use of column statistics for DDP f
unctions
</td>
</tr>
<tr>
<td>
_use_ism
</td>
<td>
TRUE
</td>
<td>
Enable Shared Page Tables - ISM
</td>
</tr>
<tr>
<td>
_use_ism_for_pga
</td>
<td>
TRUE
</td>
<td>
Use ISM for allocating large extents
</td>
</tr>
<tr>
<td>
_use_nosegment_indexes
</td>
<td>
FALSE
</td>
<td>
use nosegment indexes in explain plan
</td>
</tr>
<tr>
<td>
_use_realfree_heap
</td>
<td>
TRUE
</td>
<td>
use real-free based allocator for PGA memory
</td>
</tr>
<tr>
<td>
_use_seq_process_cache
</td>
<td>
TRUE
</td>
<td>
whether to use process local seq cache
</td>
</tr>
<tr>
<td>
_use_vector_post
</td>
<td>
TRUE
</td>
<td>
use vector post
</td>
</tr>
<tr>
<td>
_validate_flashback_database
</td>
<td>
FALSE
</td>
<td>
Scan database to validate result of flashback
 database
</td>
</tr>
<tr>
<td>
_vendor_lib_loc
</td>
<td>
&nbsp;
</td>
<td>
Vendor library search root directory
</td>
</tr>
<tr>
<td>
_verify_flashback_redo
</td>
<td>
TRUE
</td>
<td>
Verify that the redo logs needed for flashbac
k are available
</td>
</tr>
<tr>
<td>
_verify_undo_quota
</td>
<td>
FALSE
</td>
<td>
TRUE - verify consistency of undo quota stati
stics
</td>
</tr>
<tr>
<td>
_very_large_partitioned_table
</td>
<td>
1024
</td>
<td>
very_large_partitioned_table
</td>
</tr>
<tr>
<td>
_wait_for_sync
</td>
<td>
TRUE
</td>
<td>
wait for sync on commit MUST BE ALWAYS TRUE
</td>
</tr>
<tr>
<td>
_walk_insert_threshold
</td>
<td>
0
</td>
<td>
maximum number of unusable blocks to walk acr
oss freelist
</td>
</tr>
<tr>
<td>
_watchpoint_on
</td>
<td>
FALSE
</td>
<td>
is the watchpointing feature turned on?
</td>
</tr>
<tr>
<td>
_windowfunc_optimization_settings
</td>
<td>
0
</td>
<td>
settings for window function optimizations
</td>
</tr>
<tr>
<td>
_write_clones
</td>
<td>
3
</td>
<td>
write clones flag
</td>
</tr>
<tr>
<td>
_xpl_peeked_binds_log_size
</td>
<td>
8192
</td>
<td>
maximum bytes for logging peeked bind values
for V$SQL_PLAN (0 = OFF)
</td>
</tr>
<tr>
<td>
_xpl_trace
</td>
<td>
0
</td>
<td>
Explain Plan tracing parameter
</td>
</tr>
<tr>
<td>
_xsolapi_auto_materialization_bound
</td>
<td>
20
</td>
<td>
OLAP API lower bound for auto materialization
.
</td>
</tr>
<tr>
<td>
_xsolapi_auto_materialization_type
</td>
<td>
PRED_AND_RC
</td>
<td>
OLAP API behavior for auto materialization
</td>
</tr>
<tr>
<td>
_xsolapi_debug_output
</td>
<td>
&nbsp;
</td>
<td>
OLAP API debug output disposition
</td>
</tr>
<tr>
<td>
_xsolapi_densify_cubes
</td>
<td>
TABULAR
</td>
<td>
OLAP API cube densification
</td>
</tr>
<tr>
<td>
_xsolapi_dimension_group_creation
</td>
<td>
OVERFETCH
</td>
<td>
OLAP API symmetric overfetch
</td>
</tr>
<tr>
<td>
_xsolapi_fetch_type
</td>
<td>
PARTIAL
</td>
<td>
OLAP API fetch type
</td>
</tr>
<tr>
<td>
_xsolapi_load_at_process_start
</td>
<td>
NEVER
</td>
<td>
When to load OLAP API library at server proce
ss start
</td>
</tr>
<tr>
<td>
_xsolapi_materialization_rowcache_min_rows_fo
r_use
</td>
<td>
1
</td>
<td>
OLAP API min number of rows required to use r
owcache in query materialization
</td>
</tr>
<tr>
<td>
_xsolapi_materialize_sources
</td>
<td>
TRUE
</td>
<td>
OLAP API Enable source materialization
</td>
</tr>
<tr>
<td>
_xsolapi_source_trace
</td>
<td>
FALSE
</td>
<td>
OLAP API output Source definitions to trace f
ile
</td>
</tr>
<tr>
<td>
_xsolapi_sql_all_multi_join_non_base_hints
</td>
<td>
&nbsp;
</td>
<td>
OLAP API multi-join non-base hints
</td>
</tr>
<tr>
<td>
_xsolapi_sql_all_non_base_hints
</td>
<td>
&nbsp;
</td>
<td>
OLAP API non-base hints
</td>
</tr>
<tr>
<td>
_xsolapi_sql_auto_dimension_hints
</td>
<td>
FALSE
</td>
<td>
OLAP API enable automatic dimension hints
</td>
</tr>
<tr>
<td>
_xsolapi_sql_auto_measure_hints
</td>
<td>
TRUE
</td>
<td>
OLAP API enable automatic measure hints
</td>
</tr>
<tr>
<td>
_xsolapi_sql_dimension_hints
</td>
<td>
&nbsp;
</td>
<td>
OLAP API dimension hints
</td>
</tr>
<tr>
<td>
_xsolapi_sql_hints
</td>
<td>
&nbsp;
</td>
<td>
OLAP API generic hints
</td>
</tr>
<tr>
<td>
_xsolapi_sql_measure_hints
</td>
<td>
&nbsp;
</td>
<td>
OLAP API measure hints
</td>
</tr>
<tr>
<td>
_xsolapi_sql_optimize
</td>
<td>
TRUE
</td>
<td>
OLAP API enable optimization
</td>
</tr>
<tr>
<td>
_xsolapi_sql_prepare_stmt_cache_size
</td>
<td>
16
</td>
<td>
OLAP API prepare statement cache size
</td>
</tr>
<tr>
<td>
_xsolapi_sql_remove_columns
</td>
<td>
TRUE
</td>
<td>
OLAP API enable remove unused columns optimiz
ations
</td>
</tr>
<tr>
<td>
_xsolapi_sql_result_set_cache_size
</td>
<td>
32
</td>
<td>
OLAP API result set cache size
</td>
</tr>
<tr>
<td>
_xsolapi_sql_symmetric_predicate
</td>
<td>
TRUE
</td>
<td>
OLAP API enable symmetric predicate for dimen
sion groups
</td>
</tr>
<tr>
<td>
_xsolapi_sql_top_dimension_hints
</td>
<td>
&nbsp;
</td>
<td>
OLAP API top dimension hints
</td>
</tr>
<tr>
<td>
_xsolapi_sql_top_measure_hints
</td>
<td>
&nbsp;
</td>
<td>
OLAP API top measure hints
</td>
</tr>
<tr>
<td>
_xsolapi_sql_use_bind_variables
</td>
<td>
TRUE
</td>
<td>
OLAP API enable bind variables optimization
</td>
</tr>
<tr>
<td>
_xt_coverage
</td>
<td>
none
</td>
<td>
external tables code coverage parameter
</td>
</tr>
<tr>
<td>
_xt_trace
</td>
<td>
none
</td>
<td>
external tables trace parameter
</td>
</tr>
<tr>
<td>
_xtbuffer_size
</td>
<td>
0
</td>
<td>
buffer size in KB needed for populate/query o
peration
</td>
</tr>
<tr>
<td>
_xtts_allow_pre10
</td>
<td>
FALSE
</td>
<td>
allow cross platform for pre10 compatible tab
lespace
</td>
</tr>
<tr>
<td>
_xtts_set_platform_info
</td>
<td>
FALSE
</td>
<td>
set cross platform info during file header re
ad
</td>
</tr>
<tr>
<td>
_yield_check_interval
</td>
<td>
100000
</td>
<td>
interval to check whether actses should yield
</td>
</tr>
</table>
<p>

1124 rows selected.<br>
<br>


